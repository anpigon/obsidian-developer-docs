[{"body":"Our goal for community plugins and themes is to make it easy for users to safely modify and expand the capabilities of Obsidian, while prioritizing private and offline usage of the app.\nAll community plugins and themes added to the Obsidian directory must respect the following policies. Every plugin and theme is individually vetted before being included in the directory. Plugins and themes that don’t follow these policies will be removed from the directory.\nThese policies only apply to plugins listed in the official Obsidian directory. These policies do not apply to plugins installed outside of the Obsidian directory, but they are nonetheless good practices to follow.\nPolicies Not allowed Plugins and themes must not:\nObfuscate code to hide its purpose. Insert dynamic ads that are loaded over the internet. Insert static ads outside a plugin’s own interface. Include client-side telemetry. Include a mechanism that updates the plugin. Themes may not load assets from the network. To bundle an asset, see [[Embed fonts and images in your theme|this guide]]. Disclosures The following are only allowed if clearly indicated in your README:\nPayment is required for full access. An account is required for full access. Network use. Clearly explain which remote services are used and why they’re needed. Accessing files outside of Obsidian vaults. Clearly explain why this is needed. Static ads such as banners and pop-up messages within the plugin’s own interface. Server-side telemetry. Link to a privacy policy that explains how the data is handled must be included. Close sourced code. This will be handled on a case by case basis. Copyright and licensing All community plugins and themes must follow these requirements:\nInclude a LICENSE file and clearly indicate the license of your plugin or theme. Comply with the original licenses of any code your plugin or theme makes use of, including attribution in the README if required. Respect Obsidian’s trademark policy. Don’t use the “Obsidian” trademark in a way that could confuse users into thinking your plugin or theme is a first-party creation. Reporting violations If you encounter a plugin or theme that violates the policies above, please let the developer know by opening a GitHub issue in their repository. Kindly check existing issues to see if it’s already reported.\nIf the developer doesn’t respond after 7 days, contact the Obsidian team. For serious violations, you can contact our team immediately.\nRemoving plugins and themes In case of a policy violation, we may attempt to contact the developer and provide a reasonable timeframe for them to resolve the problem.\nIf the problem isn’t resolved by then, we’ll remove plugins or themes from our directory.\nWe may immediately remove a plugin or theme if:\nThe plugin or theme appears to be malicious. The developer is uncooperative. This is a repeated violation. In addition, we may also remove plugins or themes that have become unmaintained or severely broken.\n","categories":"","description":"","excerpt":"Our goal for community plugins and themes is to make it easy for users …","ref":"/developer-policies/","tags":"","title":""},{"body":"커뮤니티 플러그인(Community Plugin)과 테마(Theme)에 대한 우리의 목표는 사용자가 앱의 개인적이고 오프라인 사용을 우선시하면서 Obsidian의 기능을 안전하게 수정하고 확장할 수 있도록 하는 것입니다.\nObsidian 디렉터리에 추가되는 모든 커뮤니티 플러그인과 테마는 다음 정책을 준수해야 합니다. 모든 플러그인과 테마는 디렉터리에 포함되기 전에 개별적으로 검토됩니다. 이러한 정책을 따르지 않는 플러그인과 테마는 디렉터리에서 제거됩니다.\n이러한 정책은 공식 Obsidian 디렉터리에 나열된 플러그인에만 적용됩니다. 이러한 정책은 Obsidian 디렉터리 외부에서 설치된 플러그인에는 적용되지 않지만, 그럼에도 불구하고 따르는 것이 좋은 관행입니다.\n정책 허용되지 않는 사항 플러그인과 테마는 다음을 해서는 안 됩니다:\n목적을 숨기기 위해 코드를 난독화(Obfuscate)하는 것 인터넷을 통해 로드되는 동적 광고(Dynamic Ad)를 삽입하는 것 플러그인 자체 인터페이스 외부에 정적 광고(Static Ad)를 삽입하는 것 클라이언트 측 텔레메트리(Client-side Telemetry)를 포함하는 것 플러그인을 업데이트하는 메커니즘을 포함하는 것 테마는 네트워크에서 자산(Asset)을 로드해서는 안 됩니다. 자산을 번들링하려면 [[Embed fonts and images in your theme|이 가이드]]를 참조하세요. 공개 사항 다음은 README에 명확히 표시된 경우에만 허용됩니다:\n전체 액세스를 위해 결제가 필요한 경우 전체 액세스를 위해 계정이 필요한 경우 네트워크 사용. 어떤 원격 서비스가 사용되는지와 왜 필요한지 명확히 설명하세요. Obsidian 볼트 외부의 파일에 액세스하는 경우. 왜 이것이 필요한지 명확히 설명하세요. 플러그인 자체 인터페이스 내의 배너 및 팝업 메시지와 같은 정적 광고 서버 측 텔레메트리(Server-side Telemetry). 데이터가 어떻게 처리되는지 설명하는 개인정보 보호정책에 대한 링크가 포함되어야 합니다. 비공개 소스 코드(Closed Source Code). 이는 사례별로 처리됩니다. 저작권 및 라이선스 모든 커뮤니티 플러그인과 테마는 다음 요구사항을 따라야 합니다:\nLICENSE 파일을 포함하고 플러그인 또는 테마의 라이선스를 명확히 표시하세요. 플러그인 또는 테마가 사용하는 모든 코드의 원본 라이선스를 준수하고, 필요한 경우 README에 저작자 표시를 포함하세요. Obsidian의 상표 정책을 존중하세요. 사용자가 플러그인이나 테마를 자사 제품으로 오해할 수 있는 방식으로 “Obsidian” 상표를 사용하지 마세요. 위반 신고 위의 정책을 위반하는 플러그인이나 테마를 발견하면 해당 저장소에서 GitHub 이슈(Issue)를 열어 개발자에게 알려주세요. 이미 신고되었는지 기존 이슈를 확인해 주세요.\n개발자가 7일 후에도 응답하지 않으면 Obsidian 팀에 연락하세요. 심각한 위반의 경우 즉시 우리 팀에 연락할 수 있습니다.\n플러그인 및 테마 제거 정책 위반의 경우 개발자에게 연락하여 문제를 해결할 수 있는 합리적인 기간을 제공할 수 있습니다.\n그때까지 문제가 해결되지 않으면 디렉터리에서 플러그인이나 테마를 제거합니다.\n다음의 경우 플러그인이나 테마를 즉시 제거할 수 있습니다:\n플러그인이나 테마가 악성으로 보이는 경우 개발자가 비협조적인 경우 반복적인 위반인 경우 또한 유지보수되지 않거나 심각하게 손상된 플러그인이나 테마도 제거할 수 있습니다.\n","categories":"","description":"","excerpt":"커뮤니티 플러그인(Community Plugin)과 테마(Theme)에 대한 우리의 목표는 사용자가 앱의 개인적이고 오프라인  …","ref":"/ko/developer-policies/","tags":"","title":""},{"body":"Obsidian Developer Docs Welcome to the official Obsidian Developer Documentation, where you can learn how to build plugins and themes for Obsidian. For tips on how to use Obsidian, visit the official Help site.\nPlugins Build plugins to extend the existing functionality in Obsidian using TypeScript.\n[[Build a plugin|Build your first plugin]] [[Submit your plugin]] Themes Design beautiful themes and snippets for Obsidian using CSS.\n[[Build a theme|Build your first theme]] [[Submit your theme]] [[CSS variables]] Join the developer community If you get stuck, or if you’re looking for feedback, join the community.\n#plugin-dev and #theme-dev channels on Discord. Developers \u0026 API and Share \u0026 showcase on the forum. Contributing If you see any errors or room for improvement on this site, or want to submit a PR, feel free to open an issue on our GitHub repository. Additional details are available on our readme.\nThank you in advance for contributing!\n","categories":"","description":"","excerpt":"Obsidian Developer Docs Welcome to the official Obsidian Developer …","ref":"/home/","tags":"","title":""},{"body":"Obsidian 개발자 문서 Obsidian용 플러그인(Plugin)과 테마(Theme)를 제작하는 방법을 배울 수 있는 공식 Obsidian 개발자 문서에 오신 것을 환영합니다. Obsidian 사용법에 대한 팁은 공식 도움말 사이트를 방문해 주세요.\n플러그인(Plugins) TypeScript를 사용하여 Obsidian의 기존 기능을 확장하는 플러그인을 제작하세요.\n[[Build a plugin|첫 번째 플러그인 제작하기]] [[Submit your plugin|플러그인 제출하기]] 테마(Themes) CSS를 사용하여 Obsidian용 아름다운 테마와 스니펫(Snippet)을 디자인하세요.\n[[Build a theme|첫 번째 테마 제작하기]] [[Submit your theme|테마 제출하기]] [[CSS variables|CSS 변수]] 개발자 커뮤니티 참여 막히는 부분이 있거나 피드백을 찾고 있다면 커뮤니티에 참여하세요.\nDiscord의 #plugin-dev와 #theme-dev 채널 포럼의 Developers \u0026 API와 Share \u0026 showcase 기여하기 이 사이트에서 오류를 발견하거나 개선할 부분이 있다면, 또는 PR(Pull Request)을 제출하고 싶다면 언제든지 GitHub 저장소에 이슈(Issue)를 열어주세요. 자세한 내용은 readme에서 확인할 수 있습니다.\n미리 기여해 주셔서 감사합니다!\n","categories":"","description":"","excerpt":"Obsidian 개발자 문서 Obsidian용 플러그인(Plugin)과 테마(Theme) …","ref":"/ko/home/","tags":"","title":""},{"body":"Add this checklist to your Obsidian Releasing \u0026 naming Remove placeholder names such as MyPlugin and SampleSettingTab. Don’t include the word “Obsidian” in your name unless it absolutely makes sense. Most of the time it’s redundant. Don’t include your plugin name in command names. Obsidian adds this for you. Don’t prefix commands with your plugin ID. Obsidian adds this for you. Don’t include main.js in your repo. Only include it in your releases. If you haven’t, consider add a fundingUrl so that users of your plugin can show some support. Learn more. Compatibility Don’t provide default hotkeys for commands. Learn more. Don’t override core styling. If needed, add your own class and make the styling only apply to your class. Do scan your code for deprecated methods (they usually show up as strikeout text in IDEs). Don’t assign styles via JavaScript or in HTML. Learn more. Don’t access the hardcoded .obsidian folder if you need to access the configuration directory. The location could be customized, so please use Vault.configDir instead. Mobile support Please only complete this section if you have isDesktopOnly set to false in your manifest.\nDon’t use node.js modules such as fs, path, and electron. Don’t use regex lookbehinds if you want to support iOS versions lower than 16.4 (ignore this if you don’t use regex in your plugin). Learn more. Don’t use the FileSystemAdapter class. Don’t use process.platform, use Obsidian’s Platform instead. Link to API. Don’t use fetch or axios.get, use Obsidian’s requestUrl instead. Link to API. Coding style Don’t use var. Use let or const instead. Learn more. Don’t use the global app instance. Use this.app provided to your plugin instance instead. Learn more. Do break up your main.ts into smaller files or even folders if it gets big to make code easier to find. Do use async and await when you can for readability, instead of using Promise. Learn more. Don’t use global variables. Try to keep variables either in the scope of classes or functions. Learn more. Do test with instanceof before casting into other types such as TFile, TFolder, or FileSystemAdapter, Don’t use use as any and use proper typing instead. API usage Don’t use Vault.modify. If you want to edit the active file, prefer using the Editor interface. If you want to edit it in the background, use Vault.process. Don’t manually read and write frontmatter. Instead, use FileManager.processFrontMatter. Learn more. Don’t use vault.delete to delete files. Use trashFile instead to make sure the file is deleted according to the users preferences. Learn more. Don’t use the Adapter API whenever possible. Use Vault API instead. Learn more. Don’t manage reading and write plugin data yourself. Use Plugin.loadData() and Plugin.saveData() instead. Do use normalizePath() if you take user defined paths. Learn more. Performance Do optimize your plugin’s load time. Detailed guide. Don’t iterate all files to find a file or folder by its path. Learn more. If you want your plugins to be compatible with Obsidian 1.7.2+ (currently in early access), update your plugin to work with DeferredViews. Detailed guide. If you’re using moment, make sure you’re doing import { moment} from 'obsidian' so that you don’t import another copy. Do minimize your main.js for releasing. Do your initial UI setup on workspace.onLayoutReady() instead of in the constructor or onload() function. Learn more. User interface Don’t use setting headings unless you have more than one section. Learn more. Don’t include the word “setting” or “option” in setting headings. Learn more. Do use sentence case in all text in UI elements to be consistent with rest of Obsidian UI. Learn more. Don’t use \u003ch1\u003e or \u003ch2\u003e for setting header. Use Obsidian API instead. Learn more. Don’t do console.log unless they are absolutely necessarily. Remove testing console logs that are not needed for production. ","categories":"","description":"A checklist for plugin developers to self-critique their plugins.","excerpt":"A checklist for plugin developers to self-critique their plugins.","ref":"/obsidian-october-o_o-2024-plugin-self-critique-checklist/","tags":"","title":""},{"body":"릴리스 \u0026 네이밍 MyPlugin과 SampleSettingTab같은 플레이스홀더(Placeholder) 이름을 제거하세요. 절대적으로 필요한 경우가 아니라면 이름에 “Obsidian\"을 포함하지 마세요. 대부분의 경우 중복입니다. 명령 이름에 플러그인 이름을 포함하지 마세요. Obsidian이 자동으로 추가합니다. 명령에 플러그인 ID를 접두사로 사용하지 마세요. Obsidian이 자동으로 추가합니다. 저장소에 main.js를 포함하지 마세요. 릴리스에만 포함하세요. 아직 추가하지 않았다면 fundingUrl을 추가하여 플러그인 사용자가 지원을 보여줄 수 있도록 고려해 보세요. 자세히 알아보기. 호환성 명령에 기본 핫키(Hotkey)를 제공하지 마세요. 자세히 알아보기. 코어 스타일링을 재정의하지 마세요. 필요한 경우 자신만의 클래스를 추가하고 해당 클래스에만 스타일링을 적용하세요. 더 이상 사용되지 않는 메서드(Method)를 찾기 위해 코드를 스캔하세요 (IDE에서 보통 취소선 텍스트로 표시됨). JavaScript나 HTML에서 스타일을 할당하지 마세요. 자세히 알아보기. 구성 디렉터리에 액세스해야 하는 경우 하드코딩된 .obsidian 폴더에 액세스하지 마세요. 위치가 사용자 정의될 수 있으므로 Vault.configDir을 사용하세요. 모바일 지원 매니페스트(Manifest)에서 isDesktopOnly가 false로 설정된 경우에만 이 섹션을 완료하세요.\nfs, path, electron과 같은 node.js 모듈을 사용하지 마세요. 16.4 미만의 iOS 버전을 지원하려면 정규식 룩비하인드(Lookbehind)를 사용하지 마세요 (플러그인에서 정규식을 사용하지 않는다면 무시). 자세히 알아보기. FileSystemAdapter 클래스를 사용하지 마세요. process.platform을 사용하지 말고 Obsidian의 Platform을 사용하세요. API 링크. fetch나 axios.get을 사용하지 말고 Obsidian의 requestUrl을 사용하세요. API 링크. 코딩 스타일 var를 사용하지 마세요. 대신 let이나 const를 사용하세요. 자세히 알아보기. 전역 app 인스턴스(Instance)를 사용하지 마세요. 대신 플러그인 인스턴스에 제공되는 this.app을 사용하세요. 자세히 알아보기. main.ts가 커지면 코드를 찾기 쉽도록 더 작은 파일이나 폴더로 나누세요. 가독성을 위해 Promise를 사용하는 대신 가능한 한 async와 await를 사용하세요. 자세히 알아보기. 전역 변수를 사용하지 마세요. 변수를 클래스나 함수의 범위 내에 유지하도록 노력하세요. 자세히 알아보기. TFile, TFolder, FileSystemAdapter와 같은 다른 타입으로 캐스팅하기 전에 instanceof로 테스트하세요. as any를 사용하지 말고 적절한 타이핑을 사용하세요. API 사용 Vault.modify를 사용하지 마세요. 활성 파일을 편집하려면 Editor 인터페이스를 사용하세요. 백그라운드에서 편집하려면 Vault.process를 사용하세요. 프론트매터(Frontmatter)를 수동으로 읽고 쓰지 마세요. 대신 FileManager.processFrontMatter를 사용하세요. 자세히 알아보기. 파일을 삭제하기 위해 vault.delete를 사용하지 마세요. 사용자 기본 설정에 따라 파일이 삭제되도록 trashFile을 사용하세요. 자세히 알아보기. 가능한 한 Adapter API를 사용하지 마세요. 대신 Vault API를 사용하세요. 자세히 알아보기. 플러그인 데이터 읽기와 쓰기를 직접 관리하지 마세요. 대신 Plugin.loadData()와 Plugin.saveData()를 사용하세요. 사용자 정의 경로를 받는 경우 normalizePath()를 사용하세요. 자세히 알아보기. 성능 플러그인의 로드 시간을 최적화하세요. 상세 가이드. 경로로 파일이나 폴더를 찾기 위해 모든 파일을 반복하지 마세요. 자세히 알아보기. 플러그인이 Obsidian 1.7.2+ (현재 얼리 액세스)와 호환되기를 원한다면 DeferredViews와 작동하도록 플러그인을 업데이트하세요. 상세 가이드. moment를 사용하는 경우 다른 복사본을 가져오지 않도록 import { moment} from 'obsidian'을 사용하고 있는지 확인하세요. 릴리스를 위해 main.js를 최소화하세요. 생성자나 onload() 함수 대신 workspace.onLayoutReady()에서 초기 UI 설정을 수행하세요. 자세히 알아보기. 사용자 인터페이스 섹션이 두 개 이상 없다면 설정 제목을 사용하지 마세요. 자세히 알아보기. 설정 제목에 “setting\"이나 “option\"이라는 단어를 포함하지 마세요. 자세히 알아보기. Obsidian UI의 나머지 부분과 일관성을 유지하기 위해 UI 요소의 모든 텍스트에 문장 케이스(Sentence Case)를 사용하세요. 자세히 알아보기. 설정 헤더에 \u003ch1\u003e이나 \u003ch2\u003e를 사용하지 마세요. 대신 Obsidian API를 사용하세요. 자세히 알아보기. 절대적으로 필요한 경우가 아니라면 console.log를 사용하지 마세요. 프로덕션에 필요하지 않은 테스트 콘솔 로그를 제거하세요. ","categories":"","description":"플러그인 개발자가 자신의 플러그인을 자체 검토하기 위한 체크리스트입니다.","excerpt":"플러그인 개발자가 자신의 플러그인을 자체 검토하기 위한 체크리스트입니다.","ref":"/ko/obsidian-october-o_o-2024-plugin-self-critique-checklist/","tags":"","title":""},{"body":"Add this checklist to your Obsidian Compatibility Do use CSS variables whenever you can. Learn more. Don’t use !important. Don’t change vertical margins in classes used in live preview editor, use padding instead. If you’re using recent experimental CSS features, mention the minimal installer version required in the README. Performance Don’t use :has() unless absolutely necessary. It causes performance issues especially in Canvas. Don’t link to assets such as fonts and images. Keep them local. Learn more. Releasing Don’t include the word “Obsidian” in your name unless it absolutely makes sense. Most of the time it’s redundant. Do check your screenshot files are up-to-date. These screenshots are shown as thumbnails in the theme directory. Do check your README to make sure it’s up-to-date. This is the what all potential users see when they check out your theme in the theme directory. Do keep your screenshot small so it loads fast in the directory. We recommend the dimension of 512 x 288 pixels. Do make sure you have a license in place so others know how to use your theme and its source code. ","categories":"","description":"A checklist for theme developers to self-critique their themes.","excerpt":"A checklist for theme developers to self-critique their themes.","ref":"/obsidian-october-o_o-2024-theme-self-critique-checklist/","tags":"","title":""},{"body":"호환성 가능한 한 CSS 변수(CSS Variables)를 사용하세요. 자세히 알아보기. !important를 사용하지 마세요. 라이브 프리뷰 에디터(Live Preview Editor)에서 사용되는 클래스의 수직 마진(Vertical Margin)을 변경하지 말고 대신 패딩(Padding)을 사용하세요. 최신 실험적 CSS 기능을 사용하는 경우 README에 필요한 최소 설치 프로그램 버전을 언급하세요. 성능 절대적으로 필요한 경우가 아니라면 :has()를 사용하지 마세요. 특히 캔버스(Canvas)에서 성능 문제를 일으킵니다. 폰트나 이미지와 같은 자산(Asset)에 링크하지 마세요. 로컬에 보관하세요. 자세히 알아보기. 릴리스 절대적으로 필요한 경우가 아니라면 이름에 “Obsidian\"을 포함하지 마세요. 대부분의 경우 중복입니다. 스크린샷 파일이 최신 상태인지 확인하세요. 이러한 스크린샷은 테마 디렉터리에서 썸네일(Thumbnail)로 표시됩니다. README가 최신 상태인지 확인하세요. 이는 모든 잠재적 사용자가 테마 디렉터리에서 테마를 확인할 때 보는 내용입니다. 디렉터리에서 빠르게 로드되도록 스크린샷을 작게 유지하세요. 512 x 288 픽셀 크기를 권장합니다. 다른 사람들이 테마와 소스 코드를 어떻게 사용할지 알 수 있도록 라이선스(License)가 있는지 확인하세요. ","categories":"","description":"테마 개발자가 자신의 테마를 자체 검토하기 위한 체크리스트입니다.","excerpt":"테마 개발자가 자신의 테마를 자체 검토하기 위한 체크리스트입니다.","ref":"/ko/obsidian-october-o_o-2024-theme-self-critique-checklist/","tags":"","title":""},{"body":"Add this checklist to your Obsidian [!INFO] Reminder Although we proposed some ways below to maintain and improvement your vault, likely the user of your vault is you and only you. This is different from plugins and themes where we can make relatively more objective suggestions.\nSo feel free to remove anything from the checklist that doesn’t make sense to you and add your own items.\nVault maintenance How well is your vault doing what it’s supposed to do? (What is the purpose of your vault/notes? What measures might you use to judge how well it’s working?) 1 How quickly can you find notes you used one week ago? If your cat intentionally deleted all of your files, how recent is your backup? Do you need to document anything about your workflows? It can be surprisingly helpful to write out how you work and create checklists for important but uncommon tasks. Vault maintenance checklist Delete unused attachments Delete or refactor notes that are not linked or tagged or in a folder (“orphan” notes) Delete unused tags Delete empty folders Process items in inbox notes/folders/tags Make templates for frequently-used snippets or note types Remove unused plugins Remove unused themes Remove unused snippets Add properties missing from notes Convert tags to properties where appropriate Fix up broken links Browse through the plugin gallery for new ideas Vault rediscovery ideas Open both Backlinks and Outgoing Links to see if there are any unlinked mentions that make sense Sort the files in Files Explorer by “Modified time (old to new)”, take a look at the top files and see how they can be made better. Enable the Random Note core plugin and randomly visit some notes for surprises. Remember that “joy” is a valid measure! ↩︎\n","categories":"","description":"A checklist for vault maintenance and discovery.","excerpt":"A checklist for vault maintenance and discovery.","ref":"/obsidian-october-o_o-2024-vault-self-critique-checklist/","tags":"","title":""},{"body":" [!INFO] 알림 아래에서 볼트를 유지보수하고 개선하는 몇 가지 방법을 제안했지만, 볼트의 사용자는 아마도 당신 자신뿐일 것입니다. 이는 상대적으로 더 객관적인 제안을 할 수 있는 플러그인과 테마와는 다릅니다.\n따라서 체크리스트에서 의미가 없다고 생각되는 항목은 자유롭게 제거하고 자신만의 항목을 추가하세요.\n볼트 유지보수 볼트가 해야 할 일을 얼마나 잘 수행하고 있나요? (볼트/노트의 목적은 무엇인가요? 얼마나 잘 작동하는지 판단하기 위해 어떤 기준을 사용할 수 있나요?) 1 일주일 전에 사용한 노트를 얼마나 빨리 찾을 수 있나요? 고양이가 의도적으로 모든 파일을 삭제했다면, 백업(Backup)은 얼마나 최신인가요? 워크플로우(Workflow)에 대해 문서화해야 할 것이 있나요? 자신이 어떻게 작업하는지 적어보고 중요하지만 흔하지 않은 작업에 대한 체크리스트를 만드는 것이 놀랍도록 도움이 될 수 있습니다. 볼트 유지보수 체크리스트 사용하지 않는 첨부파일(Attachment) 삭제 링크되지 않거나 태그가 없거나 폴더에 없는 노트(“고아” 노트) 삭제 또는 리팩터링 사용하지 않는 태그(Tag) 삭제 빈 폴더 삭제 받은편지함 노트/폴더/태그의 항목 처리 자주 사용하는 스니펫(Snippet)이나 노트 유형에 대한 템플릿(Template) 만들기 사용하지 않는 플러그인 제거 사용하지 않는 테마 제거 사용하지 않는 스니펫 제거 노트에서 누락된 속성(Properties) 추가 적절한 경우 태그를 속성으로 변환 깨진 링크 수정 새로운 아이디어를 위해 플러그인 갤러리 둘러보기 볼트 재발견 아이디어 백링크(Backlinks)와 나가는 링크(Outgoing Links)를 모두 열어서 의미가 있는 연결되지 않은 언급이 있는지 확인 파일 탐색기에서 파일을 “수정 시간(오래된 것부터 새로운 것 순)“으로 정렬하고, 상위 파일들을 살펴보며 어떻게 개선할 수 있는지 확인 랜덤 노트(Random Note) 코어 플러그인을 활성화하고 무작위로 노트를 방문하여 놀라운 발견을 해보세요. “즐거움\"도 유효한 기준이라는 것을 기억하세요! ↩︎\n","categories":"","description":"볼트 유지보수 및 재발견을 위한 체크리스트입니다.","excerpt":"볼트 유지보수 및 재발견을 위한 체크리스트입니다.","ref":"/ko/obsidian-october-o_o-2024-vault-self-critique-checklist/","tags":"","title":""},{"body":"Once you’ve built your editor extension, you might want to communicate with it from outside the editor. For example, through a [[Commands|command]], or a [[Ribbon actions|ribbon action]].\nYou can access the CodeMirror 6 editor from a [[MarkdownView|MarkdownView]]. However, since the Obsidian API doesn’t actually expose the editor, you need to tell TypeScript to trust that it’s there, using @ts-expect-error.\nimport { EditorView } from '@codemirror/view'; // @ts-expect-error, not typed const editorView = view.editor.cm as EditorView; View plugin You can access the [[View plugins|view plugin]] instance from the EditorView.plugin() method.\nthis.addCommand({ id: 'example-editor-command', name: 'Example editor command', editorCallback: (editor, view) =\u003e { // @ts-expect-error, not typed const editorView = view.editor.cm as EditorView; const plugin = editorView.plugin(examplePlugin); if (plugin) { plugin.addPointerToSelection(editorView); } }, }); State field You can dispatch changes and [[State fields#Dispatching state effects|dispatch state effects]] directly on the editor view.\nthis.addCommand({ id: 'example-editor-command', name: 'Example editor command', editorCallback: (editor, view) =\u003e { // @ts-expect-error, not typed const editorView = view.editor.cm as EditorView; editorView.dispatch({ effects: [ // ... ], }); }, }); ","categories":"","description":"","excerpt":"Once you’ve built your editor extension, you might want to communicate …","ref":"/plugins/editor/communicating-with-editor-extensions/","tags":"","title":""},{"body":"에디터 확장 기능을 만들었다면, 에디터 외부(예: [[Commands|명령]]이나 [[Ribbon actions|리본 액션]]을 통해)와 통신하고 싶을 수 있습니다.\n[[MarkdownView|MarkdownView]]에서 CodeMirror 6 에디터에 접근할 수 있습니다. 하지만 Obsidian API가 실제로 에디터를 노출하지 않기 때문에 TypeScript에게 그것이 존재한다고 믿도록 @ts-expect-error를 사용해야 합니다.\nimport { EditorView } from '@codemirror/view'; // @ts-expect-error, 타입이 정의되지 않음 const editorView = view.editor.cm as EditorView; 뷰 플러그인 EditorView.plugin() 메서드를 통해 [[View plugins|뷰 플러그인]] 인스턴스에 접근할 수 있습니다.\nthis.addCommand({ id: 'example-editor-command', name: '에디터 명령 예제', editorCallback: (editor, view) =\u003e { // @ts-expect-error, 타입이 정의되지 않음 const editorView = view.editor.cm as EditorView; const plugin = editorView.plugin(examplePlugin); if (plugin) { plugin.addPointerToSelection(editorView); } }, }); 상태 필드 에디터 뷰에서 직접 변경 사항을 전달하고 [[State fields#Dispatching state effects|상태 효과를 전달]]할 수 있습니다.\nthis.addCommand({ id: 'example-editor-command', name: '에디터 명령 예제', editorCallback: (editor, view) =\u003e { // @ts-expect-error, 타입이 정의되지 않음 const editorView = view.editor.cm as EditorView; editorView.dispatch({ effects: [ // ... ], }); }, }); ","categories":"","description":"","excerpt":"에디터 확장 기능을 만들었다면, 에디터 외부(예: [[Commands|명령]]이나 [[Ribbon actions|리본 액션]] …","ref":"/ko/plugins/editor/communicating-with-editor-extensions/","tags":"","title":""},{"body":"Decorations let you control how to draw or style content in [[Editor extensions|editor extensions]]. If you intend to change the look and feel by adding, replacing, or styling elements in the editor, you most likely need to use decorations.\nBy the end of this page, you’ll be able to:\nUnderstand how to use decorations to change the editor appearance. Understand the difference between providing decoration using state fields and view plugins. [!note] This page aims to distill the official CodeMirror 6 documentation for Obsidian plugin developers. For more detailed information on state fields, refer to Decorating the Document.\nPrerequisites Basic understanding of [[State fields]]. Basic understanding of [[View plugins]]. Overview Without decorations, the document would render as plain text. Not very interesting at all. Using decorations, you can change how to display the document, for example by highlighting text or adding custom HTML elements.\nYou can use the following types of decorations:\nMark decorations style existing elements. Widget decorations insert elements in the document. Replace decorations hide or replace part of the document with another element. Line decorations add styling to the lines, rather than the document itself. To use decorations, you need to create them inside an editor extension and have the extension provide them to the editor. You can provide decorations to the editor in two ways, either directly using [[State fields|state fields]] or indirectly using [[View plugins|view plugins]].\nShould I use a view plugin or a state field? Both view plugins and state fields can provide decorations to the editor, but they have some differences.\nUse a view plugin if you can determine the decoration based on what’s inside the [[Viewport]]. Use a state field if you need to manage decorations outside of the viewport. Use a state field if you want to make changes that could change the content of the viewport, for example by adding line breaks. If you can implement your extension using either approach, then the view plugin generally results in better performance. For example, imagine that you want to implement an editor extension that checks the spelling of a document.\nOne way would be to pass the entire document to an external spell checker which then returns a list of spelling errors. In this case, you’d need to map each error to a decoration and use a state field to manage decorations regardless of what’s in the viewport at the moment.\nAnother way would be to only spellcheck what’s visible in the viewport. The extension would need to continuously run a spell check as the user scrolls through the document, but you’d be able to spell check documents with millions of lines of text.\nProviding decorations Imagine that you want to build an editor extension that replaces the bullet list item with an emoji. You can accomplish this with either a view plugin or a state field, with some differences. In this section, you’ll see how to implement it with both types of extensions.\nBoth implementations share the same core logic:\nUse syntaxTree to find list items. For every list item, replace leading hyphens, -, with a widget. Widgets Widgets are custom HTML elements that you can add to the editor. You can either insert a widget at a specific position in the document, or replace a piece of content with a widget.\nThe following example defines a widget that returns an HTML element, \u003cspan\u003e👉\u003c/span\u003e. You’ll use this widget later on.\nimport { EditorView, WidgetType } from '@codemirror/view'; export class EmojiWidget extends WidgetType { toDOM(view: EditorView): HTMLElement { const div = document.createElement('span'); div.innerText = '👉'; return div; } } To replace a range of content in your document with the emoji widget, use the replace decoration.\nconst decoration = Decoration.replace({ widget: new EmojiWidget() }); State fields To provide decorations from a state field:\n[[State fields#Defining a state field|Define a state field]] with a DecorationSet type.\nAdd the provide property to the state field.\nprovide(field: StateField\u003cDecorationSet\u003e): Extension { return EditorView.decorations.from(field); }, import { syntaxTree } from '@codemirror/language'; import { Extension, RangeSetBuilder, StateField, Transaction, } from '@codemirror/state'; import { Decoration, DecorationSet, EditorView, WidgetType, } from '@codemirror/view'; import { EmojiWidget } from 'emoji'; export const emojiListField = StateField.define\u003cDecorationSet\u003e({ create(state): DecorationSet { return Decoration.none; }, update(oldState: DecorationSet, transaction: Transaction): DecorationSet { const builder = new RangeSetBuilder\u003cDecoration\u003e(); syntaxTree(transaction.state).iterate({ enter(node) { if (node.type.name.startsWith('list')) { // Position of the '-' or the '*'. const listCharFrom = node.from - 2; builder.add( listCharFrom, listCharFrom + 1, Decoration.replace({ widget: new EmojiWidget(), }) ); } }, }); return builder.finish(); }, provide(field: StateField\u003cDecorationSet\u003e): Extension { return EditorView.decorations.from(field); }, }); View plugins To manage your decorations using a view plugin:\n[[View plugins#Creating a view plugin|Create a view plugin]]. Add a DecorationSet member property to your plugin. Initialize the decorations in the constructor(). Rebuild decorations in update(). Not all updates are reasons to rebuild your decorations. The following example only rebuilds decorations whenever the underlying document or the viewport changes.\nimport { syntaxTree } from '@codemirror/language'; import { RangeSetBuilder } from '@codemirror/state'; import { Decoration, DecorationSet, EditorView, PluginSpec, PluginValue, ViewPlugin, ViewUpdate, WidgetType, } from '@codemirror/view'; import { EmojiWidget } from 'emoji'; class EmojiListPlugin implements PluginValue { decorations: DecorationSet; constructor(view: EditorView) { this.decorations = this.buildDecorations(view); } update(update: ViewUpdate) { if (update.docChanged || update.viewportChanged) { this.decorations = this.buildDecorations(update.view); } } destroy() {} buildDecorations(view: EditorView): DecorationSet { const builder = new RangeSetBuilder\u003cDecoration\u003e(); for (let { from, to } of view.visibleRanges) { syntaxTree(view.state).iterate({ from, to, enter(node) { if (node.type.name.startsWith('list')) { // Position of the '-' or the '*'. const listCharFrom = node.from - 2; builder.add( listCharFrom, listCharFrom + 1, Decoration.replace({ widget: new EmojiWidget(), }) ); } }, }); } return builder.finish(); } } const pluginSpec: PluginSpec\u003cEmojiListPlugin\u003e = { decorations: (value: EmojiListPlugin) =\u003e value.decorations, }; export const emojiListPlugin = ViewPlugin.fromClass( EmojiListPlugin, pluginSpec ); buildDecorations() is a helper method that builds a complete set of decorations based on the editor view.\nNotice the second argument to the ViewPlugin.fromClass() function. The decorations property in the PluginSpec specifies how the view plugin provides the decorations to the editor.\nSince the view plugin knows what’s visible to the user, you can use view.visibleRanges to limit what parts of the syntax tree to visit.\n","categories":"","description":"","excerpt":"Decorations let you control how to draw or style content in [[Editor …","ref":"/plugins/editor/decorations/","tags":"","title":""},{"body":"데코레이션(Decorations)을 사용하면 [[Editor extensions|에디터 확장 기능]]에서 콘텐츠를 어떻게 그리거나 스타일링할지 제어할 수 있습니다. 에디터에서 요소를 추가, 교체하거나 스타일을 변경하여 모양과 느낌을 바꾸려면 대부분 데코레이션을 사용해야 합니다.\n이 페이지를 읽고 나면 다음을 할 수 있게 됩니다:\n에디터 외관을 변경하기 위해 데코레이션을 사용하는 방법 이해 상태 필드와 뷰 플러그인을 사용하여 데코레이션을 제공하는 차이점 이해 [!note] 이 페이지는 Obsidian 플러그인 개발자를 위해 공식 CodeMirror 6 문서를 요약한 것입니다. 상태 필드에 대한 더 자세한 정보는 Decorating the Document를 참조하세요.\n필수 조건 [[State fields]] 기본 이해 [[View plugins]] 기본 이해 개요 데코레이션 없이는 문서가 일반 텍스트로 렌더링됩니다. 전혀 흥미롭지 않죠. 데코레이션을 사용하면 텍스트 강조나 커스텀 HTML 요소 추가와 같이 문서 표시 방식을 변경할 수 있습니다.\n다음 유형의 데코레이션을 사용할 수 있습니다:\n마크 데코레이션: 기존 요소 스타일링 위젯 데코레이션: 문서에 요소 삽입 교체 데코레이션: 문서 일부를 다른 요소로 숨기거나 교체 라인 데코레이션: 문서 자체가 아닌 라인에 스타일 추가 데코레이션을 사용하려면 에디터 확장 기능 내부에서 데코레이션을 생성하고 확장 기능이 이를 에디터에 _제공_하도록 해야 합니다. 데코레이션을 에디터에 제공하는 방법은 두 가지입니다: [[State fields|상태 필드]]를 사용해 직접 제공하거나 [[View plugins|뷰 플러그인]]을 사용해 간접적으로 제공하는 방법입니다.\n뷰 플러그인과 상태 필드 중 어떤 것을 사용해야 하나요? 뷰 플러그인과 상태 필드 모두 데코레이션을 제공할 수 있지만 몇 가지 차이점이 있습니다.\n[[Viewport]] 내부에 있는 내용을 기반으로 데코레이션을 결정할 수 있다면 뷰 플러그인을 사용하세요. 뷰포트 외부의 데코레이션을 관리해야 한다면 상태 필드를 사용하세요. 줄 바꿈 추가와 같이 뷰포트 내용을 변경할 수 있는 변경을 원한다면 상태 필드를 사용하세요. 두 접근 방식 중 어느 것으로도 확장 기능을 구현할 수 있다면 일반적으로 뷰 플러그인이 더 나은 성능을 제공합니다. 예를 들어 문서의 맞춤법을 검사하는 에디터 확장 기능을 구현한다고 가정해 보겠습니다.\n한 가지 방법은 전체 문서를 외부 맞춤법 검사기에 전달한 다음 맞춤법 오류 목록을 반환받는 것입니다. 이 경우 각 오류를 데코레이션에 매핑하고 현재 뷰포트에 무엇이 있는지와 관계없이 데코레이션을 관리하기 위해 상태 필드를 사용해야 합니다.\n다른 방법은 뷰포트에 보이는 내용만 맞춤법 검사를 하는 것입니다. 확장 기능은 사용자가 문서를 스크롤할 때 지속적으로 맞춤법 검사를 실행해야 하지만 수백만 줄의 텍스트가 있는 문서도 맞춤법 검사를 할 수 있습니다.\n데코레이션 제공 불릿 리스트 항목을 이모지로 바꾸는 에디터 확장 기능을 만들고 싶다고 가정해 보겠습니다. 뷰 플러그인이나 상태 필드를 사용하여 이를 구현할 수 있으며 각각 약간의 차이가 있습니다. 이 섹션에서는 두 유형의 확장 기능으로 구현하는 방법을 살펴보겠습니다.\n두 구현 모두 동일한 핵심 로직을 공유합니다:\nsyntaxTree를 사용하여 리스트 항목 찾기 각 리스트 항목에 대해 선행 하이픈 -을 _위젯_으로 교체 위젯 위젯은 에디터에 추가할 수 있는 커스텀 HTML 요소입니다. 문서의 특정 위치에 위젯을 삽입하거나 콘텐츠 일부를 위젯으로 교체할 수 있습니다.\n다음 예제는 HTML 요소 \u003cspan\u003e👉\u003c/span\u003e을 반환하는 위젯을 정의합니다. 나중에 이 위젯을 사용하게 됩니다.\nimport { EditorView, WidgetType } from '@codemirror/view'; export class EmojiWidget extends WidgetType { toDOM(view: EditorView): HTMLElement { const div = document.createElement('span'); div.innerText = '👉'; return div; } } 문서의 콘텐츠 범위를 이모지 위젯으로 교체하려면 교체 데코레이션을 사용하세요.\nconst decoration = Decoration.replace({ widget: new EmojiWidget() }); 상태 필드 상태 필드에서 데코레이션을 제공하려면:\nDecorationSet 타입으로 [[State fields#Defining a state field|상태 필드 정의]]\n상태 필드에 provide 속성 추가\nprovide(field: StateField\u003cDecorationSet\u003e): Extension { return EditorView.decorations.from(field); }, import { syntaxTree } from '@codemirror/language'; import { Extension, RangeSetBuilder, StateField, Transaction, } from '@codemirror/state'; import { Decoration, DecorationSet, EditorView, WidgetType, } from '@codemirror/view'; import { EmojiWidget } from 'emoji'; export const emojiListField = StateField.define\u003cDecorationSet\u003e({ create(state): DecorationSet { return Decoration.none; }, update(oldState: DecorationSet, transaction: Transaction): DecorationSet { const builder = new RangeSetBuilder\u003cDecoration\u003e(); syntaxTree(transaction.state).iterate({ enter(node) { if (node.type.name.startsWith('list')) { // '-' 또는 '*'의 위치 const listCharFrom = node.from - 2; builder.add( listCharFrom, listCharFrom + 1, Decoration.replace({ widget: new EmojiWidget(), }) ); } }, }); return builder.finish(); }, provide(field: StateField\u003cDecorationSet\u003e): Extension { return EditorView.decorations.from(field); }, }); 뷰 플러그인 뷰 플러그인을 사용하여 데코레이션을 관리하려면:\n[[View plugins#Creating a view plugin|뷰 플러그인 생성]] 플러그인에 DecorationSet 멤버 속성 추가 constructor()에서 데코레이션 초기화 update()에서 데코레이션 재구성 모든 업데이트가 데코레이션 재구성의 이유는 아닙니다. 다음 예제는 기본 문서나 뷰포트가 변경될 때만 데코레이션을 재구성합니다.\nimport { syntaxTree } from '@codemirror/language'; import { RangeSetBuilder } from '@codemirror/state'; import { Decoration, DecorationSet, EditorView, PluginSpec, PluginValue, ViewPlugin, ViewUpdate, WidgetType, } from '@codemirror/view'; import { EmojiWidget } from 'emoji'; class EmojiListPlugin implements PluginValue { decorations: DecorationSet; constructor(view: EditorView) { this.decorations = this.buildDecorations(view); } update(update: ViewUpdate) { if (update.docChanged || update.viewportChanged) { this.decorations = this.buildDecorations(update.view); } } destroy() {} buildDecorations(view: EditorView): DecorationSet { const builder = new RangeSetBuilder\u003cDecoration\u003e(); for (let { from, to } of view.visibleRanges) { syntaxTree(view.state).iterate({ from, to, enter(node) { if (node.type.name.startsWith('list')) { // '-' 또는 '*'의 위치 const listCharFrom = node.from - 2; builder.add( listCharFrom, listCharFrom + 1, Decoration.replace({ widget: new EmojiWidget(), }) ); } }, }); } return builder.finish(); } } const pluginSpec: PluginSpec\u003cEmojiListPlugin\u003e = { decorations: (value: EmojiListPlugin) =\u003e value.decorations, }; export const emojiListPlugin = ViewPlugin.fromClass( EmojiListPlugin, pluginSpec ); buildDecorations()는 에디터 뷰를 기반으로 완전한 데코레이션 세트를 구성하는 도우미 메서드입니다.\nViewPlugin.fromClass() 함수의 두 번째 인수에 주목하세요. PluginSpec의 decorations 속성은 뷰 플러그인이 데코레이션을 에디터에 제공하는 방법을 지정합니다.\n뷰 플러그인은 사용자에게 보이는 내용을 알고 있으므로 view.visibleRanges를 사용하여 구문 트리에서 방문할 부분을 제한할 수 있습니다.\n","categories":"","description":"","excerpt":"데코레이션(Decorations)을 사용하면 [[Editor extensions|에디터 확장 기능]]에서 콘텐츠를 어떻게 그리 …","ref":"/ko/plugins/editor/decorations/","tags":"","title":""},{"body":"Editor extensions let you customize the experience of editing notes in Obsidian. This page explains what editor extensions are, and when to use them.\nObsidian uses CodeMirror 6 (CM6) to power the Markdown editor. Just like Obsidian, CM6 has plugins of its own, called extensions. In other words, an Obsidian editor extension is the same thing as a CodeMirror 6 extension.\nThe API for building editor extensions is a bit unconventional and requires that you have a basic understanding of its architecture before you get started. This section aims to give you enough context and examples for you to get started. If you want to learn more about building editor extensions, refer to the CodeMirror 6 documentation.\nDo I need an editor extension? Building editor extensions can be challenging, so before you start building one, consider whether you really need it.\nIf you want to change how to convert Markdown to HTML in the Reading view, consider building a [[Markdown post processing|Markdown post processor]]. If you want to change how the document looks and feels in Live Preview, you need to build an editor extension. Registering editor extensions CodeMirror 6 (CM6) is a powerful engine for editing code using web technologies. At its core, the editor itself has a minimal set of features. Any features you’d expect from a modern editor are available as extensions that you can pick and choose. While Obsidian comes with many of these extensions out-of-the-box, you can also register your own.\nTo register an editor extension, use [[registerEditorExtension|registerEditorExtension()]] in the onload method of your Obsidian plugin:\nonload() { this.registerEditorExtension([examplePlugin, exampleField]); } While CM6 supports several types of extensions, two of the most common ones are [[View plugins]] and [[State fields]]. ","categories":"","description":"","excerpt":"Editor extensions let you customize the experience of editing notes in …","ref":"/plugins/editor/editor-extensions/","tags":"","title":""},{"body":"에디터 확장 기능(Editor extensions)을 사용하면 Obsidian에서 노트를 편집하는 경험을 커스터마이즈할 수 있습니다. 이 페이지에서는 에디터 확장 기능이 무엇인지, 언제 사용해야 하는지 설명합니다.\nObsidian은 마크다운 에디터를 구동하기 위해 CodeMirror 6(CM6)을 사용합니다. Obsidian과 마찬가지로 CM6에는 _확장 기능(extensions)_이라는 자체 플러그인이 있습니다. 즉, Obsidian의 _에디터 확장 기능_은 _CodeMirror 6 확장 기능_과 동일합니다.\n에디터 확장 기능을 구축하기 위한 API는 약간 독특하며 시작하기 전에 기본적인 아키텍처 이해가 필요합니다. 이 섹션은 시작하기에 충분한 컨텍스트와 예제를 제공하기 위한 것입니다. 에디터 확장 기능 구축에 대해 더 배우고 싶다면 CodeMirror 6 문서를 참조하세요.\n에디터 확장 기능이 필요한가요? 에디터 확장 기능을 구축하는 것은 도전적일 수 있으므로, 구축을 시작하기 전에 정말로 필요한지 고려하세요.\n읽기 모드에서 마크다운을 HTML로 변환하는 방식을 변경하려면 [[Markdown post processing|마크다운 후처리기]]를 구축하는 것을 고려하세요. 라이브 프리뷰에서 문서의 모양과 느낌을 변경하려면 에디터 확장 기능을 구축해야 합니다. 에디터 확장 기능 등록 CodeMirror 6(CM6)은 웹 기술을 사용하여 코드를 편집하기 위한 강력한 엔진입니다. 핵심적으로 에디터 자체는 최소한의 기능 세트를 가지고 있습니다. 현대적인 에디터에서 기대할 수 있는 모든 기능은 선택할 수 있는 _확장 기능_으로 제공됩니다. Obsidian은 이러한 확장 기능 중 많은 것을 기본으로 제공하지만, 자신만의 확장 기능을 등록할 수도 있습니다.\n에디터 확장 기능을 등록하려면 Obsidian 플러그인의 onload 메서드에서 [[registerEditorExtension|registerEditorExtension()]]을 사용하세요:\nonload() { this.registerEditorExtension([examplePlugin, exampleField]); } CM6는 여러 유형의 확장 기능을 지원하지만, 가장 일반적인 두 가지는 [[View plugins]]와 [[State fields]]입니다. ","categories":"","description":"","excerpt":"에디터 확장 기능(Editor extensions)을 사용하면 Obsidian에서 노트를 편집하는 경험을 커스터마이즈할 수 있 …","ref":"/ko/plugins/editor/editor-extensions/","tags":"","title":""},{"body":"The [[Reference/TypeScript API/Editor|Editor]] class exposes operations for reading and manipulating an active Markdown document in edit mode.\nIf you want to access the editor in a command, use the [[Commands#Editor commands|editorCallback]].\nIf you want to use the editor elsewhere, you can access it from the active view:\nconst view = this.app.workspace.getActiveViewOfType(MarkdownView); // Make sure the user is editing a Markdown file. if (view) { const cursor = view.editor.getCursor(); // ... } [!note] Obsidian uses CodeMirror (CM) as the underlying text editor, and exposes the CodeMirror editor as part of the API. Editor serves as an abstraction to bridge features between CM6 and CM5 (legacy editor, only available on desktop). By using Editor instead of directly accessing the CodeMirror instance, you ensure that your plugin works on both platforms.\nInsert text at cursor position The [[replaceRange|replaceRange()]] method replaces the text between two cursor positions. If you only give it one position, it inserts the new text between that position and the next.\nThe following command inserts today’s date at the cursor position:\nimport { Editor, moment, Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { this.addCommand({ id: 'insert-todays-date', name: 'Insert today\\'s date', editorCallback: (editor: Editor) =\u003e { editor.replaceRange( moment().format('YYYY-MM-DD'), editor.getCursor() ); }, }); } } ![[editor-todays-date.gif]]\nReplace current selection If you want to modify the selected text, use [[replaceSelection|replaceSelection()]] to replace the current selection with a new text.\nThe following command reads the current selection and converts it to uppercase:\nimport { Editor, Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { this.addCommand({ id: 'convert-to-uppercase', name: 'Convert to uppercase', editorCallback: (editor: Editor) =\u003e { const selection = editor.getSelection(); editor.replaceSelection(selection.toUpperCase()); }, }); } } ![[editor-uppercase.gif]]\n","categories":"","description":"","excerpt":"The [[Reference/TypeScript API/Editor|Editor]] class exposes …","ref":"/plugins/editor/editor/","tags":"","title":""},{"body":"[[Reference/TypeScript API/Editor|Editor]] 클래스는 편집 모드에서 활성화된 마크다운 문서를 읽고 조작하기 위한 작업을 제공합니다.\n명령에서 편집기에 접근하려면 [[Commands#Editor commands|editorCallback]]을 사용하세요.\n다른 곳에서 편집기를 사용하려면 활성 뷰에서 접근할 수 있습니다:\nconst view = this.app.workspace.getActiveViewOfType(MarkdownView); // 사용자가 마크다운 파일을 편집 중인지 확인 if (view) { const cursor = view.editor.getCursor(); // ... } [!note] Obsidian은 기본 텍스트 편집기로 CodeMirror (CM)를 사용하며, API의 일부로 CodeMirror 편집기를 노출합니다. Editor는 CM6과 CM5(레거시 편집기, 데스크톱에서만 사용 가능) 간의 기능을 연결하기 위한 추상화 역할을 합니다. CodeMirror 인스턴스에 직접 접근하는 대신 Editor를 사용하면 두 플랫폼에서 모두 플러그인이 작동하도록 보장할 수 있습니다.\n커서 위치에 텍스트 삽입 [[replaceRange|replaceRange()]] 메서드는 두 커서 위치 사이의 텍스트를 교체합니다. 하나의 위치만 제공하면 해당 위치와 다음 위치 사이에 새 텍스트를 삽입합니다.\n다음 명령은 커서 위치에 오늘 날짜를 삽입합니다:\nimport { Editor, moment, Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { this.addCommand({ id: 'insert-todays-date', name: '오늘 날짜 삽입', editorCallback: (editor: Editor) =\u003e { editor.replaceRange( moment().format('YYYY-MM-DD'), editor.getCursor() ); }, }); } } ![[editor-todays-date.gif]]\n현재 선택 영역 교체 선택된 텍스트를 수정하려면 [[replaceSelection|replaceSelection()]]을 사용하여 현재 선택 영역을 새 텍스트로 교체하세요.\n다음 명령은 현재 선택 영역을 읽어 대문자로 변환합니다:\nimport { Editor, Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { this.addCommand({ id: 'convert-to-uppercase', name: '대문자로 변환', editorCallback: (editor: Editor) =\u003e { const selection = editor.getSelection(); editor.replaceSelection(selection.toUpperCase()); }, }); } } ![[editor-uppercase.gif]]\n","categories":"","description":"","excerpt":"[[Reference/TypeScript API/Editor|Editor]] 클래스는 편집 모드에서 활성화된 마크다운 문서를  …","ref":"/ko/plugins/editor/editor/","tags":"","title":""},{"body":"If you want to change how a Markdown document is rendered in Reading view, you can add your own Markdown post processor. As indicated by the name, the post processor runs after the Markdown has been processed into HTML. It lets you add, remove, or replace [[HTML elements]] to the rendered document.\nThe following example looks for any code block that contains a text between two colons, :, and replaces it with an appropriate emoji:\nimport { Plugin } from 'obsidian'; const ALL_EMOJIS: Record\u003cstring, string\u003e = { ':+1:': '👍', ':sunglasses:': '😎', ':smile:': '😄', }; export default class ExamplePlugin extends Plugin { async onload() { this.registerMarkdownPostProcessor((element, context) =\u003e { const codeblocks = element.findAll('code'); for (let codeblock of codeblocks) { const text = codeblock.innerText.trim(); if (text[0] === ':' \u0026\u0026 text[text.length - 1] === ':') { const emojiEl = codeblock.createSpan({ text: ALL_EMOJIS[text] ?? text, }); codeblock.replaceWith(emojiEl); } } }); } } Post-process Markdown code blocks Did you know that you can create Mermaid diagrams in Obsidian by creating a mermaid code block with a text definition like this one?:\n```mermaid flowchart LR Start --\u003e Stop ``` If you change to Preview mode, the text in the code block becomes the following diagram:\nflowchart LR Start --\u003e Stop If you want to add your own custom code blocks like the Mermaid one, you can use [[registerMarkdownCodeBlockProcessor|registerMarkdownCodeBlockProcessor()]]. The following example renders a code block with CSV data, as a table:\nimport { Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { this.registerMarkdownCodeBlockProcessor('csv', (source, el, ctx) =\u003e { const rows = source.split('\\n').filter((row) =\u003e row.length \u003e 0); const table = el.createEl('table'); const body = table.createEl('tbody'); for (let i = 0; i \u003c rows.length; i++) { const cols = rows[i].split(','); const row = body.createEl('tr'); for (let j = 0; j \u003c cols.length; j++) { row.createEl('td', { text: cols[j] }); } } }); } } ","categories":"","description":"","excerpt":"If you want to change how a Markdown document is rendered in Reading …","ref":"/plugins/editor/markdown-post-processing/","tags":"","title":""},{"body":"읽기 모드에서 마크다운 문서가 렌더링되는 방식을 변경하려면 자신만의 _마크다운 후처리기(Markdown post processor)_를 추가할 수 있습니다. 이름에서 알 수 있듯이, 후처리기는 마크다운이 HTML로 처리된 후에 실행됩니다. 이를 통해 렌더링된 문서에 [[HTML elements|HTML 요소]]를 추가, 제거 또는 교체할 수 있습니다.\n다음 예제는 두 개의 콜론 : 사이에 텍스트가 있는 코드 블록을 찾아 적절한 이모지로 교체합니다:\nimport { Plugin } from 'obsidian'; const ALL_EMOJIS: Record\u003cstring, string\u003e = { ':+1:': '👍', ':sunglasses:': '😎', ':smile:': '😄', }; export default class ExamplePlugin extends Plugin { async onload() { this.registerMarkdownPostProcessor((element, context) =\u003e { const codeblocks = element.findAll('code'); for (let codeblock of codeblocks) { const text = codeblock.innerText.trim(); if (text[0] === ':' \u0026\u0026 text[text.length - 1] === ':') { const emojiEl = codeblock.createSpan({ text: ALL_EMOJIS[text] ?? text, }); codeblock.replaceWith(emojiEl); } } }); } } 마크다운 코드 블록 후처리 Mermaid 다이어그램을 다음과 같은 텍스트 정의가 있는 mermaid 코드 블록으로 생성할 수 있다는 것을 알고 계셨나요?:\n```mermaid flowchart LR Start --\u003e Stop ``` 미리보기 모드로 전환하면 코드 블록의 텍스트가 다음과 같은 다이어그램으로 변환됩니다:\nflowchart LR\rStart --\u003e Stop Mermaid와 같은 사용자 정의 코드 블록을 추가하려면 [[registerMarkdownCodeBlockProcessor|registerMarkdownCodeBlockProcessor()]]를 사용할 수 있습니다. 다음 예제는 CSV 데이터가 포함된 코드 블록을 테이블로 렌더링합니다:\nimport { Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { this.registerMarkdownCodeBlockProcessor('csv', (source, el, ctx) =\u003e { const rows = source.split('\\n').filter((row) =\u003e row.length \u003e 0); const table = el.createEl('table'); const body = table.createEl('tbody'); for (let i = 0; i \u003c rows.length; i++) { const cols = rows[i].split(','); const row = body.createEl('tr'); for (let j = 0; j \u003c cols.length; j++) { row.createEl('td', { text: cols[j] }); } } }); } } ","categories":"","description":"","excerpt":"읽기 모드에서 마크다운 문서가 렌더링되는 방식을 변경하려면 자신만의 _마크다운 후처리기(Markdown post …","ref":"/ko/plugins/editor/markdown-post-processing/","tags":"","title":""},{"body":"A state field is an [[Editor extensions|editor extension]] that lets you manage custom editor state. This page walks you through building a state field by implementing a calculator extension.\nThe calculator should be able to add and subtract a number from the current state, and to reset the state when you want to start over.\nBy the end of this page, you’ll understand the basic concepts of building a state field.\n[!note] This page aims to distill the official CodeMirror 6 documentation for Obsidian plugin developers. For more detailed information on state fields, refer to State Fields.\nPrerequisites Basic understanding of [[State management]]. Defining state effects State effects describe the state change you’d like to make. You may think of them as methods on a class.\nIn the calculator example, you’d define a state effect for each of the calculator operations:\nconst addEffect = StateEffect.define\u003cnumber\u003e(); const subtractEffect = StateEffect.define\u003cnumber\u003e(); const resetEffect = StateEffect.define(); The type between the angle brackets, \u003c\u003e, defines the input type for the effect. For example, the number you want to add or subtract. The reset effect doesn’t need any input, so you can leave it out.\nDefining a state field Contrary to what one might think, state fields don’t actually store state. They manage it. State fields take the current state, applies any state effects, and returns the new state.\nThe state field contains the calculator logic to apply the mathematical operations depending on the effects in a transaction. Since a transaction can contain multiple effects, for example two additions, the state field needs to apply them all one after another.\nexport const calculatorField = StateField.define\u003cnumber\u003e({ create(state: EditorState): number { return 0; }, update(oldState: number, transaction: Transaction): number { let newState = oldState; for (let effect of transaction.effects) { if (effect.is(addEffect)) { newState += effect.value; } else if (effect.is(subtractEffect)) { newState -= effect.value; } else if (effect.is(resetEffect)) { newState = 0; } } return newState; }, }); create returns the value the calculator starts with. update contains the logic for applying the effects. effect.is() lets you check the type of the effect before you apply it. Dispatching state effects To apply a state effect to a state field, you need to dispatch it to the editor view as part of a transaction.\nview.dispatch({ effects: [addEffect.of(num)], }); You can even define a set of helper functions that provide a more familiar API:\nexport function add(view: EditorView, num: number) { view.dispatch({ effects: [addEffect.of(num)], }); } export function subtract(view: EditorView, num: number) { view.dispatch({ effects: [subtractEffect.of(num)], }); } export function reset(view: EditorView) { view.dispatch({ effects: [resetEffect.of(null)], }); } Next steps Provide [[Decorations]] from your state fields to change how to display the document.\n","categories":"","description":"","excerpt":"A state field is an [[Editor extensions|editor extension]] that lets …","ref":"/plugins/editor/state-fields/","tags":"","title":""},{"body":"상태 필드(State field)는 사용자 정의 에디터 상태를 관리할 수 있는 [[Editor extensions|에디터 확장 기능]]입니다. 이 페이지는 계산기 확장 기능을 구현하면서 상태 필드를 구축하는 과정을 안내합니다.\n계산기는 현재 상태에 숫자를 더하거나 빼고, 다시 시작하려면 상태를 초기화할 수 있어야 합니다.\n이 페이지를 마치면 상태 필드를 구축하는 기본 개념을 이해하게 될 것입니다.\n[!note] 이 페이지는 Obsidian 플러그인 개발자를 위해 공식 CodeMirror 6 문서를 요약한 것입니다. 상태 필드에 대한 더 자세한 정보는 State Fields를 참조하세요.\n필수 조건 [[State management]] 기본 이해 상태 효과 정의 상태 효과(State effect)는 수행하려는 상태 변경을 설명합니다. 클래스의 메서드라고 생각할 수 있습니다.\n계산기 예제에서는 각 계산기 연산에 대한 상태 효과를 정의합니다:\nconst addEffect = StateEffect.define\u003cnumber\u003e(); const subtractEffect = StateEffect.define\u003cnumber\u003e(); const resetEffect = StateEffect.define(); 꺾쇠 괄호 \u003c\u003e 사이의 타입은 효과에 대한 입력 타입을 정의합니다. 예를 들어 더하거나 빼려는 숫자입니다. 리셋 효과는 입력이 필요 없으므로 생략할 수 있습니다.\n상태 필드 정의 생각과 달리 상태 필드는 실제로 상태를 _저장_하지 않습니다. 상태를 _관리_합니다. 상태 필드는 현재 상태를 가져와 상태 효과를 적용하고 새 상태를 반환합니다.\n상태 필드는 트랜잭션의 효과에 따라 수학적 연산을 적용하는 계산기 로직을 포함합니다. 트랜잭션에는 두 개의 추가와 같은 여러 효과가 포함될 수 있으므로 상태 필드는 이를 모두 하나씩 적용해야 합니다.\nexport const calculatorField = StateField.define\u003cnumber\u003e({ create(state: EditorState): number { return 0; }, update(oldState: number, transaction: Transaction): number { let newState = oldState; for (let effect of transaction.effects) { if (effect.is(addEffect)) { newState += effect.value; } else if (effect.is(subtractEffect)) { newState -= effect.value; } else if (effect.is(resetEffect)) { newState = 0; } } return newState; }, }); create는 계산기가 시작하는 값을 반환합니다. update는 효과를 적용하는 로직을 포함합니다. effect.is()는 효과를 적용하기 전에 타입을 확인할 수 있게 합니다. 상태 효과 전달 상태 필드에 상태 효과를 적용하려면 트랜잭션의 일부로 에디터 뷰에 전달해야 합니다.\nview.dispatch({ effects: [addEffect.of(num)], }); 더 친숙한 API를 제공하는 도우미 함수 세트를 정의할 수도 있습니다:\nexport function add(view: EditorView, num: number) { view.dispatch({ effects: [addEffect.of(num)], }); } export function subtract(view: EditorView, num: number) { view.dispatch({ effects: [subtractEffect.of(num)], }); } export function reset(view: EditorView) { view.dispatch({ effects: [resetEffect.of(null)], }); } 다음 단계 상태 필드에서 [[Decorations]]를 제공하여 문서 표시 방식을 변경하세요.\n","categories":"","description":"","excerpt":"상태 필드(State field)는 사용자 정의 에디터 상태를 관리할 수 있는 [[Editor extensions| …","ref":"/ko/plugins/editor/state-fields/","tags":"","title":""},{"body":"This page aims to give an introduction to state management for [[Editor extensions|editor extensions]].\n[!note] This page aims to distill the official CodeMirror 6 documentation for Obsidian plugin developers. For more detailed information on state management, refer to State and Updates.\nState changes In most applications, you would update state by assigning a new value to a property or variable. As a consequence, the old value is lost forever.\nlet note = ''; note = 'Heading' note = '# Heading' note = '## Heading' // How to undo this? To support features like undoing and redoing changes to a user’s workspace, applications like Obsidian instead keep a history of all changes that have been made. To undo a change, you can then go back to a point in time before the change was made.\nState 0 1 Heading 2 # Heading 3 ## Heading In TypeScript, you’d then end up with something like this:\nconst changes: ChangeSpec[] = []; changes.push({ from: 0, insert: 'Heading' }); changes.push({ from: 0, insert: '# ' }); changes.push({ from: 0, insert: '#' }); Transactions Imagine a feature where you select some text and press the double quote, \" to surround the selection with quotes on both sides. One way to implement the feature would be to:\nInsert \" at the start of the selection. Insert \" at the end of the selection. Notice that the implementation consists of two state changes. If you added these to the undo history, the user would need to undo twice, once for each double quote. To avoid this, what if you could group these changes so that they appear as one?\nFor editor extensions, a group of state changes that happen together is called a transaction.\nIf you combine what you’ve learned so far—and if you allow transactions that contain only a single state change—then you can consider state as a history of transactions.\nBringing it all together to implement the surround feature from before in an editor extension, here’s how you’d add, or dispatch, a transaction to the editor view:\nview.dispatch({ changes: [ { from: selectionStart, insert: `\"` }, { from: selectionEnd, insert: `\"` } ] }); Next steps On this page, you’ve learned about modeling state as a series of state changes, and how to group them into transactions.\nTo learn how to manage custom state in your editor, refer to [[State fields]].\n","categories":"","description":"","excerpt":"This page aims to give an introduction to state management for …","ref":"/plugins/editor/state-management/","tags":"","title":""},{"body":"이 페이지는 [[Editor extensions|에디터 확장 기능]]을 위한 상태 관리에 대한 소개를 제공합니다.\n[!note] 이 페이지는 Obsidian 플러그인 개발자를 위해 공식 CodeMirror 6 문서를 요약한 것입니다. 상태 관리에 대한 더 자세한 정보는 State and Updates를 참조하세요.\n상태 변경 대부분의 애플리케이션에서는 속성이나 변수에 새 값을 할당하여 상태를 업데이트합니다. 결과적으로 이전 값은 영원히 사라집니다.\nlet note = ''; note = 'Heading' note = '# Heading' note = '## Heading' // 이 변경을 어떻게 취소할까요? 사용자 작업 공간에 대한 변경 사항을 실행 취소/다시 실행하는 기능을 지원하기 위해 Obsidian과 같은 애플리케이션은 대신 모든 변경 사항의 기록을 유지합니다. 변경 사항을 취소하려면 변경 전의 시점으로 돌아갈 수 있습니다.\n상태 0 1 Heading 2 # Heading 3 ## Heading TypeScript에서는 다음과 같이 표현할 수 있습니다:\nconst changes: ChangeSpec[] = []; changes.push({ from: 0, insert: 'Heading' }); changes.push({ from: 0, insert: '# ' }); changes.push({ from: 0, insert: '#' }); 트랜잭션 텍스트를 선택하고 큰따옴표 \"를 눌러 선택 영역 양쪽에 따옴표를 추가하는 기능을 상상해 보세요. 이 기능을 구현하는 한 가지 방법은:\n선택 영역 시작에 \" 삽입 선택 영역 끝에 \" 삽입 구현에는 _두 개_의 상태 변경이 포함됩니다. 이를 실행 취소 기록에 추가하면 사용자는 각 따옴표에 대해 한 번씩 두 번 실행 취소해야 합니다. 이를 피하기 위해 이러한 변경 사항을 그룹화하여 하나로 표시할 수 있다면 어떨까요?\n에디터 확장 기능에서 함께 발생하는 상태 변경 그룹을 _트랜잭션_이라고 합니다.\n지금까지 배운 내용을 결합하고 단일 상태 변경만 포함하는 트랜잭션을 허용한다면 상태를 _트랜잭션 기록_으로 간주할 수 있습니다.\n앞서 언급한 따옴표 감싸기 기능을 에디터 확장 기능으로 구현하려면 다음과 같이 에디터 뷰에 트랜잭션을 추가(또는 전달)합니다:\nview.dispatch({ changes: [ { from: selectionStart, insert: `\"` }, { from: selectionEnd, insert: `\"` } ] }); 다음 단계 이 페이지에서는 상태를 일련의 상태 변경으로 모델링하는 방법과 이를 트랜잭션으로 그룹화하는 방법에 대해 배웠습니다.\n에디터에서 사용자 정의 상태를 관리하는 방법을 배우려면 [[State fields]]를 참조하세요.\n","categories":"","description":"","excerpt":"이 페이지는 [[Editor extensions|에디터 확장 기능]]을 위한 상태 관리에 대한 소개를 제공합니다. …","ref":"/ko/plugins/editor/state-management/","tags":"","title":""},{"body":"A view plugin is an [[Editor extensions|editor extension]] that gives you access to the editor [[Viewport]].\n[!note] This page aims to distill the official CodeMirror 6 documentation for Obsidian plugin developers. For more information on state management, refer to Affecting the View.\nPrerequisites Basic understanding of the [[Viewport]]. Creating a view plugin View plugins are editor extensions that run after the viewport has been recomputed. While this means that they can access the viewport, it also means that a view plugin can’t make any changes that would impact the viewport. For example, by inserting blocks or line breaks into the document.\n[!tip] If you want to make changes that impact the vertical layout of the editor, by for example inserting blocks and line breaks, you need to use a [[State fields|state field]].\nTo create a view plugin, create a class that implements PluginValue and pass it to the ViewPlugin.fromClass() function.\nimport { ViewUpdate, PluginValue, EditorView, ViewPlugin, } from '@codemirror/view'; class ExamplePlugin implements PluginValue { constructor(view: EditorView) { // ... } update(update: ViewUpdate) { // ... } destroy() { // ... } } export const examplePlugin = ViewPlugin.fromClass(ExamplePlugin); The three methods of the view plugin control its lifecycle:\nconstructor() initializes the plugin. update() updates your plugin when something has changed, for example when the user entered or selected some text. destroy() cleans up after the plugin. While the view plugin in the example works, it doesn’t do much. If you want to better understand what causes the plugin to update, you can add a console.log(update); line to the update() method to print all updates to the console.\nNext steps Provide [[Decorations]] from your view plugin to change how to display the document.\n","categories":"","description":"","excerpt":"A view plugin is an [[Editor extensions|editor extension]] that gives …","ref":"/plugins/editor/view-plugins/","tags":"","title":""},{"body":"뷰 플러그인(View plugin)은 에디터 [[Viewport|뷰포트]]에 접근할 수 있는 [[Editor extensions|에디터 확장 기능]]입니다.\n[!note] 이 페이지는 Obsidian 플러그인 개발자를 위해 공식 CodeMirror 6 문서를 요약한 것입니다. 상태 관리에 대한 더 자세한 정보는 Affecting the View를 참조하세요.\n필수 조건 [[Viewport|뷰포트]] 기본 이해 뷰 플러그인 생성 뷰 플러그인은 뷰포트가 재계산된 후에 실행되는 에디터 확장 기능입니다. 이는 뷰포트에 접근할 수 있음을 의미하지만, 동시에 뷰 플러그인은 뷰포트에 영향을 미치는 변경 사항을 만들 수 없음을 의미합니다. 예를 들어 문서에 블록이나 줄 바꿈을 삽입하는 등의 작업은 불가능합니다.\n[!tip] 블록이나 줄 바꿈을 삽입하는 등 에디터의 수직 레이아웃에 영향을 주는 변경을 원한다면 [[State fields|상태 필드]]를 사용해야 합니다.\n뷰 플러그인을 생성하려면 PluginValue를 구현하는 클래스를 만들고 ViewPlugin.fromClass() 함수에 전달하세요.\nimport { ViewUpdate, PluginValue, EditorView, ViewPlugin, } from '@codemirror/view'; class ExamplePlugin implements PluginValue { constructor(view: EditorView) { // ... } update(update: ViewUpdate) { // ... } destroy() { // ... } } export const examplePlugin = ViewPlugin.fromClass(ExamplePlugin); 뷰 플러그인의 세 가지 메서드는 라이프사이클을 제어합니다:\nconstructor(): 플러그인을 초기화합니다. update(): 사용자가 텍스트를 입력하거나 선택하는 등 변경 사항이 있을 때 플러그인을 업데이트합니다. destroy(): 플러그인 정리 작업을 수행합니다. 예제의 뷰 플러그인은 동작하지만 많은 기능을 하지 않습니다. 플러그인이 업데이트되는 원인을 더 잘 이해하려면 update() 메서드에 console.log(update); 줄을 추가하여 모든 업데이트를 콘솔에 출력할 수 있습니다.\n다음 단계 뷰 플러그인에서 [[Decorations|데코레이션]]을 제공하여 문서 표시 방식을 변경하세요.\n","categories":"","description":"","excerpt":"뷰 플러그인(View plugin)은 에디터 [[Viewport|뷰포트]]에 접근할 수 있는 [[Editor …","ref":"/ko/plugins/editor/view-plugins/","tags":"","title":""},{"body":"The Obsidian editor supports huge documents with millions of lines. One of the reasons why this is possible, is because the editor only renders what’s visible (and a little bit more).\nImagine that you want to edit a document that is too big to fit on your monitor. The Obsidian editor creates a “window” that moves across the document, only rendering the content within the window (and ignoring what’s outside). This window is known as the editor’s viewport.\nWhenever the user scrolls through the document, or when the document itself changes, the viewport becomes out-of-date and needs to be recomputed.\nIf you want to build an editor extension that depends on the viewport, refer to [[View plugins]].\n[!note] This page aims to distill the official CodeMirror 6 documentation for Obsidian plugin developers. For more information on state management, refer to Viewport.\n","categories":"","description":"","excerpt":"The Obsidian editor supports huge documents with millions of lines. …","ref":"/plugins/editor/viewport/","tags":"","title":""},{"body":"Obsidian 에디터는 수백만 줄에 달하는 거대한 문서를 지원합니다. 이것이 가능한 이유 중 하나는 에디터가 현재 보이는 부분(그리고 그 주변 약간)만 렌더링하기 때문입니다.\n모니터에 한 번에 담을 수 없을 만큼 큰 문서를 편집한다고 상상해 보세요. Obsidian 에디터는 문서를 가로지르며 움직이는 “창(window)“을 생성하여, 이 창 내부의 콘텐츠만 렌더링하고 창 밖의 내용은 무시합니다. 이 창을 에디터의 viewport 라고 합니다.\n사용자가 문서를 스크롤하거나 문서 자체가 변경될 때마다 viewport는 최신 상태가 아니게 되며 재계산이 필요합니다.\nviewport에 의존하는 에디터 확장을 만들고 싶다면, [[View plugins]]를 참조하세요.\n[!note] 이 페이지는 Obsidian 플러g인 개발자를 위해 공식 CodeMirror 6 문서를 요약한 것입니다. 상태 관리에 대한 더 자세한 정보는 Viewport를 참조하세요.\n","categories":"","description":"","excerpt":"Obsidian 에디터는 수백만 줄에 달하는 거대한 문서를 지원합니다. 이것이 가능한 이유 중 하나는 에디터가 현재 보이는 부 …","ref":"/ko/plugins/editor/viewport/","tags":"","title":""},{"body":"Many of the interfaces in the Obsidian lets you subscribe to events throughout the application, for example when the user makes changes to a file.\nAny registered event handlers need to be detached whenever the plugin unloads. The safest way to make sure this happens is to use the [[registerEvent|registerEvent()]] method.\nimport { Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { this.registerEvent(this.app.vault.on('create', () =\u003e { console.log('a new file has entered the arena') })); } } Timing events If you want to repeatedly call a function with a fixed delay, use the window.setInterval() function with the [[registerInterval|registerInterval()]] method.\nThe following example displays the current time in the status bar, updated every second:\nimport { moment, Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { statusBar: HTMLElement; async onload() { this.statusBar = this.addStatusBarItem(); this.updateStatusBar(); this.registerInterval( window.setInterval(() =\u003e this.updateStatusBar(), 1000) ); } updateStatusBar() { this.statusBar.setText(moment().format('H:mm:ss')); } } [!tip] Date and time Moment is a popular JavaScript library for working with dates and time. Obsidian uses Moment internally, so you don’t need to install it yourself. You can import it from the Obsidian API instead:\nimport { moment } from 'obsidian'; ","categories":"","description":"","excerpt":"Many of the interfaces in the Obsidian lets you subscribe to events …","ref":"/plugins/events/","tags":"","title":""},{"body":"Obsidian의 많은 인터페이스에서는 애플리케이션 전체에서 발생하는 이벤트를 구독할 수 있습니다. 예를 들어 사용자가 파일을 변경할 때와 같은 이벤트입니다.\n등록된 모든 이벤트 핸들러는 플러그인이 언로드될 때 분리되어야 합니다. 이를 보장하는 가장 안전한 방법은 [[registerEvent|registerEvent()]] 메서드를 사용하는 것입니다.\nimport { Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { this.registerEvent(this.app.vault.on('create', () =\u003e { console.log('새 파일이 생성되었습니다'); })); } } 타이밍 이벤트 일정한 간격으로 함수를 반복적으로 호출하려면 [[registerInterval|registerInterval()]] 메서드와 함께 window.setInterval() 함수를 사용하세요.\n다음 예제는 상태 표시줄에 현재 시간을 1초마다 업데이트하여 표시합니다:\nimport { moment, Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { statusBar: HTMLElement; async onload() { this.statusBar = this.addStatusBarItem(); this.updateStatusBar(); this.registerInterval( window.setInterval(() =\u003e this.updateStatusBar(), 1000) ); } updateStatusBar() { this.statusBar.setText(moment().format('H:mm:ss')); } } [!tip] 날짜와 시간 Moment는 날짜와 시간을 다루는 인기 있는 JavaScript 라이브러리입니다. Obsidian은 내부적으로 Moment를 사용하므로 별도로 설치할 필요가 없습니다. 대신 Obsidian API에서 가져올 수 있습니다:\nimport { moment } from 'obsidian'; ","categories":"","description":"","excerpt":"Obsidian의 많은 인터페이스에서는 애플리케이션 전체에서 발생하는 이벤트를 구독할 수 있습니다. …","ref":"/ko/plugins/events/","tags":"","title":""},{"body":"The [[Plugin|Plugin]] class defines the lifecycle of a plugin and exposes the operations available to all plugins:\nimport { Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { // Configure resources needed by the plugin. } async onunload() { // Release any resources configured by the plugin. } } Plugin lifecycle [[onload|onload()]] runs whenever the user starts using the plugin in Obsidian. This is where you’ll configure most of the plugin’s capabilities.\n[[onunload|onunload()]] runs when the plugin is disabled. Any resources that your plugin is using must be released here to avoid affecting the performance of Obsidian after your plugin has been disabled.\nTo better understand when these methods are called, you can print a message to the console whenever the plugin loads and unloads. The console is a valuable tool that lets developers monitor the status of their code.\nTo view the console:\nToggle the Developer Tools by pressing Ctrl+Shift+I in Windows and Linux, or Cmd-Option-I on macOS. Click on the Console tab in the Developer Tools window. import { Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { console.log('loading plugin') } async onunload() { console.log('unloading plugin') } } ","categories":"","description":"","excerpt":"The [[Plugin|Plugin]] class defines the lifecycle of a plugin and …","ref":"/plugins/getting-started/anatomy-of-a-plugin/","tags":"","title":""},{"body":"[[Plugin|Plugin]] 클래스는 플러그인의 생명주기(lifecycle)를 정의하고 모든 플러그인에서 사용할 수 있는 작업들을 노출합니다:\nimport { Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { // 플러그인에 필요한 리소스를 설정합니다. } async onunload() { // 플러그인에서 설정한 모든 리소스를 해제합니다. } } 플러그인 생명주기 [[onload|onload()]]는 사용자가 Obsidian에서 플러그인을 사용하기 시작할 때마다 실행됩니다. 이곳에서 플러그인의 대부분의 기능을 설정하게 됩니다.\n[[onunload|onunload()]]는 플러그인이 비활성화될 때 실행됩니다. 플러그인이 비활성화된 후 Obsidian의 성능에 영향을 주지 않으려면 플러그인에서 사용하는 모든 리소스를 여기서 해제해야 합니다.\n이 메소드들이 언제 호출되는지 더 잘 이해하기 위해, 플러그인이 로드되거나 언로드될 때마다 콘솔에 메시지를 출력할 수 있습니다. 콘솔은 개발자가 코드 상태를 모니터링할 수 있게 해주는 유용한 도구입니다.\n콘솔을 보려면:\nWindows 및 Linux에서는 Ctrl+Shift+I를, macOS에서는 Cmd-Option-I를 눌러 개발자 도구를 토글합니다. 개발자 도구 창에서 콘솔 탭을 클릭합니다. import { Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { console.log('loading plugin') } async onunload() { console.log('unloading plugin') } } ","categories":"","description":"","excerpt":"[[Plugin|Plugin]] 클래스는 플러그인의 생명주기(lifecycle)를 정의하고 모든 플러그인에서 사용할 수 있는  …","ref":"/ko/plugins/getting-started/anatomy-of-a-plugin/","tags":"","title":""},{"body":"Plugins let you extend Obsidian with your own features to create a custom note-taking experience.\nIn this tutorial, you’ll compile a sample plugin from source code and load it into Obsidian.\nWhat you’ll learn After you’ve completed this tutorial, you’ll be able to:\nConfigure an environment for developing Obsidian plugins. Compile a plugin from source code. Reload a plugin after making changes to it. Prerequisites To complete this tutorial, you’ll need:\nGit installed on your local machine. A local development environment for Node.js. A code editor, such as Visual Studio Code. Before you start When developing plugins, one mistake can lead to unintended changes to your vault. To prevent data loss, you should never develop plugins in your main vault. Always use a separate vault dedicated to plugin development.\nCreate an empty vault.\nStep 1: Download the sample plugin In this step, you’ll download a sample plugin to the plugins directory in your vault’s .obsidian directory so that Obsidian can find it.\nThe sample plugin you’ll use in this tutorial is available in a GitHub repository.\nOpen a terminal window and change the project directory to the plugins directory.\ncd path/to/vault mkdir .obsidian/plugins cd .obsidian/plugins Clone the sample plugin using Git.\ngit clone https://github.com/obsidianmd/obsidian-sample-plugin.git [!tip] GitHub template repository The repository for the sample plugin is a GitHub template repository, which means you can create your own repository from the sample plugin. To learn how, refer to Creating a repository from a template.\nRemember to use the URL of your own repository when cloning the sample plugin.\nStep 2: Build the plugin In this step, you’ll compile the sample plugin so that Obsidian can load it.\nNavigate to the plugin directory.\ncd obsidian-sample-plugin Install dependencies.\nnpm install Compile the source code. The following command keeps running in the terminal and rebuilds the plugin when you modify the source code.\nnpm run dev Notice that the plugin directory now has a main.js file that contains a compiled version of the plugin.\nStep 3: Enable the plugin To load a plugin in Obsidian, you first need to enable it.\nIn Obsidian, open Settings. In the side menu, select Community plugins. Select Turn on community plugins. Under Installed plugins, enable the Sample Plugin by selecting the toggle button next to it. You’re now ready to use the plugin in Obsidian. Next, we’ll make some changes to the plugin.\nStep 4: Update the plugin manifest In this step, you’ll rename the plugin by updating the plugin manifest, manifest.json. The manifest contains information about your plugin, such as its name and description.\nOpen manifest.json in your code editor. Change id to a unique identifier, such as \"hello-world\". Change name to a human-friendly name, such as \"Hello world\". Rename the plugin folder to match the plugin’s id. Restart Obsidian to load the new changes to the plugin manifest. Go back to Installed plugins and notice that the name of the plugin has been updated to reflect the changes you made.\nRemember to restart Obsidian whenever you make changes to manifest.json.\nStep 5: Update the source code To let the user interact with your plugin, add a ribbon icon that greets the user when they select it.\nOpen main.ts in your code editor.\nRename the plugin class from MyPlugin to HelloWorldPlugin.\nImport Notice from the obsidian package.\nimport { Notice, Plugin } from 'obsidian'; In the onload() method, add the following code:\nthis.addRibbonIcon('dice', 'Greet', () =\u003e { new Notice('Hello, world!'); }); In the Command palette, select Reload app without saving to reload the plugin.\nYou can now see a dice icon in the ribbon on the left side of the Obsidian window. Select it to display a message in the upper-right corner.\nRemember, you need to reload your plugin after changing the source code, either by disabling it then enabling it again in the community plugins panel, or using the command palette as detailed in part 5 of this step.\n[!tip] Hot reloading Install the Hot-Reload plugin to automatically reload your plugin while developing.\nConclusion In this tutorial, you’ve built your first Obsidian plugin using the TypeScript API. You’ve modified the plugin and reloaded it to reflect the changes inside Obsidian.\n","categories":"","description":"","excerpt":"Plugins let you extend Obsidian with your own features to create a …","ref":"/plugins/getting-started/build-a-plugin/","tags":"","title":""},{"body":"플러그인(Plugin)을 사용하면 자신만의 기능으로 Obsidian을 확장하여 맞춤형 노트 작성 경험을 만들 수 있습니다.\n이 튜토리얼에서는 샘플 플러그인을 소스 코드(Source Code)에서 컴파일(Compile)하고 Obsidian에 로드하는 방법을 배웁니다.\n학습 내용 이 튜토리얼을 완료하면 다음을 할 수 있게 됩니다:\nObsidian 플러그인 개발을 위한 환경 구성 소스 코드에서 플러그인 컴파일 플러그인을 수정한 후 다시 로드 사전 요구사항 이 튜토리얼을 완료하려면 다음이 필요합니다:\n로컬 머신에 설치된 Git Node.js용 로컬 개발 환경 Visual Studio Code와 같은 코드 에디터(Code Editor) 시작하기 전에 플러그인을 개발할 때 한 번의 실수로 볼트(Vault)에 의도하지 않은 변경이 발생할 수 있습니다. 데이터 손실을 방지하려면 메인 볼트에서 플러그인을 개발해서는 안 됩니다. 항상 플러그인 개발 전용 별도 볼트를 사용하세요.\n빈 볼트 만들기.\n1단계: 샘플 플러그인 다운로드 이 단계에서는 Obsidian이 찾을 수 있도록 볼트의 .obsidian 디렉터리 내 plugins 디렉터리에 샘플 플러그인을 다운로드합니다.\n이 튜토리얼에서 사용할 샘플 플러그인은 GitHub 저장소에서 사용할 수 있습니다.\n터미널(Terminal) 창을 열고 프로젝트 디렉터리를 plugins 디렉터리로 변경합니다.\ncd path/to/vault mkdir .obsidian/plugins cd .obsidian/plugins Git을 사용하여 샘플 플러그인을 클론(Clone)합니다.\ngit clone https://github.com/obsidianmd/obsidian-sample-plugin.git [!tip] GitHub 템플릿 저장소 샘플 플러그인의 저장소는 GitHub 템플릿 저장소(Template Repository)입니다. 즉, 샘플 플러그인에서 자신만의 저장소를 만들 수 있습니다. 방법을 알아보려면 템플릿에서 저장소 만들기를 참조하세요.\n샘플 플러그인을 클론할 때는 자신의 저장소 URL을 사용하는 것을 잊지 마세요.\n2단계: 플러그인 빌드 이 단계에서는 Obsidian이 로드할 수 있도록 샘플 플러그인을 컴파일합니다.\n플러그인 디렉터리로 이동합니다.\ncd obsidian-sample-plugin 의존성(Dependencies)을 설치합니다.\nnpm install 소스 코드를 컴파일합니다. 다음 명령은 터미널에서 계속 실행되며 소스 코드를 수정할 때 플러그인을 다시 빌드합니다.\nnpm run dev 플러그인 디렉터리에 이제 플러그인의 컴파일된 버전이 포함된 main.js 파일이 있는 것을 확인할 수 있습니다.\n3단계: 플러그인 활성화 Obsidian에서 플러그인을 로드하려면 먼저 활성화해야 합니다.\nObsidian에서 설정을 엽니다. 사이드 메뉴에서 커뮤니티 플러그인을 선택합니다. 커뮤니티 플러그인 켜기를 선택합니다. 설치된 플러그인 아래에서 Sample Plugin 옆의 토글 버튼을 선택하여 활성화합니다. 이제 Obsidian에서 플러그인을 사용할 준비가 되었습니다. 다음으로 플러그인을 일부 변경해보겠습니다.\n4단계: 플러그인 매니페스트 업데이트 이 단계에서는 플러그인 매니페스트(Manifest) manifest.json을 업데이트하여 플러그인 이름을 변경합니다. 매니페스트에는 플러그인의 이름과 설명 같은 정보가 포함되어 있습니다.\n코드 에디터에서 manifest.json을 엽니다. id를 \"hello-world\"와 같은 고유 식별자로 변경합니다. name을 \"Hello world\"와 같은 사용자 친화적인 이름으로 변경합니다. 플러그인 폴더 이름을 플러그인의 id와 일치하도록 변경합니다. 플러그인 매니페스트의 새 변경 사항을 로드하려면 Obsidian을 다시 시작합니다. 설치된 플러그인으로 돌아가서 플러그인 이름이 변경한 내용을 반영하여 업데이트된 것을 확인하세요.\nmanifest.json을 변경할 때마다 Obsidian을 다시 시작하는 것을 잊지 마세요.\n5단계: 소스 코드 업데이트 사용자가 플러그인과 상호작용할 수 있도록 사용자가 선택했을 때 인사말을 표시하는 _리본 아이콘(Ribbon Icon)_을 추가합니다.\n코드 에디터에서 main.ts를 엽니다.\n플러그인 클래스(Class) 이름을 MyPlugin에서 HelloWorldPlugin으로 변경합니다.\nobsidian 패키지(Package)에서 Notice를 가져옵니다(Import).\nimport { Notice, Plugin } from 'obsidian'; onload() 메서드(Method)에서 다음 코드를 추가합니다:\nthis.addRibbonIcon('dice', 'Greet', () =\u003e { new Notice('Hello, world!'); }); **명령 팔레트(Command Palette)**에서 저장하지 않고 앱 다시 로드를 선택하여 플러그인을 다시 로드합니다.\n이제 Obsidian 창 왼쪽의 리본에서 주사위 아이콘을 볼 수 있습니다. 이를 선택하면 오른쪽 상단 모서리에 메시지가 표시됩니다.\n소스 코드를 변경한 후에는 플러그인을 다시 로드해야 한다는 점을 기억하세요. 커뮤니티 플러그인 패널에서 비활성화한 다음 다시 활성화하거나 이 단계의 5번에서 설명한 대로 명령 팔레트를 사용하면 됩니다.\n[!tip] 핫 리로딩(Hot Reloading) 개발하는 동안 플러그인을 자동으로 다시 로드하려면 Hot-Reload 플러그인을 설치하세요.\n결론 이 튜토리얼에서는 TypeScript API를 사용하여 첫 번째 Obsidian 플러그인을 빌드했습니다. 플러그인을 수정하고 다시 로드하여 Obsidian 내에서 변경 사항을 반영했습니다.\n","categories":"","description":"","excerpt":"플러그인(Plugin)을 사용하면 자신만의 기능으로 Obsidian을 확장하여 맞춤형 노트 작성 경험을 만들 수 있습니다. …","ref":"/ko/plugins/getting-started/build-a-plugin/","tags":"","title":""},{"body":"Whenever you make a change to the plugin source code, the plugin needs to be reloaded. You can reload the plugin by quitting Obsidian and starting it again, but that gets tiring quickly.\nReload plugin inside Obsidian You can reload the plugin by re-enabling it in the list of installed plugins:\nOpen Preferences. Click Community plugins. Find your plugin under Installed plugins. Toggle the switch off to disable the plugin. Toggle the switch on to enable the plugin. You’re now running the updated version of your plugin.\nReload plugin on file changes The Hot-Reload plugin reloads your plugin whenever the source code changes.\nFor more information, check out the forum announcement.\n","categories":"","description":"","excerpt":"Whenever you make a change to the plugin source code, the plugin needs …","ref":"/plugins/getting-started/development-workflow/","tags":"","title":""},{"body":"플러그인 소스 코드를 변경할 때마다 플러그인을 다시 로드해야 합니다. Obsidian을 종료했다가 다시 시작하여 플러그인을 다시 로드할 수 있지만, 이 방법은 금방 지치게 됩니다.\nObsidian 내에서 플러그인 다시 로드하기 설치된 플러그인 목록에서 플러그인을 다시 활성화하여 다시 로드할 수 있습니다:\nPreferences를 엽니다. Community plugins를 클릭합니다. Installed plugins 아래에서 플러그인을 찾습니다. 스위치를 꺼서 플러그인을 비활성화합니다. 스위치를 켜서 플러그인을 활성화합니다. 이제 업데이트된 버전의 플러그인을 실행하고 있습니다.\n파일 변경 시 플러그인 다시 로드하기 Hot-Reload 플러그인은 소스 코드가 변경될 때마다 플러그인을 다시 로드합니다.\n더 자세한 정보는 포럼 공지를 확인하세요.\n","categories":"","description":"","excerpt":"플러그인 소스 코드를 변경할 때마다 플러그인을 다시 로드해야 합니다. Obsidian을 종료했다가 다시 시작하여 플러그인을 다 …","ref":"/ko/plugins/getting-started/development-workflow/","tags":"","title":""},{"body":"Learn how you can develop your plugin for mobile devices.\nEmulate mobile device on desktop You can emulate Obsidian running a mobile device directly from the Developer Tools.\nOpen the Developer Tools.\nSelect the Console tab.\nEnter the following and then press Enter.\nthis.app.emulateMobile(true); To disable mobile emulation, enter the following and press Enter:\nthis.app.emulateMobile(false); [!tip] To instead toggle mobile emulation back and forth, you can use the this.app.isMobile flag:\nthis.app.emulateMobile(!this.app.isMobile); Inspecting the webview on the actual mobile device Android You can inspect Obsidian running on an Android device if you enable USB Debugging in Developer settings of Android. Then go to a chromium based browser on your desktop/laptop and navigate to chrome://inspect/. If you did everything right, if you have your phone/tablet connected to your PC via USB and the browser open at that link you should see your device pop up and it will let you run the usual devtools from there on it.\nMore in depth information can be found here: https://developer.chrome.com/docs/devtools/remote-debugging\niOS You can inspect Obsidian on an iOS device running 16.4 or later and a macOS based computer. Instructions on how to set it up can be found here: https://webkit.org/web-inspector/enabling-web-inspector/\nPlatform-specific features To detect the platform your plugin is running on, you can use [[Platform]]:\nimport { Platform } from 'obsidian'; if (Platform.isIosApp) { // ... } if (Platform.isAndroidApp) { // ... } Disable your plugin on mobile devices If your plugin requires the Node.js or Electron API, you can prevent users from installing the plugin on mobile devices.\nTo only support the desktop app, set isDesktopOnly to true in the [[Manifest]].\nTroubleshooting This section lists common issues when developing for mobile devices.\nNode and Electron APIs The Node.js API, and the Electron API aren’t available on mobile devices. Any calls to these libraries made by your plugin or it’s dependencies can cause your plugin to crash.\nLookbehind in regular expressions Lookbehind in regular expressions is only supported on iOS 16.4 and above, and some iPhone and iPad users may still use earlier versions. To implement a fallback for iOS users, either refer to [[#Platform-specific features]], or use a JavaScript library to detect specific browser versions.\nRefer to Can I Use for more information and exact version statistics. Look for “Safari on iOS”.\n","categories":"","description":"","excerpt":"Learn how you can develop your plugin for mobile devices.\nEmulate …","ref":"/plugins/getting-started/mobile-development/","tags":"","title":""},{"body":"모바일 기기용 플러그인을 개발하는 방법을 알아보세요.\n데스크톱에서 모바일 기기 에뮬레이션하기 개발자 도구에서 직접 모바일 기기에서 실행되는 Obsidian을 에뮬레이션할 수 있습니다.\n개발자 도구를 엽니다. 콘솔 탭을 선택합니다. 다음을 입력하고 Enter를 누릅니다. this.app.emulateMobile(true); 모바일 에뮬레이션을 비활성화하려면 다음을 입력하고 Enter를 누릅니다:\nthis.app.emulateMobile(false); [!tip] 모바일 에뮬레이션을 번갈아 토글하려면 this.app.isMobile 플래그를 사용할 수 있습니다:\nthis.app.emulateMobile(!this.app.isMobile); 실제 모바일 기기에서 웹뷰 검사하기 Android Android의 개발자 설정에서 USB 디버깅을 활성화하면 Android 기기에서 실행 중인 Obsidian을 검사할 수 있습니다. 그런 다음 데스크톱/노트북의 크롬 기반 브라우저로 이동하여 chrome://inspect/로 이동합니다. 모든 작업을 올바르게 수행했다면, 휴대폰/태블릿을 USB를 통해 PC에 연결하고 해당 링크에서 브라우저를 열었을 때 기기가 팝업으로 나타나며, 거기서부터 일반적인 개발자 도구를 실행할 수 있습니다.\n더 자세한 정보는 여기서 찾을 수 있습니다: https://developer.chrome.com/docs/devtools/remote-debugging\niOS iOS 16.4 이상을 실행하는 iOS 기기와 macOS 기반 컴퓨터에서 Obsidian을 검사할 수 있습니다. 설정 방법에 대한 지침은 여기서 찾을 수 있습니다: https://webkit.org/web-inspector/enabling-web-inspector/\n플랫폼별 기능 플러그인이 실행 중인 플랫폼을 감지하려면 [[Platform]]을 사용할 수 있습니다:\nimport { Platform } from 'obsidian'; if (Platform.isIosApp) { // ... } if (Platform.isAndroidApp) { // ... } 모바일 기기에서 플러그인 비활성화하기 플러그인에 Node.js 또는 Electron API가 필요한 경우, 사용자가 모바일 기기에 플러그인을 설치하지 못하도록 할 수 있습니다.\n데스크톱 앱만 지원하려면 [[Manifest]]에서 isDesktopOnly를 true로 설정하세요.\n문제 해결 이 섹션에서는 모바일 기기용으로 개발할 때 흔히 발생하는 문제들을 나열합니다.\nNode 및 Electron API Node.js API와 Electron API는 모바일 기기에서 사용할 수 없습니다. 플러그인이나 그 종속성에서 이러한 라이브러리를 호출하면 플러그인이 충돌할 수 있습니다.\n정규 표현식의 Lookbehind 정규 표현식의 Lookbehind는 iOS 16.4 이상에서만 지원되며, 일부 iPhone 및 iPad 사용자는 여전히 이전 버전을 사용할 수 있습니다. iOS 사용자를 위한 대체(fallback) 기능을 구현하려면 [[#Platform-specific features]]를 참조하거나, 특정 브라우저 버전을 감지하는 JavaScript 라이브러리를 사용하세요.\n더 자세한 정보와 정확한 버전 통계는 Can I Use를 참조하세요. “Safari on iOS\"를 찾아보세요.\n","categories":"","description":"","excerpt":"모바일 기기용 플러그인을 개발하는 방법을 알아보세요.\n데스크톱에서 모바일 기기 에뮬레이션하기 개발자 도구에서 직접 모바일 기기 …","ref":"/ko/plugins/getting-started/mobile-development/","tags":"","title":""},{"body":"In this guide, you’ll configure your plugin to use React. It assumes that you already have a plugin with a [[Views|custom view]] that you want to convert to use React.\nWhile you don’t need to use a separate framework to build a plugin, there are a few reasons why you’d want to use React:\nYou have existing experience of React and want to use a familiar technology. You have existing React components that you want to reuse in your plugin. Your plugin requires complex state management or other features that can be cumbersome to implement with regular [[HTML elements]]. Configure your plugin Add React to your plugin dependencies:\nnpm install react react-dom Add type definitions for React:\nnpm install --save-dev @types/react @types/react-dom In tsconfig.json, enable JSX support on the compilerOptions object:\n{ \"compilerOptions\": { \"jsx\": \"react-jsx\" } } Create a React component Create a new file called ReactView.tsx in the plugin root directory, with the following content:\nexport const ReactView = () =\u003e { return \u003ch4\u003eHello, React!\u003c/h4\u003e; }; Mount the React component To use the React component, it needs to be mounted on a [[HTML elements|HTML element]]. The following example mounts the ReactView component on the this.contentEl element:\nimport { StrictMode } from 'react'; import { ItemView, WorkspaceLeaf } from 'obsidian'; import { Root, createRoot } from 'react-dom/client'; import { ReactView } from './ReactView'; const VIEW_TYPE_EXAMPLE = 'example-view'; class ExampleView extends ItemView { root: Root | null = null; constructor(leaf: WorkspaceLeaf) { super(leaf); } getViewType() { return VIEW_TYPE_EXAMPLE; } getDisplayText() { return 'Example view'; } async onOpen() { this.root = createRoot(this.contentEl); this.root.render( \u003cStrictMode\u003e \u003cReactView /\u003e, \u003c/StrictMode\u003e, ); } async onClose() { this.root?.unmount(); } } For more information on createRoot and unmount(), refer to the documentation on ReactDOM.\nYou can mount your React component on any HTMLElement, for example [[Plugins/User interface/Status bar|status bar items]]. Just make sure to clean up properly by calling this.root.unmount() when you’re done.\nCreate an App context If you want to access the [[Reference/TypeScript API/App|App]] object from one of your React components, you need to pass it as a dependency. As your plugin grows, even though you’re only using the App object in a few places, you start passing it through the whole component tree.\nAnother alternative is to create a React context for the app to make it globally available to all components inside your React view.\nUse createContext() to create a new app context.\nimport { createContext } from 'react'; import { App } from 'obsidian'; export const AppContext = createContext\u003cApp | undefined\u003e(undefined); Wrap the ReactView with a context provider and pass the app as the value.\nthis.root = createRoot(this.contentEl); this.root.render( \u003cAppContext.Provider value={this.app}\u003e \u003cReactView /\u003e \u003c/AppContext.Provider\u003e ); Create a custom hook to make it easier to use the context in your components.\nimport { useContext } from 'react'; import { AppContext } from './context'; export const useApp = (): App | undefined =\u003e { return useContext(AppContext); }; Use the hook in any React component within ReactView to access the app.\nimport { useApp } from './hooks'; export const ReactView = () =\u003e { const { vault } = useApp(); return \u003ch4\u003e{vault.getName()}\u003c/h4\u003e; }; For more information, refer to the React documentation for Passing Data Deeply with Context and Reusing Logic with Custom Hooks.\n","categories":"","description":"","excerpt":"In this guide, you’ll configure your plugin to use React. It assumes …","ref":"/plugins/getting-started/use-react-in-your-plugin/","tags":"","title":""},{"body":"이 가이드에서는 React를 사용하도록 플러그인을 설정합니다. React를 사용하도록 변환하려는 [[Views|사용자 정의 뷰]]가 이미 있는 플러그인을 가지고 있다고 가정합니다.\n플러그인을 빌드하기 위해 별도의 프레임워크를 사용할 필요는 없지만, React를 사용하려는 몇 가지 이유가 있습니다:\nReact에 대한 기존 경험이 있고 익숙한 기술을 사용하고 싶을 때. 플러그인에서 재사용하고 싶은 기존 React 컴포넌트가 있을 때. 플러그인에 복잡한 상태 관리나 일반적인 [[HTML elements]]로 구현하기 번거로운 다른 기능이 필요할 때. 플러그인 설정하기 플러그인 종속성에 React를 추가합니다:\nnpm install react react-dom React에 대한 타입 정의를 추가합니다:\nnpm install --save-dev @types/react @types/react-dom tsconfig.json의 compilerOptions 객체에서 JSX 지원을 활성화합니다:\n{ \"compilerOptions\": { \"jsx\": \"react-jsx\" } } React 컴포넌트 생성하기 플러그인 루트 디렉토리에 ReactView.tsx라는 새 파일을 만들고 다음 내용을 추가합니다:\nexport const ReactView = () =\u003e { return \u003ch4\u003eHello, React!\u003c/h4\u003e; }; React 컴포넌트 마운트하기 React 컴포넌트를 사용하려면 [[HTML elements|HTML 요소]]에 마운트해야 합니다. 다음 예제는 ReactView 컴포넌트를 this.contentEl 요소에 마운트합니다:\nimport { StrictMode } from 'react'; import { ItemView, WorkspaceLeaf } from 'obsidian'; import { Root, createRoot } from 'react-dom/client'; import { ReactView } from './ReactView'; const VIEW_TYPE_EXAMPLE = 'example-view'; class ExampleView extends ItemView { root: Root | null = null; constructor(leaf: WorkspaceLeaf) { super(leaf); } getViewType() { return VIEW_TYPE_EXAMPLE; } getDisplayText() { return 'Example view'; } async onOpen() { this.root = createRoot(this.contentEl); this.root.render( \u003cStrictMode\u003e \u003cReactView /\u003e, \u003c/StrictMode\u003e, ); } async onClose() { this.root?.unmount(); } } createRoot 및 unmount()에 대한 자세한 내용은 ReactDOM 문서를 참조하세요.\nReact 컴포넌트를 [[Plugins/User interface/Status bar|상태 표시줄 항목]]과 같은 모든 HTMLElement에 마운트할 수 있습니다. 작업이 끝나면 this.root.unmount()를 호출하여 제대로 정리해야 합니다.\nApp 컨텍스트 생성하기 React 컴포넌트 중 하나에서 [[Reference/TypeScript API/App|App]] 객체에 접근하려면 이를 종속성으로 전달해야 합니다. 플러그인이 커지면서 App 객체를 몇 군데에서만 사용하더라도 전체 컴포넌트 트리를 통해 전달하기 시작합니다.\n또 다른 대안은 앱에 대한 React 컨텍스트를 만들어 React 뷰 내부의 모든 컴포넌트에서 전역적으로 사용할 수 있도록 하는 것입니다.\ncreateContext()를 사용하여 새 앱 컨텍스트를 만듭니다.\nimport { createContext } from 'react'; import { App } from 'obsidian'; export const AppContext = createContext\u003cApp | undefined\u003e(undefined); ReactView를 컨텍스트 제공자로 감싸고 앱을 값으로 전달합니다.\nthis.root = createRoot(this.contentEl); this.root.render( \u003cAppContext.Provider value={this.app}\u003e \u003cReactView /\u003e \u003c/AppContext.Provider\u003e ); 컴포넌트에서 컨텍스트를 더 쉽게 사용할 수 있도록 사용자 정의 훅을 만듭니다.\nimport { useContext } from 'react'; import { AppContext } from './context'; export const useApp = (): App | undefined =\u003e { return useContext(AppContext); }; ReactView 내의 모든 React 컴포넌트에서 훅을 사용하여 앱에 접근합니다.\nimport { useApp } from './hooks'; export const ReactView = () =\u003e { const { vault } = useApp(); return \u003ch4\u003e{vault.getName()}\u003c/h4\u003e; }; 자세한 내용은 React 문서의 Passing Data Deeply with Context 및 Reusing Logic with Custom Hooks를 참조하세요.\n","categories":"","description":"","excerpt":"이 가이드에서는 React를 사용하도록 플러그인을 설정합니다. React를 사용하도록 변환하려는 [[Views|사용자 정의  …","ref":"/ko/plugins/getting-started/use-react-in-your-plugin/","tags":"","title":""},{"body":"This guide explains how to configure your plugin to use Svelte, a light-weight alternative to traditional frameworks like React and Vue.\nSvelte is built around a compiler that preprocesses your code and outputs optimized vanilla JavaScript. This means that it doesn’t need a virtual DOM to track state changes, which allows your plugin to run with minimal additional overhead.\nIf you want to learn more about Svelte, and how to use it, refer to the tutorial and the documentation.\nThis guide assumes that you’ve finished [[Build a plugin]].\n[!tip] Visual Studio Code Svelte has an official Visual Studio Code extension that enables syntax highlighting and rich IntelliSense in Svelte components.\nConfigure your plugin To build a plugin with Svelte, you need to install the dependencies and configure your plugin to compile code written using Svelte. If you only want to use TypeScript’s type-only features, you don’t need svelte-preprocess.\nAdd Svelte to your plugin dependencies:\nnpm install --save-dev svelte svelte-preprocess esbuild-svelte svelte-check [!info] Svelte requires at least TypeScript 5.0. To update to Typescript 5.0 run the following in your terminal.\nnpm install typescript@~5.0.0 Extend the tsconfig.json to enable additional type checking for common Svelte issues. verbatimModuleSyntax is needed for svelte-preprocess and skipLibCheck is needed for svelte-check to work correctly.\n{ \"compilerOptions\": { \"verbatimModuleSyntax\": true, \"skipLibCheck\": true, // ... }, \"include\": [ \"**/*.ts\", \"**/*.svelte\" ] } In esbuild.config.mjs, add the following imports to the top of the file:\nimport esbuildSvelte from 'esbuild-svelte'; import { sveltePreprocess } from 'svelte-preprocess'; Add Svelte to the list of plugins.\nconst context = await esbuild.context({ plugins: [ esbuildSvelte({ compilerOptions: { css: 'injected' }, preprocess: sveltePreprocess(), }), ], // ... }); Add a script to run svelte-check to your package.json.\n{ // ... \"scripts\": { // ... \"svelte-check\": \"svelte-check --tsconfig tsconfig.json\" } } Create a Svelte component In the root directory of the plugin, create a new file called Counter.svelte:\n\u003cscript lang=\"ts\"\u003e interface Props { startCount: number; } let { startCount }: Props = $props(); let count = $state(startCount); export function increment() { count += 1; } \u003c/script\u003e \u003cdiv class=\"number\"\u003e \u003cspan\u003eMy number is {count}!\u003c/span\u003e \u003c/div\u003e \u003cstyle\u003e .number { color: red; } \u003c/style\u003e Mount the Svelte component To use the Svelte component, it needs to be mounted on an existing [[HTML elements|HTML element]]. For example, if you are mounting on a custom [[ItemView|ItemView]] in Obsidian:\nimport { ItemView, WorkspaceLeaf } from 'obsidian'; // Import the Counter Svelte component and the `mount` and `unmount` methods. import Counter from './Counter.svelte'; import { mount, unmount } from 'svelte'; export const VIEW_TYPE_EXAMPLE = 'example-view'; export class ExampleView extends ItemView { // A variable to hold on to the Counter instance mounted in this ItemView. counter: ReturnType\u003ctypeof Counter\u003e | undefined; constructor(leaf: WorkspaceLeaf) { super(leaf); } getViewType() { return VIEW_TYPE_EXAMPLE; } getDisplayText() { return 'Example view'; } async onOpen() { // Attach the Svelte component to the ItemViews content element and provide the needed props. this.counter = mount(Counter, { target: this.contentEl, props: { startCount: 5, } }); // Since the component instance is typed, the exported `increment` method is known to TypeScript. this.counter.increment(); } async onClose() { if (this.counter) { // Remove the Counter from the ItemView. unmount(this.counter); } } } See [[Views]] for more on how to incorporate this new view into the User Interface.\n","categories":"","description":"","excerpt":"This guide explains how to configure your plugin to use Svelte, a …","ref":"/plugins/getting-started/use-svelte-in-your-plugin/","tags":"","title":""},{"body":"이 가이드에서는 React나 Vue와 같은 전통적인 프레임워크의 경량 대안인 Svelte를 사용하도록 플러그인을 설정하는 방법을 설명합니다.\nSvelte는 코드를 전처리하고 최적화된 순수 JavaScript를 출력하는 컴파일러를 중심으로 구축되었습니다. 이는 상태 변경을 추적하기 위해 가상 DOM이 필요 없다는 것을 의미하며, 플러그인이 최소한의 추가 오버헤드로 실행될 수 있게 합니다.\nSvelte에 대해 더 배우고 사용법을 알고 싶다면, 튜토리얼과 문서를 참조하세요.\n이 가이드는 [[Build a plugin]]을 완료했다고 가정합니다.\n[!tip] Visual Studio Code Svelte에는 Svelte 컴포넌트에서 구문 강조 및 풍부한 IntelliSense를 활성화하는 공식 Visual Studio Code 확장 프로그램이 있습니다.\n플러그인 설정하기 Svelte로 플러그인을 빌드하려면 종속성을 설치하고 Svelte를 사용하여 작성된 코드를 컴파일하도록 플러그인을 설정해야 합니다. TypeScript의 타입 전용 기능만 사용하려는 경우 svelte-preprocess는 필요하지 않습니다.\n플러그인 종속성에 Svelte를 추가합니다:\nnpm install --save-dev svelte svelte-preprocess esbuild-svelte svelte-check [!info] Svelte는 최소 TypeScript 5.0이 필요합니다. TypeScript 5.0으로 업데이트하려면 터미널에서 다음을 실행하세요.\nnpm install typescript@~5.0.0 tsconfig.json을 확장하여 일반적인 Svelte 문제에 대한 추가 유형 검사를 활성화합니다. svelte-preprocess에는 verbatimModuleSyntax가 필요하고 svelte-check가 올바르게 작동하려면 skipLibCheck가 필요합니다.\n{ \"compilerOptions\": { \"verbatimModuleSyntax\": true, \"skipLibCheck\": true, // ... }, \"include\": [ \"**/*.ts\", \"**/*.svelte\" ] } esbuild.config.mjs에서 파일 상단에 다음 가져오기를 추가합니다:\nimport esbuildSvelte from 'esbuild-svelte'; import { sveltePreprocess } from 'svelte-preprocess'; 플러그인 목록에 Svelte를 추가합니다.\nconst context = await esbuild.context({ plugins: [ esbuildSvelte({ compilerOptions: { css: 'injected' }, preprocess: sveltePreprocess(), }), ], // ... }); package.json에 svelte-check를 실행하는 스크립트를 추가합니다.\n{ // ... \"scripts\": { // ... \"svelte-check\": \"svelte-check --tsconfig tsconfig.json\" } } Svelte 컴포넌트 생성하기 플러그인의 루트 디렉토리에 Counter.svelte라는 새 파일을 만듭니다:\n\u003cscript lang=\"ts\"\u003e interface Props { startCount: number; } let { startCount }: Props = $props(); let count = $state(startCount); export function increment() { count += 1; } \u003c/script\u003e \u003cdiv class=\"number\"\u003e \u003cspan\u003eMy number is {count}!\u003c/span\u003e \u003c/div\u003e \u003cstyle\u003e .number { color: red; } \u003c/style\u003e Svelte 컴포넌트 마운트하기 Svelte 컴포넌트를 사용하려면 기존 [[HTML elements|HTML 요소]]에 마운트해야 합니다. 예를 들어, Obsidian의 사용자 정의 [[ItemView|ItemView]]에 마운트하는 경우:\nimport { ItemView, WorkspaceLeaf } from 'obsidian'; // Counter Svelte 컴포넌트와 `mount`, `unmount` 메소드를 가져옵니다. import Counter from './Counter.svelte'; import { mount, unmount } from 'svelte'; export const VIEW_TYPE_EXAMPLE = 'example-view'; export class ExampleView extends ItemView { // 이 ItemView에 마운트된 Counter 인스턴스를 유지할 변수입니다. counter: ReturnType\u003ctypeof Counter\u003e | undefined; constructor(leaf: WorkspaceLeaf) { super(leaf); } getViewType() { return VIEW_TYPE_EXAMPLE; } getDisplayText() { return 'Example view'; } async onOpen() { // Svelte 컴포넌트를 ItemView의 content 요소에 첨부하고 필요한 props를 제공합니다. this.counter = mount(Counter, { target: this.contentEl, props: { startCount: 5, } }); // 컴포넌트 인스턴스가 타입화되었으므로, 내보낸 `increment` 메소드는 TypeScript에 알려져 있습니다. this.counter.increment(); } async onClose() { if (this.counter) { // ItemView에서 Counter를 제거합니다. unmount(this.counter); } } } 이 새로운 뷰를 사용자 인터페이스에 통합하는 방법에 대한 자세한 내용은 [[Views]]를 참조하세요.\n","categories":"","description":"","excerpt":"이 가이드에서는 React나 Vue와 같은 전통적인 프레임워크의 경량 대안인 Svelte를 사용하도록 플러그인을 설정하는 방법 …","ref":"/ko/plugins/getting-started/use-svelte-in-your-plugin/","tags":"","title":""},{"body":"In Obsidian v1.7.1, we added the “Debug startup time” view. This view indicates how long it takes for the app to launch.\nPlugins play an important role in app load time. To ensure that Obsidian behaves correctly, Obsidian loads all plugins before the user can interact with the app.\nHow do I improve my plugin’s load time? Simplify your plugin onload. Check your plugin View constructor. Avoid the common pitfalls. First, the easy stuff. Make sure that you are using a production build of your plugin. If you are using a bundler like esbuild, rollup, or webpack, you can likely create a “development” build or a “production” build. A production build will usually be smaller, load faster, and remove code that’s only used for testing. When you create a release, ensure that the main.js file is a production build.\nIn your build configuration, you should consider minifying your plugin code. This will make the overall plugin file size smaller and therefore faster for plugin to read from disk and load.\nNext, make sure you aren’t doing anything expensive inside your plugin’s onload function. The onload function should only include code necessary for the plugin to initialize. This includes app registrations, like registering commands, view types, and Markdown post-processors. It should not include anything computationally expensive or data fetching.\nIf your plugin creates any custom views, be mindful of your custom view constructor. When Obsidian opens, it will reopen all the views saved to the user’s workspace. If your view is loaded (and not [[Understanding deferred views|deferred]]), this will directly impact the app load time.\nIf you have code that you want to run at startup, where should it go? For most cases, you will want to wrap your code inside a onLayoutReady callback. These callbacks are deferred and are only called after Obsidian finishes loading.\nPitfalls Listening to vault.on('create') As a part of Obsidian’s vault initialization process, it will call create for every file. If your plugin needs to react to new files getting created, you need to wait for the workspace to be ready first. Your vault event registration should be inside an onLayoutReady callback; this will ensure you don’t start reacting to events until the workspace is fully initialized.\nOption A. Check if the layout is ready class MyPlugin extends Plugin { onload(app: App) { super(app); this.registerEvent(this.app.vault.on('create', this.onCreate, this)); } onCreate() { if (!this.app.workspace.layoutReady) { // Workspace is still loading, do nothing return; } // ... } } Option B. Register the handler once the layout is ready class MyPlugin extends Plugin { onload(app: App) { super(app); this.app.workspace.onLayoutReady(() =\u003e { this.registerEvent(this.app.vault.on('create', this.onCreate, this)); }); } onCreate() { // ... } } For additional help with optimizing your plugin, reach out for [[Home#Join the developer community|help from the developer community]]!\n","categories":"","description":"","excerpt":"In Obsidian v1.7.1, we added the “Debug startup time” view. This view …","ref":"/plugins/guides/optimizing-plugin-load-time/","tags":"","title":""},{"body":"Obsidian v1.7.1에서 “Debug startup time” 뷰를 추가했습니다. 이 뷰는 앱이 시작되는 데 걸리는 시간을 나타냅니다.\n플러그인은 앱 로드 시간에 중요한 역할을 합니다. Obsidian이 올바르게 작동하도록 보장하기 위해, Obsidian은 사용자가 앱과 상호 작용하기 전에 모든 플러그인을 로드합니다.\n플러그인의 로드 시간을 어떻게 개선할 수 있나요? 플러그인 onload를 단순화하세요. 플러그인 뷰 생성자를 확인하세요. 일반적인 함정을 피하세요. 먼저, 쉬운 것부터 시작합시다. 플러그인의 프로덕션 빌드를 사용하고 있는지 확인하세요. esbuild, rollup 또는 webpack과 같은 번들러를 사용하는 경우, “개발” 빌드 또는 “프로덕션” 빌드를 생성할 수 있습니다. 프로덕션 빌드는 일반적으로 더 작고, 더 빨리 로드되며, 테스트에만 사용되는 코드를 제거합니다. 릴리스를 생성할 때 main.js 파일이 프로덕션 빌드인지 확인하세요.\n빌드 구성에서 플러그인 코드를 최소화하는 것을 고려해야 합니다. 이렇게 하면 전체 플러그인 파일 크기가 작아져 플러그인이 디스크에서 읽고 로드하는 속도가 빨라집니다.\n다음으로, 플러그인의 onload 함수 내에서 비용이 많이 드는 작업을 수행하지 않는지 확인하세요. onload 함수는 플러그인 초기화에 필요한 코드만 포함해야 합니다. 여기에는 명령어, 뷰 유형 및 마크다운 후처리기 등록과 같은 앱 등록이 포함됩니다. 계산 비용이 많이 들거나 데이터를 가져오는 작업은 포함되어서는 안 됩니다.\n플러그인이 사용자 정의 뷰를 생성하는 경우, 사용자 정의 뷰 생성자에 유의하세요. Obsidian이 열릴 때, 사용자의 작업 공간에 저장된 모든 뷰를 다시 엽니다. 뷰가 로드되면(그리고 [[Understanding deferred views|지연되지 않으면]]), 이는 앱 로드 시간에 직접적인 영향을 미칩니다.\n시작 시 실행하고 싶은 코드가 있다면 어디에 두어야 하나요? 대부분의 경우, 코드를 onLayoutReady 콜백 안에 래핑하고 싶을 것입니다. 이러한 콜백은 지연되며 Obsidian 로딩이 완료된 후에만 호출됩니다.\n함정 vault.on('create') 수신 Obsidian의 vault 초기화 프로세스의 일부로, 모든 파일에 대해 create를 호출합니다. 플러그인이 새로 생성된 파일에 반응해야 하는 경우, 먼저 작업 공간이 준비될 때까지 기다려야 합니다. vault 이벤트 등록은 onLayoutReady 콜백 내에 있어야 합니다. 이렇게 하면 작업 공간이 완전히 초기화될 때까지 이벤트에 반응하지 않게 됩니다.\n옵션 A. 레이아웃이 준비되었는지 확인 class MyPlugin extends Plugin { onload(app: App) { super(app); this.registerEvent(this.app.vault.on('create', this.onCreate, this)); } onCreate() { if (!this.app.workspace.layoutReady) { // 작업 공간이 아직 로딩 중이므로 아무것도 하지 않음 return; } // ... } } 옵션 B. 레이아웃이 준비되면 핸들러 등록 class MyPlugin extends Plugin { onload(app: App) { super(app); this.app.workspace.onLayoutReady(() =\u003e { this.registerEvent(this.app.vault.on('create', this.onCreate, this)); }); } onCreate() { // ... } } 플러그인 최적화에 대한 추가 도움이 필요하면 [[Home#Join the developer community|개발자 커뮤니티의 도움]]을 요청하세요!\n","categories":"","description":"","excerpt":"Obsidian v1.7.1에서 “Debug startup time” 뷰를 추가했습니다. 이 뷰는 앱이 시작되는 데 걸리는 시 …","ref":"/ko/plugins/guides/optimizing-plugin-load-time/","tags":"","title":""},{"body":"As of Obsidian v1.7.2, When Obsidian loads, all views are created as instances of DeferredView. Once a view is visible on screen (i.e. the tab is selected within its containing tab group), the leaf will rerender and the view will be switched out to the correct View instance.\nThis change might break some assumptions that your plugin is currently making.\nAccessing leaf.view If your plugin is iterating the workspace (using either iterateAllLeaves or getLeavesOfType), it’s now very important that you perform an instanceof check before making any assumptions about leaf.view.\n// Bad workspace.iterateAllLeaves(leaf =\u003e { if (leaf.view.getViewType() === 'my-view') { let view = leaf.view as MyCustomView; ... } }); // Good workspace.iterateAllLeaves(leaf =\u003e { if (leaf.view instanceof MyCustomView) { ... } }); // Bad let leaf = workspace.getLeavesOfType('my-view').first(); if (leaf) { let view = leaf.view as MyCustomView; } ... // Good let leaf = workspace.getLeavesOfType('my-view').first(); if (leaf \u0026\u0026 leaf.view instanceof MyCustomView) { ... } This will avoid your plugin breaking by making a bad assumption about the workspace and causing your plugin to error out.\nAccessing your CustomView anywhere in the workspace A general rule to follow: if your plugin is attempting to communicate with a view, that view should be visible.\nIf your plugin needs to access an instance of CustomView in the workspace, you might notice that the previous code snippets won’t work.\nFor most use cases, the solution is simple:\nlet leaf = workspace.getLeavesOfType('my-view').first(); if (leaf) { await workspace.revealLeaf(leaf); // Ensure the view is visible, `await` it to make sure the view is fully loaded if (leaf.view instanceof MyCustomView) { let view = leaf.view; // You now have your CustomView } } For most cases, this will be the correct way to handle accessing your custom view.\nAccessing your CustomView without reveal (Advanced) There are some cases where you want to access a view without revealing it. For example, if your plugin is applying modifications to an existing view type.\nIn this case, you will need to manually request that the view is loaded.\nlet leaves = workspace.getLeavesOfType('my-view'); for (let leaf of leaves) { if (requireApiVersion('1.7.2')) { await leaf.loadIfDeferred(); // Ensure view is fully loaded } // perform modifications here... } [!Warning] Performance warning Manually calling loadIfDeferred, your plugin is removing this performance optimization from the given views. Use this sparingly.\n","categories":"","description":"","excerpt":"As of Obsidian v1.7.2, When Obsidian loads, all views are created as …","ref":"/plugins/guides/understanding-deferred-views/","tags":"","title":""},{"body":"Obsidian v1.7.2부터 Obsidian이 로드될 때 모든 뷰는 DeferredView의 인스턴스로 생성됩니다. 뷰가 화면에 표시되면(즉, 포함된 탭 그룹 내에서 탭이 선택되면), leaf는 다시 렌더링되고 뷰는 올바른 View 인스턴스로 전환됩니다.\n이 변경으로 인해 플러그인이 현재 만들고 있는 일부 가정이 깨질 수 있습니다.\nleaf.view에 접근하기 플러그인이 작업 공간을 반복하는 경우(iterateAllLeaves 또는 getLeavesOfType 사용), leaf.view에 대한 가정을 하기 전에 instanceof 확인을 수행하는 것이 이제 매우 중요합니다.\n// 나쁜 예 workspace.iterateAllLeaves(leaf =\u003e { if (leaf.view.getViewType() === 'my-view') { let view = leaf.view as MyCustomView; ... } }); // 좋은 예 workspace.iterateAllLeaves(leaf =\u003e { if (leaf.view instanceof MyCustomView) { ... } }); // 나쁜 예 let leaf = workspace.getLeavesOfType('my-view').first(); if (leaf) { let view = leaf.view as MyCustomView; } ... // 좋은 예 let leaf = workspace.getLeavesOfType('my-view').first(); if (leaf \u0026\u0026 leaf.view instanceof MyCustomView) { ... } 이렇게 하면 플러그인이 작업 공간에 대한 잘못된 가정으로 인해 중단되고 오류가 발생하는 것을 방지할 수 있습니다.\n작업 공간 어디에서나 CustomView에 접근하기 따라야 할 일반적인 규칙: 플러그인이 뷰와 통신하려고 시도하는 경우 해당 뷰는 보여야 합니다.\n플러그인이 작업 공간의 CustomView 인스턴스에 접근해야 하는 경우, 이전 코드 조각이 작동하지 않는 것을 알 수 있습니다.\n대부분의 사용 사례에서 해결책은 간단합니다:\nlet leaf = workspace.getLeavesOfType('my-view').first(); if (leaf) { await workspace.revealLeaf(leaf); // 뷰가 보이도록 하고, 뷰가 완전히 로드되도록 `await`합니다. if (leaf.view instanceof MyCustomView) { let view = leaf.view; // 이제 CustomView를 가졌습니다. } } 대부분의 경우, 이것이 사용자 정의 뷰에 접근하는 올바른 방법입니다.\n드러내지 않고 CustomView에 접근하기 (고급) 뷰를 드러내지 않고 접근하고 싶은 경우가 있습니다. 예를 들어, 플러그인이 기존 뷰 유형에 수정을 적용하는 경우입니다.\n이 경우 뷰가 로드되도록 수동으로 요청해야 합니다.\nlet leaves = workspace.getLeavesOfType('my-view'); for (let leaf of leaves) { if (requireApiVersion('1.7.2')) { await leaf.loadIfDeferred(); // 뷰가 완전히 로드되었는지 확인 } // 여기서 수정 수행... } [!Warning] 성능 경고 loadIfDeferred를 수동으로 호출하면, 플러그인은 주어진 뷰에서 이 성능 최적화를 제거합니다. 이것을 아껴서 사용하세요.\n","categories":"","description":"","excerpt":"Obsidian v1.7.2부터 Obsidian이 로드될 때 모든 뷰는 DeferredView의 인스턴스로 생성됩니다. 뷰가  …","ref":"/ko/plugins/guides/understanding-deferred-views/","tags":"","title":""},{"body":"Before you [[Submit your plugin|submit your plugin]], you may want to let users try it out first. While Obsidian doesn’t officially support beta releases, we recommend that you use the BRAT plugin to distribute your plugin to beta testers before it’s been published.\nFor more information, refer to the BRAT documentation.\n","categories":"","description":"","excerpt":"Before you [[Submit your plugin|submit your plugin]], you may want to …","ref":"/plugins/releasing/beta-testing-plugins/","tags":"","title":""},{"body":"[[Submit your plugin|플러그인을 제출하기]] 전에 사용자들이 먼저 사용해 보도록 하고 싶을 수 있습니다. Obsidian은 공식적으로 베타 릴리스를 지원하지 않지만, 플러그인이 게시되기 전에 베타 테스터에게 배포하기 위해 BRAT 플러그인을 사용하는 것을 권장합니다.\n자세한 내용은 BRAT 문서를 참조하세요.\n","categories":"","description":"","excerpt":"[[Submit your plugin|플러그인을 제출하기]] 전에 사용자들이 먼저 사용해 보도록 하고 싶을 수 있습니다. …","ref":"/ko/plugins/releasing/beta-testing-plugins/","tags":"","title":""},{"body":"This page lists common review comments plugin authors get when submitting their plugin.\nWhile the guidelines on this page are recommendations, depending on their severity, we may still require you to address any violations.\n[!important] Policies for plugin developers Make sure that you’ve read our [[Developer policies]] as well as the [[Submission requirements for plugins]].\nGeneral Avoid using global app instance Avoid using the global app object, app (or window.app). Instead, use the reference provided by your plugin instance, this.app.\nThe global app object is intended for debugging purposes and might be removed in the future.\nAvoid unnecessary logging to console Please avoid unnecessary logging. In it’s default configuration, the developer console should only show error messages, debug messages should not be shown.\nConsider organizing your code base using folders If your plugin uses more than one .ts file, consider organizing them into folders to make it easier to review and maintain.\nRename placeholder class names The sample plugin contains placeholder names for common classes, such as MyPlugin, MyPluginSettings, and SampleSettingTab. Rename these to reflect the name of your plugin.\nMobile ![[Mobile development#Node and Electron APIs]]\n![[Mobile development#Lookbehind in regular expressions]]\nUI text This section lists guidelines for formatting text in the user interface, such as settings, commands, and buttons.\nThe example below from Settings → Appearance demonstrates the guidelines for text in the user interface.\n![[settings-headings.png]]\n[[#Only use headings under settings if you have more than one section.|General settings are at the top and don’t have a heading]]. [[#Avoid “settings” in settings headings|Section headings don’t have “settings” in the heading text]]. [[#Use Sentence case in UI]]. For more information on writing and formatting text for Obsidian, refer to our Style guide.\nOnly use headings under settings if you have more than one section. Avoid adding a top-level heading in the settings tab, such as “General”, “Settings”, or the name of your plugin.\nIf you have more than one section under settings, and one contains general settings, keep them at the top without adding a heading.\nFor example, look at the settings under Settings → Appearance.\nAvoid “settings” in settings headings In the settings tab, you can add headings to organize settings. Avoid including the word “settings” to these headings. Since everything in under the settings tab is settings, repeating it for every heading becomes redundant.\nPrefer “Advanced” over “Advanced settings”. Prefer “Templates” over “Settings for templates”. Use sentence case in UI Any text in UI elements should be using Sentence case instead of Title Case, where only the first word in a sentence, and proper nouns, should be capitalized.\nPrefer “Template folder location” over “Template Folder Location”. Prefer “Create new note” over “Create New Note”. Use setHeading instead of a \u003ch1\u003e, \u003ch2\u003e Using the heading elements from HTML will result in inconsistent styling between different plugins. Instead you should prefer the following:\nnew Setting(containerEl).setName('your heading title').setHeading(); Security Avoid innerHTML, outerHTML and insertAdjacentHTML Building DOM elements from user-defined input, using innerHTML, outerHTML and insertAdjacentHTML can pose a security risk.\nThe following example builds a DOM element using a string that contains user input, ${name}. name can contain other DOM elements, such as \u003cscript\u003ealert()\u003c/script\u003e, and can allow a potential attacker to execute arbitrary code on the user’s computer.\nfunction showName(name: string) { let containerElement = document.querySelector('.my-container'); // DON'T DO THIS containerElement.innerHTML = `\u003cdiv class=\"my-class\"\u003e\u003cb\u003eYour name is: \u003c/b\u003e${name}\u003c/div\u003e`; } Instead, use the DOM API or the Obsidian helper functions, such as createEl(), createDiv() and createSpan() to build the DOM element programmatically. For more information, refer to [[HTML elements]].\nTo cleanup a HTML elements contents use el.empty();\nResource management Clean up resources when plugin unloads Any resources created by the plugin, such as event listeners, must be destroyed or released when the plugin unloads.\nWhen possible, use methods like [[registerEvent|registerEvent()]] or [[addCommand|addCommand()]] to automatically clean up resources when the plugin unloads.\nexport default class MyPlugin extends Plugin { onload() { this.registerEvent(this.app.vault.on('create', this.onCreate)); } onCreate: (file: TAbstractFile) =\u003e { // ... } } [!note] You don’t need to clean up resources that are guaranteed to be removed when your plugin unloads. For example, if you register a mouseenter listener on a DOM element, the event listener will be garbage-collected when the element goes out of scope.\nDon’t detach leaves in onunload When the user updates your plugin, any open leaves will be reinitialized at their original position, regardless of where the user had moved them.\nCommands Avoid setting a default hotkey for commands Setting a default hotkey may lead to conflicts between plugins and may override hotkeys that the user has already configured.\nIt’s also difficult to choose a default hotkey that is available on all operating systems.\nUse the appropriate callback type for commands When you add a command in your plugin, use the appropriate callback type.\nUse callback if the command runs unconditionally. Use checkCallback if the command only runs under certain conditions. If the command requires an open and active Markdown editor, use editorCallback, or the corresponding editorCheckCallback.\nWorkspace Avoid accessing workspace.activeLeaf directly If you want to access the active view, use [[getActiveViewOfType|getActiveViewOfType()]] instead:\nconst view = this.app.workspace.getActiveViewOfType(MarkdownView); // getActiveViewOfType will return null if the active view is null, or if it's not a MarkdownView. if (view) { // ... } If you want to access the editor in the active note, use activeEditor instead:\nconst editor = this.app.workspace.activeEditor?.editor; if (editor) { // ... } Avoid managing references to custom views Managing references to custom view can cause memory leaks or unintended consequences.\nDon’t do this:\nthis.registerViewType(MY_VIEW_TYPE, () =\u003e this.view = new MyCustomView()); Do this instead:\nthis.registerViewType(MY_VIEW_TYPE, () =\u003e new MyCustomView()); To access the view from your plugin, use Workspace.getActiveLeavesOfType():\nfor (let leaf of app.workspace.getActiveLeavesOfType(MY_VIEW_TYPE)) { let view = leaf.view; if (view instanceof MyCustomView) { // ... } } Vault Prefer the Editor API instead of Vault.modify to the active file If you want to edit an active note, use the [[Editor]] interface instead of [[Vault/modify|Vault.modify()]].\nEditor maintains information about the active note, such as cursor position, selection, and folded content. When you use [[Vault/modify|Vault.modify()]] to edit the note, all that information is lost, which leads to a poor experience for the user.\nEditor is also more efficient when making small changes to parts of the note.\nPrefer Vault.process instead of Vault.modify to modify a file in the background If you want to edit a note that is not currently opened, use the [[Reference/TypeScript API/Vault/process|Vault.process]] function instead of [[modify|Vault.modify]].\nThe process function modifies the file atomically, which means that your plugin won’t run into conflicts with other plugins modifying the same file.\nPrefer FileManager.processFrontMatter to modify frontmatter of a note Instead of extracting the frontmatter of a note, parsing and modifying the YAML manually you should use the [[processFrontMatter|FileManager.processFrontMatter]] function.\nprocessFrontMatter runs atomically, so modifying the file will not conflict with other plugins editing the same file. It will also ensure a consistent layout of the YAML produced.\nPrefer the Vault API over the Adapter API Obsidian exposes two APIs for file operations: the Vault API (app.vault) and the Adapter API (app.vault.adapter).\nWhile the file operations in the Adapter API are often more familiar to many developers, the Vault API has two main advantages over the adapter.\nPerformance: The Vault API has a caching layer that can speed up file reads when the file is already known to Obsidian. Safety: The Vault API performs file operations serially to avoid any race conditions, for example when reading a file that is being written to at the same time. Avoid iterating all files to find a file by its path This is inefficient, especially for large vaults. Use [[getFileByPath|Vault.getFileByPath]], [[getFolderByPath|Vault.getFolderByPath]] or [[getAbstractFileByPath|Vault.getAbstractFileByPath]] instead.\nDon’t do this:\nthis.app.vault.getFiles().find(file =\u003e file.path === filePath); Do this instead:\nconst filePath = 'folder/file.md'; // if you want to get a file const file = this.app.vault.getFileByPath(filePath); const folderPath = 'folder'; // or if you want to get a folder const folder = this.app.vault.getFolderByPath(folderPath); If you aren’t sure if the path provided is for a folder or a file, use:\nconst abstractFile = this.app.vault.getAbstractFileByPath(filePath); if (file instanceof TFile) { // it's a file } if (file instanceof TFolder) { // it's a folder } Use normalizePath() to clean up user-defined paths Use [[normalizePath|normalizePath()]] whenever you accept user-defined paths to files or folders in the vault, or when you construct your own paths in the plugin code.\nnormalizePath() takes a path and scrubs it to be safe for the file system and for cross-platform use. This function:\nCleans up the use of forward and backward slashes, such as replacing 1 or more of \\ or / with a single /. Removes leading and trailing forward and backward slashes. Replaces any non-breaking spaces, \\u00A0, with a regular space. Runs the path through String.prototype.normalize. import { normalizePath } from 'obsidian'; const pathToPlugin = normalizePath('//my-folder\\file'); // pathToPlugin contains \"my-folder/file\" not \"//my-folder\\\" Editor Change or reconfigure editor extensions If you want to change or reconfigure an [[Editor extensions|editor extension]] after you’ve registered using [[registerEditorExtension|registerEditorExtension()]], use [[updateOptions|updateOptions()]] to update all editors.\nclass MyPlugin extends Plugin { private editorExtension: Extension[] = []; onload() { //... this.registerEditorExtension(this.editorExtension); } updateEditorExtension() { // Empty the array while keeping the same reference // (Don't create a new array here) this.editorExtension.length = 0; // Create new editor extension let myNewExtension = this.createEditorExtension(); // Add it to the array this.editorExtension.push(myNewExtension); // Flush the changes to all editors this.app.workspace.updateOptions(); } } Styling No hardcoded styling Don’t do this:\nconst el = containerEl.createDiv(); el.style.color = 'white'; el.style.backgroundColor = 'red'; To make it easy for users to modify the styling of your plugin you should use CSS classes, as hardcoding the styling in the plugin code makes it impossible to modify with themes and snippets.\nDo this instead:\nconst el = containerEl.createDiv({cls: 'warning-container'}); In the plugins CSS add the following:\n.warning-container { color: var(--text-normal); background-color: var(--background-modifier-error); } To make the styling of your plugin consistent with Obsidian and other plugins you should use the [[CSS variables]] provided by Obsidian. If there is no variable available that fits in your case, you can create your own.\nTypeScript Prefer const and let over var For more information, refer to 4 Reasons Why var is Considered Obsolete in Modern JavaScript.\nPrefer async/await over Promise Recent versions of JavaScript and TypeScript support the async and await keywords to run code asynchronously, which allow for more readable code than using Promises.\nDon’t do this:\nfunction test(): Promise\u003cstring | null\u003e { return requestUrl('https://example.com') .then(res =\u003e res.text .catch(e =\u003e { console.log(e); return null; }); } Do this instead:\nasync function AsyncTest(): Promise\u003cstring | null\u003e { try { let res = await requestUrl('https://example.com'); let text = await r.text; return text; } catch (e) { console.log(e); return null; } } ","categories":"","description":"","excerpt":"This page lists common review comments plugin authors get when …","ref":"/plugins/releasing/plugin-guidelines/","tags":"","title":""},{"body":"이 페이지는 플러그인 작성자가 플러그인을 제출할 때 흔히 받는 리뷰 의견을 나열합니다.\n이 페이지의 가이드라인은 권장 사항이지만, 심각성에 따라 위반 사항을 해결하도록 요구할 수 있습니다.\n[!important] 플러그인 개발자를 위한 정책 [[Developer policies]]와 [[Submission requirements for plugins]]를 반드시 읽어보세요.\n일반 전역 앱 인스턴스 사용 피하기 전역 앱 객체인 app (또는 window.app) 사용을 피하세요. 대신 플러그인 인스턴스에서 제공하는 참조인 this.app을 사용하세요.\n전역 앱 객체는 디버깅 목적으로 만들어졌으며 향후 제거될 수 있습니다.\n불필요한 콘솔 로깅 피하기 불필요한 로깅을 피해주세요. 기본 설정에서는 개발자 콘솔에 오류 메시지만 표시되어야 하며, 디버그 메시지는 표시되지 않아야 합니다.\n폴더를 사용하여 코드 베이스 정리 고려하기 플러그인이 하나 이상의 .ts 파일을 사용하는 경우, 리뷰와 유지보수를 용이하게 하기 위해 폴더로 정리하는 것을 고려해보세요.\n플레이스홀더 클래스 이름 바꾸기 샘플 플러그인에는 MyPlugin, MyPluginSettings, SampleSettingTab과 같은 일반적인 클래스에 대한 플레이스홀더 이름이 포함되어 있습니다. 플러그인 이름을 반영하도록 이 이름들을 변경하세요.\n모바일 ![[Mobile development#Node and Electron APIs]]\n![[Mobile development#Lookbehind in regular expressions]]\nUI 텍스트 이 섹션은 설정, 명령어, 버튼 등 사용자 인터페이스의 텍스트 서식 지정에 대한 가이드라인을 나열합니다.\n아래 Settings → Appearance의 예시는 사용자 인터페이스 텍스트에 대한 가이드라인을 보여줍니다.\n![[settings-headings.png]]\n[[#Only use headings under settings if you have more than one section.|일반 설정은 상단에 있으며 제목이 없습니다]]. [[#Avoid “settings” in settings headings|섹션 제목에는 “settings\"라는 단어가 포함되지 않습니다]]. [[#Use Sentence case in UI]]. Obsidian용 텍스트 작성 및 서식 지정에 대한 자세한 내용은 스타일 가이드를 참조하세요.\n설정 아래에 섹션이 두 개 이상인 경우에만 제목 사용하기 설정 탭에 “General”, “Settings” 또는 플러그인 이름과 같은 최상위 제목을 추가하지 마세요.\n설정 아래에 섹션이 두 개 이상 있고 그중 하나에 일반 설정이 포함된 경우, 제목을 추가하지 않고 상단에 유지하세요.\n예를 들어, Settings → Appearance 아래의 설정을 보세요.\n설정 제목에 “settings” 피하기 설정 탭에서 설정을 정리하기 위해 제목을 추가할 수 있습니다. 이 제목에 “settings\"라는 단어를 포함하지 마세요. 설정 탭 아래의 모든 것이 설정이므로 모든 제목에 반복하는 것은 중복입니다.\n“Advanced settings” 대신 “Advanced\"를 선호합니다. “Settings for templates” 대신 “Templates\"를 선호합니다. UI에서 문장 케이스 사용하기 UI 요소의 모든 텍스트는 Title Case 대신 Sentence case를 사용해야 합니다. 문장 케이스에서는 문장의 첫 단어와 고유 명사만 대문자로 표기합니다.\n“Template Folder Location” 대신 “Template folder location\"을 선호합니다. “Create New Note” 대신 “Create new note\"를 선호합니다. \u003ch1\u003e, \u003ch2\u003e 대신 setHeading 사용하기 HTML의 제목 요소를 사용하면 다른 플러그인 간에 스타일이 일관되지 않을 수 있습니다. 대신 다음을 사용하는 것을 선호해야 합니다:\nnew Setting(containerEl).setName('your heading title').setHeading(); 보안 innerHTML, outerHTML, insertAdjacentHTML 피하기 사용자 정의 입력을 사용하여 innerHTML, outerHTML, insertAdjacentHTML로 DOM 요소를 만드는 것은 보안 위험을 초래할 수 있습니다.\n다음 예제는 사용자 입력 ${name}을 포함하는 문자열을 사용하여 DOM 요소를 만듭니다. name은 \u003cscript\u003ealert()\u003c/script\u003e와 같은 다른 DOM 요소를 포함할 수 있으며, 잠재적인 공격자가 사용자의 컴퓨터에서 임의의 코드를 실행하도록 허용할 수 있습니다.\nfunction showName(name: string) { let containerElement = document.querySelector('.my-container'); // 이렇게 하지 마세요 containerElement.innerHTML = `\u003cdiv class=\"my-class\"\u003e\u003cb\u003eYour name is: \u003c/b\u003e${name}\u003c/div\u003e`; } 대신, createEl(), createDiv(), createSpan()과 같은 DOM API 또는 Obsidian 헬퍼 함수를 사용하여 프로그래밍 방식으로 DOM 요소를 만드세요. 자세한 내용은 [[HTML elements]]를 참조하세요.\nHTML 요소의 내용을 정리하려면 el.empty();를 사용하세요.\n리소스 관리 플러그인이 언로드될 때 리소스 정리하기 이벤트 리스너와 같이 플러그인에 의해 생성된 모든 리소스는 플러그인이 언로드될 때 파괴되거나 해제되어야 합니다.\n가능하면 [[registerEvent|registerEvent()]] 또는 [[addCommand|addCommand()]]와 같은 메소드를 사용하여 플러그인이 언로드될 때 리소스를 자동으로 정리하세요.\nexport default class MyPlugin extends Plugin { onload() { this.registerEvent(this.app.vault.on('create', this.onCreate)); } onCreate: (file: TAbstractFile) =\u003e { // ... } } [!note] 플러그인이 언로드될 때 제거가 보장되는 리소스는 정리할 필요가 없습니다. 예를 들어, DOM 요소에 mouseenter 리스너를 등록하면 해당 요소가 범위를 벗어날 때 이벤트 리스너가 가비지 컬렉션됩니다.\nonunload에서 리프(leaf) 분리하지 않기 사용자가 플러그인을 업데이트할 때, 열려 있는 모든 리프는 사용자가 어디로 옮겼는지에 관계없이 원래 위치에서 다시 초기화됩니다.\n명령어 명령어에 기본 단축키 설정 피하기 기본 단축키를 설정하면 플러그인 간에 충돌이 발생할 수 있으며 사용자가 이미 구성한 단축키를 덮어쓸 수 있습니다.\n또한 모든 운영 체제에서 사용 가능한 기본 단축키를 선택하기 어렵습니다.\n명령어에 적절한 콜백 유형 사용하기 플러그인에 명령어를 추가할 때 적절한 콜백 유형을 사용하세요.\n명령어가 무조건 실행되는 경우 callback을 사용합니다. 명령어가 특정 조건에서만 실행되는 경우 checkCallback을 사용합니다. 명령어에 열려 있고 활성화된 마크다운 에디터가 필요한 경우, editorCallback 또는 해당 editorCheckCallback을 사용하세요.\n작업 공간 workspace.activeLeaf에 직접 접근 피하기 활성 뷰에 접근하려면 대신 [[getActiveViewOfType|getActiveViewOfType()]]를 사용하세요:\nconst view = this.app.workspace.getActiveViewOfType(MarkdownView); // getActiveViewOfType은 활성 뷰가 null이거나 MarkdownView가 아닌 경우 null을 반환합니다. if (view) { // ... } 활성 노트의 에디터에 접근하려면 대신 activeEditor를 사용하세요:\nconst editor = this.app.workspace.activeEditor?.editor; if (editor) { // ... } 사용자 정의 뷰에 대한 참조 관리 피하기 사용자 정의 뷰에 대한 참조를 관리하면 메모리 누수나 의도하지 않은 결과를 초래할 수 있습니다.\n이렇게 하지 마세요:\nthis.registerViewType(MY_VIEW_TYPE, () =\u003e this.view = new MyCustomView()); 대신 이렇게 하세요:\nthis.registerViewType(MY_VIEW_TYPE, () =\u003e new MyCustomView()); 플러그인에서 뷰에 접근하려면 Workspace.getActiveLeavesOfType()를 사용하세요:\nfor (let leaf of app.workspace.getActiveLeavesOfType(MY_VIEW_TYPE)) { let view = leaf.view; if (view instanceof MyCustomView) { // ... } } 저장소(Vault) 활성 파일에 대해 Vault.modify 대신 Editor API 선호하기 활성 노트를 편집하려면 [[Vault/modify|Vault.modify()]] 대신 [[Editor]] 인터페이스를 사용하세요.\nEditor는 커서 위치, 선택 영역, 접힌 내용과 같은 활성 노트에 대한 정보를 유지합니다. [[Vault/modify|Vault.modify()]]를 사용하여 노트를 편집하면 모든 정보가 손실되어 사용자 경험이 저하됩니다.\nEditor는 노트의 일부를 작게 변경할 때 더 효율적입니다.\n백그라운드에서 파일을 수정하려면 Vault.modify 대신 Vault.process 선호하기 현재 열려 있지 않은 노트를 편집하려면 [[modify|Vault.modify]] 대신 [[Reference/TypeScript API/Vault/process|Vault.process]] 함수를 사용하세요.\nprocess 함수는 파일을 원자적으로 수정하므로, 플러그인이 동일한 파일을 수정하는 다른 플러그인과 충돌하지 않습니다.\n노트의 프론트매터를 수정하려면 FileManager.processFrontMatter 선호하기 노트의 프론트매터를 추출하고 YAML을 수동으로 파싱하고 수정하는 대신 [[processFrontMatter|FileManager.processFrontMatter]] 함수를 사용해야 합니다.\nprocessFrontMatter는 원자적으로 실행되므로 파일을 수정해도 동일한 파일을 편집하는 다른 플러그인과 충돌하지 않습니다. 또한 생성된 YAML의 일관된 레이아웃을 보장합니다.\nAdapter API 대신 Vault API 선호하기 Obsidian은 파일 작업을 위한 두 가지 API를 노출합니다: Vault API (app.vault)와 Adapter API (app.vault.adapter).\nAdapter API의 파일 작업이 많은 개발자에게 더 익숙하지만, Vault API는 어댑터에 비해 두 가지 주요 이점이 있습니다.\n성능: Vault API에는 파일이 이미 Obsidian에 알려진 경우 파일 읽기 속도를 높일 수 있는 캐싱 계층이 있습니다. 안전성: Vault API는 동시에 쓰기 중인 파일을 읽는 것과 같은 경쟁 조건을 피하기 위해 파일 작업을 직렬로 수행합니다. 경로로 파일을 찾기 위해 모든 파일 반복 피하기 이것은 특히 큰 저장소에서 비효율적입니다. 대신 [[getFileByPath|Vault.getFileByPath]], [[getFolderByPath|Vault.getFolderByPath]] 또는 [[getAbstractFileByPath|Vault.getAbstractFileByPath]]를 사용하세요.\n이렇게 하지 마세요:\nthis.app.vault.getFiles().find(file =\u003e file.path === filePath); 대신 이렇게 하세요:\nconst filePath = 'folder/file.md'; // 파일을 가져오려면 const file = this.app.vault.getFileByPath(filePath); const folderPath = 'folder'; // 또는 폴더를 가져오려면 const folder = this.app.vault.getFolderByPath(folderPath); 제공된 경로가 폴더용인지 파일용인지 확실하지 않은 경우 다음을 사용하세요:\nconst abstractFile = this.app.vault.getAbstractFileByPath(filePath); if (file instanceof TFile) { // 파일입니다 } if (file instanceof TFolder) { // 폴더입니다 } 사용자 정의 경로를 정리하기 위해 normalizePath() 사용하기 저장소의 파일이나 폴더에 대한 사용자 정의 경로를 받거나 플러그인 코드에서 자체 경로를 구성할 때마다 [[normalizePath|normalizePath()]]를 사용하세요.\nnormalizePath()는 경로를 받아 파일 시스템 및 크로스 플랫폼 사용에 안전하도록 정리합니다. 이 함수는 다음을 수행합니다:\n\\ 또는 /를 하나 이상의 \\ 또는 /를 단일 /로 바꾸는 등 순방향 및 역방향 슬래시 사용을 정리합니다. 선행 및 후행 순방향 및 역방향 슬래시를 제거합니다. 줄 바꿈 없는 공백 \\u00A0을 일반 공백으로 바꿉니다. 경로를 String.prototype.normalize를 통해 실행합니다. import { normalizePath } from 'obsidian'; const pathToPlugin = normalizePath('//my-folder\\file'); // pathToPlugin은 \"//my-folder\\\"가 아닌 \"my-folder/file\"을 포함합니다 에디터 에디터 확장 변경 또는 재구성하기 [[registerEditorExtension|registerEditorExtension()]]을 사용하여 [[Editor extensions|에디터 확장]]을 등록한 후 변경하거나 재구성하려면 [[updateOptions|updateOptions()]]를 사용하여 모든 에디터를 업데이트하세요.\nclass MyPlugin extends Plugin { private editorExtension: Extension[] = []; onload() { //... this.registerEditorExtension(this.editorExtension); } updateEditorExtension() { // 동일한 참조를 유지하면서 배열 비우기 // (여기서 새 배열을 만들지 마세요) this.editorExtension.length = 0; // 새 에디터 확장 만들기 let myNewExtension = this.createEditorExtension(); // 배열에 추가하기 this.editorExtension.push(myNewExtension); // 모든 에디터에 변경 사항 적용하기 this.app.workspace.updateOptions(); } } 스타일링 하드코딩된 스타일링 금지 이렇게 하지 마세요:\nconst el = containerEl.createDiv(); el.style.color = 'white'; el.style.backgroundColor = 'red'; 사용자가 플러그인의 스타일링을 쉽게 수정할 수 있도록 하려면 CSS 클래스를 사용해야 합니다. 플러그인 코드에 스타일링을 하드코딩하면 테마와 스니펫으로 수정하는 것이 불가능해집니다.\n대신 이렇게 하세요:\nconst el = containerEl.createDiv({cls: 'warning-container'}); 플러그인 CSS에 다음을 추가하세요:\n.warning-container { color: var(--text-normal); background-color: var(--background-modifier-error); } 플러그인의 스타일링을 Obsidian 및 다른 플러그인과 일관되게 만들려면 Obsidian에서 제공하는 [[CSS variables]]를 사용해야 합니다. 사용 사례에 맞는 변수가 없는 경우 직접 만들 수 있습니다.\nTypeScript var 대신 const와 let 선호하기 자세한 내용은 현대 JavaScript에서 var가 구식으로 간주되는 4가지 이유를 참조하세요.\nPromise 대신 async/await 선호하기 최신 버전의 JavaScript와 TypeScript는 비동기 코드를 실행하기 위해 async 및 await 키워드를 지원하여 Promise를 사용하는 것보다 더 읽기 쉬운 코드를 작성할 수 있습니다.\n이렇게 하지 마세요:\nfunction test(): Promise\u003cstring | null\u003e { return requestUrl('https://example.com') .then(res =\u003e res.text .catch(e =\u003e { console.log(e); return null; }); } 대신 이렇게 하세요:\nasync function AsyncTest(): Promise\u003cstring | null\u003e { try { let res = await requestUrl('https://example.com'); let text = await r.text; return text; } catch (e) { console.log(e); return null; } } ","categories":"","description":"","excerpt":"이 페이지는 플러그인 작성자가 플러그인을 제출할 때 흔히 받는 리뷰 의견을 나열합니다.\n이 페이지의 가이드라인은 권장 사항이지 …","ref":"/ko/plugins/releasing/plugin-guidelines/","tags":"","title":""},{"body":"Manually releasing your plugin can be time-consuming and error-prone. In this guide, you’ll configure your plugin to use GitHub Actions to automatically create a release when you create a new tag.\nIn the root directory of your plugin, create a file called release.yml under .github/workflows with the following content:\nname: Release Obsidian plugin on: push: tags: - \"*\" jobs: build: runs-on: ubuntu-latest permissions: contents: write steps: - uses: actions/checkout@v3 - name: Use Node.js uses: actions/setup-node@v3 with: node-version: \"18.x\" - name: Build plugin run: | npm install npm run build - name: Create release env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} run: | tag=\"${GITHUB_REF#refs/tags/}\" gh release create \"$tag\" \\ --title=\"$tag\" \\ --draft \\ main.js manifest.json styles.css In your terminal, commit the workflow.\ngit add .github/workflows/release.yml git commit -m \"Add release workflow\" git push origin main Browse to your repository on GitHub and select the Settings tab. Expand the Actions menu in the left sidebar, navigate to the General menu, scroll to the Workflow permissions section, select the Read and write permissions option, and save.\nCreate a tag that matches the version in the manifest.json file.\ngit tag -a 1.0.1 -m \"1.0.1\" git push origin 1.0.1 -a creates an annotated tag. -m specifies the name of your release. For Obsidian plugins, this must be the same as the version. Browse to your repository on GitHub and select the Actions tab. Your workflow might still be running, or it might have finished already.\nWhen the workflow finishes, go back to the main page for your repository and select Releases in the sidebar on the right side. The workflow has created a draft GitHub release and uploaded the required assets as binary attachments.\nSelect Edit (pencil icon) on the right side of the release name.\nAdd release notes to let users know what happened in this release, and then select Publish release.\nYou’ve successfully set up your plugin to automatically create a GitHub release whenever you create a new tag.\nIf this is the first release for this plugin, you’re now ready to [[Submit your plugin]]. If this is an update to an already published plugin, your users can now update to the latest version. ","categories":"","description":"","excerpt":"Manually releasing your plugin can be time-consuming and error-prone. …","ref":"/plugins/releasing/release-your-plugin-with-github-actions/","tags":"","title":""},{"body":"플러그인을 수동으로 릴리스하는 것은 시간이 많이 걸리고 오류가 발생하기 쉽습니다. 이 가이드에서는 GitHub Actions를 사용하여 새 태그를 생성할 때 자동으로 릴리스를 생성하도록 플러그인을 설정합니다.\n플러그인의 루트 디렉토리에서 .github/workflows 아래에 release.yml이라는 파일을 만들고 다음 내용을 추가합니다:\nname: Release Obsidian plugin on: push: tags: - \"*\" jobs: build: runs-on: ubuntu-latest permissions: contents: write steps: - uses: actions/checkout@v3 - name: Use Node.js uses: actions/setup-node@v3 with: node-version: \"18.x\" - name: Build plugin run: | npm install npm run build - name: Create release env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} run: | tag=\"${GITHUB_REF#refs/tags/}\" gh release create \"$tag\" \\ --title=\"$tag\" \\ --draft \\ main.js manifest.json styles.css 터미널에서 워크플로우를 커밋합니다.\ngit add .github/workflows/release.yml git commit -m \"Add release workflow\" git push origin main GitHub에서 리포지토리로 이동하여 Settings 탭을 선택합니다. 왼쪽 사이드바에서 Actions 메뉴를 확장하고 General 메뉴로 이동한 다음 Workflow permissions 섹션으로 스크롤하여 Read and write permissions 옵션을 선택하고 저장합니다.\nmanifest.json 파일의 버전과 일치하는 태그를 생성합니다.\ngit tag -a 1.0.1 -m \"1.0.1\" git push origin 1.0.1 -a는 주석 태그(annotated tag)를 생성합니다. -m은 릴리스 이름을 지정합니다. Obsidian 플러그인의 경우 버전과 동일해야 합니다. GitHub에서 리포지토리로 이동하여 Actions 탭을 선택합니다. 워크플로우가 아직 실행 중이거나 이미 완료되었을 수 있습니다.\n워크플로우가 완료되면 리포지토리의 기본 페이지로 돌아가 오른쪽 사이드바에서 Releases를 선택합니다. 워크플로우는 초안 GitHub 릴리스를 생성하고 필요한 자산을 바이너리 첨부 파일로 업로드했습니다.\n릴리스 이름 오른쪽에 있는 Edit(연필 아이콘)를 선택합니다.\n이 릴리스에서 변경된 내용을 사용자에게 알리기 위해 릴리스 노트를 추가한 다음 Publish release를 선택합니다.\n이제 새 태그를 생성할 때마다 자동으로 GitHub 릴리스를 생성하도록 플러그인을 성공적으로 설정했습니다.\n이 플러그인의 첫 번째 릴리스인 경우, 이제 [[Submit your plugin|플러그인을 제출]]할 준비가 되었습니다. 이미 게시된 플러그인의 업데이트인 경우, 사용자는 이제 최신 버전으로 업데이트할 수 있습니다. ","categories":"","description":"","excerpt":"플러그인을 수동으로 릴리스하는 것은 시간이 많이 걸리고 오류가 발생하기 쉽습니다. 이 가이드에서는 GitHub Actions …","ref":"/ko/plugins/releasing/release-your-plugin-with-github-actions/","tags":"","title":""},{"body":"This page lists extends the [[Developer policies]] with plugin-specific requirements that all plugins must follow to be published.\nOnly use fundingUrl to link to services for financial support Use [[Manifest#fundingUrl|fundingUrl]] if you accept financial support for your plugin, using services like Buy Me A Coffee or GitHub Sponsors.\nIf you don’t accept donations, remove fundingUrl from your manifest.\nSet an appropriate minAppVersion The minAppVersion in the [[Reference/Manifest|Manifest]] should be set to the minimum required version of the Obsidian app that your plugin is compatible with. If you don’t know what an appropriate version number is, use the latest stable build number.\nKeep plugin descriptions short and simple Good plugin descriptions help users understand your plugin quickly and succinctly. Good descriptions often start with an action statement such as:\n“Translate selected text into…” “Generate notes automatically from…” “Import notes from…” “Sync highlights and annotations from…” “Open links in…” Avoid starting your description with “This is a plugin”, because it’ll be obvious to users in the context of the Community Plugins directory.\nYour description should:\nFollow the Obsidian style guide. Have 250 characters maximum. End with a period .. Avoid using emoji or special characters. Use correct capitalization for acronyms, proper nouns and trademarks such as “Obsidian”, “Markdown”, “PDF”. If you are not sure how to capitalize a term, refer to its website or Wikipedia description. Node.js and Electron APIs are only allowed on desktop The Node.js and Electron APIs are only available in the desktop version of Obsidian. For example, Node.js packages like fs, crypto, and os, are only available on desktop.\nIf your plugin uses any of these APIs, you must set isDesktopOnly to true in the manifest.json.\n[!tip] Many Node.js features have Web API alternatives:\nSubtleCrypto instead of crypto. navigator.clipboard.readText() and navigator.clipboard.writeText() to access clipboard contents. Don’t include the plugin ID in the command ID Obsidian automatically prefixes command IDs with your plugin ID. You don’t need to include the plugin ID yourself.\nRemove all the sample code The sample plugin includes examples how to do many of the most common things a plugin requires. It’s only there to get you started, sample code should be removed from your plugin before submission.\n","categories":"","description":"","excerpt":"This page lists extends the [[Developer policies]] with …","ref":"/plugins/releasing/submission-requirements-for-plugins/","tags":"","title":""},{"body":"이 페이지는 게시되기 위해 모든 플러그인이 따라야 하는 플러그인별 요구 사항으로 [[Developer policies]]를 확장합니다.\n재정적 지원 서비스 링크에만 fundingUrl 사용하기 Buy Me A Coffee나 GitHub Sponsors와 같은 서비스를 사용하여 플러그인에 대한 재정적 지원을 받는 경우 [[Manifest#fundingUrl|fundingUrl]]을 사용하세요.\n기부를 받지 않는 경우, 매니페스트에서 fundingUrl을 제거하세요.\n적절한 minAppVersion 설정하기 [[Reference/Manifest|매니페스트]]의 minAppVersion은 플러그인이 호환되는 Obsidian 앱의 최소 필수 버전으로 설정해야 합니다. 적절한 버전 번호를 모르는 경우, 최신 안정 빌드 번호를 사용하세요.\n플러그인 설명은 짧고 간단하게 유지하기 좋은 플러그인 설명은 사용자가 플러그인을 빠르고 간결하게 이해하는 데 도움이 됩니다. 좋은 설명은 종종 다음과 같은 행동문으로 시작합니다:\n“선택한 텍스트를 …로 번역합니다” “…에서 노트를 자동으로 생성합니다” “…에서 노트를 가져옵니다” “…에서 하이라이트와 주석을 동기화합니다” “…에서 링크를 엽니다” “이것은 플러그인입니다\"로 설명을 시작하지 마세요. 커뮤니티 플러그인 디렉토리의 맥락에서 사용자에게는 명백할 것입니다.\n설명은 다음을 따라야 합니다:\nObsidian 스타일 가이드를 따릅니다. 최대 250자여야 합니다. 마침표 .로 끝나야 합니다. 이모티콘이나 특수 문자를 사용하지 마세요. “Obsidian”, “Markdown”, “PDF\"와 같은 약어, 고유 명사 및 상표에 대해 올바른 대소문자를 사용하세요. 용어의 대소문자 표기가 확실하지 않은 경우, 해당 웹사이트나 위키피디아 설명을 참조하세요. Node.js 및 Electron API는 데스크톱에서만 허용됩니다 Node.js 및 Electron API는 Obsidian의 데스크톱 버전에서만 사용할 수 있습니다. 예를 들어, fs, crypto, os와 같은 Node.js 패키지는 데스크톱에서만 사용할 수 있습니다.\n플러그인이 이러한 API 중 하나라도 사용하는 경우, manifest.json에서 isDesktopOnly를 true로 반드시 설정해야 합니다.\n[!tip] 많은 Node.js 기능에는 웹 API 대안이 있습니다:\ncrypto 대신 SubtleCrypto. 클립보드 내용에 접근하기 위한 navigator.clipboard.readText() 및 navigator.clipboard.writeText(). 명령어 ID에 플러그인 ID를 포함하지 마세요 Obsidian은 자동으로 명령어 ID에 플러그인 ID를 접두사로 붙입니다. 직접 플러그인 ID를 포함할 필요가 없습니다.\n모든 샘플 코드 제거하기 샘플 플러그인에는 플러그인에 필요한 가장 일반적인 작업을 수행하는 방법에 대한 예제가 포함되어 있습니다. 이는 시작을 돕기 위한 것일 뿐이며, 제출 전에 플러그인에서 샘플 코드를 제거해야 합니다.\n","categories":"","description":"","excerpt":"이 페이지는 게시되기 위해 모든 플러그인이 따라야 하는 플러그인별 요구 사항으로 [[Developer policies]]를 확 …","ref":"/ko/plugins/releasing/submission-requirements-for-plugins/","tags":"","title":""},{"body":"If you want to share your plugin with the Obsidian community, the best way is to submit it to the official list of plugins. Once we’ve reviewed and published your plugin, users can install it directly from within Obsidian. It’ll also be featured in the plugin directory on the Obsidian website.\nYou only need to submit the initial version of your plugin. After your plugin has been published, users can download new releases from GitHub directly from within Obsidian.\nPrerequisites To complete this guide, you’ll need:\nA GitHub account. Before you begin Before you submit your plugin, make sure you have the following files in the root folder of your repository:\nA README.md that describes the purpose of the plugin, and how to use it. A LICENSE that determines how others are allowed to use the plugin and its source code. If you need help to add a license for your plugin, refer to Choose a License. A manifest.json that describes your plugin. For more information, refer to [[Manifest]]. Step 1: Publish your plugin to GitHub [!note] Template repositories If you created your plugin from one of our template repositories, you may skip this step.\nTo review your plugin, we need to access to the source code on GitHub. If you’re unfamiliar with GitHub, refer to the GitHub docs for how to Create a new repository.\nStep 2: Create a release In this step, you’ll prepare a release for your plugin that’s ready to be submitted.\nIn manifest.json, update version to a new version that follows the Semantic Versioning specification, for example 1.0.0 for your initial release. Versions supported only in the format x.y.z.\nCreate a GitHub release. The “Tag version” of the release must match the version in your manifest.json.\nEnter a name for the release, and describe it in the description field. Obsidian doesn’t use the release name for anything, so feel free to name it however you like.\nUpload the following plugin assets to the release as binary attachments:\nmain.js manifest.json styles.css (optional) Step 3: Submit your plugin for review In this step, you’ll submit your plugin to the Obsidian team for review.\nIn community-plugins.json, add a new entry at the end of the JSON array.\n{ \"id\": \"doggo-dictation\", \"name\": \"Doggo Dictation\", \"author\": \"John Dolittle\", \"description\": \"Transcribes dog speech into notes.\", \"repo\": \"drdolittle/doggo-dictation\" } id, name, author, and description determines how your plugin appears to the user, and should match the corresponding properties in your [[Manifest]]. id is unique to your plugin. Search community-plugins.json to confirm that there’s no existing plugin with the same id. The id can’t contain obsidian. repo is the path to your GitHub repository. For example, if your GitHub repo is located at https://github.com/your-username/your-repo-name, the path is your-username/your-repo-name. Remember to add a comma after the closing brace, }, of the previous entry.\nSelect Commit changes… in the upper-right corner.\nSelect Propose changes.\nSelect Create pull request.\nSelect Preview, and then select Community Plugin.\nClick Create pull request.\nIn the name of the pull request, enter “Add plugin: […]”, where […] is the name of your plugin.\nFill in the details in the description for the pull request. For the checkboxes, insert an x between the brackets, [x], to mark them as done.\nClick Create pull request (for the last time 🤞).\nYou’ve now submitted your plugin to the Obsidian plugin directory. Sit back and wait for an initial validation by our friendly bot. It may take a few minutes before the results are ready.\nIf you see a Ready for review label on your PR, your submission has passed the automatic validation. If you see a Validation failed label on your PR, you need to address all listed issues until the bot assigns a Ready for review label. Once your submission is ready for review, you can sit back and wait for the Obsidian team to review it.\n[!question] How long does it take to review my plugin? The time it takes to review your submission depends on the current workload of the Obsidian team. The team is still small, so please be patient while you wait for your plugin to be reviewed. We’re currently unable to give any estimates on when we’ll be able to review your submission.\nStep 4: Address review comments Once a reviewer has reviewed your plugin, they’ll add a comment to your pull request with the result of the review. The reviewer may require that you update your plugin, or they can offer suggestions on how you can improve it.\nAddress any required changes and update the GitHub release with the new changes. Leave a comment on the PR to let us know you’ve addressed the feedback. Don’t open a new PR.\nWe’ll publish the plugin as soon we’ve verified that all required changes have been addressed.\n[!note] While only Obsidian team members can publish your plugin, other community members may also offer to review your submission in the meantime.\nNext steps Once we’ve reviewed and published your plugin, it’s time to announce it to the community:\nAnnounce in Share \u0026 showcase in the forums. Announce in the #updates channel on Discord. You need the developer role to post in #updates. ","categories":"","description":"","excerpt":"If you want to share your plugin with the Obsidian community, the best …","ref":"/plugins/releasing/submit-your-plugin/","tags":"","title":""},{"body":"플러그인을 Obsidian 커뮤니티와 공유하고 싶다면, 가장 좋은 방법은 공식 플러그인 목록에 제출하는 것입니다. 우리가 플러그인을 검토하고 게시하면, 사용자는 Obsidian 내에서 직접 설치할 수 있습니다. 또한 Obsidian 웹사이트의 플러그인 디렉토리에도 소개됩니다.\n플러그인의 초기 버전만 제출하면 됩니다. 플러그인이 게시된 후에는 사용자가 Obsidian 내에서 직접 GitHub의 새 릴리스를 다운로드할 수 있습니다.\n사전 준비 이 가이드를 완료하려면 다음이 필요합니다:\nGitHub 계정. 시작하기 전에 플러그인을 제출하기 전에 리포지토리의 루트 폴더에 다음 파일이 있는지 확인하세요:\n플러그인의 목적과 사용 방법을 설명하는 README.md. 다른 사람이 플러그인과 소스 코드를 어떻게 사용할 수 있는지 결정하는 LICENSE. 플러그인에 라이선스를 추가하는 데 도움이 필요하면 라이선스 선택을 참조하세요. 플러그인을 설명하는 manifest.json. 자세한 내용은 [[Manifest]]를 참조하세요. 1단계: GitHub에 플러그인 게시하기 [!note] 템플릿 리포지토리 템플릿 리포지토리 중 하나에서 플러그인을 생성한 경우 이 단계를 건너뛸 수 있습니다.\n플러그인을 검토하려면 GitHub의 소스 코드에 접근해야 합니다. GitHub에 익숙하지 않은 경우, 새 리포지토리 생성 방법에 대한 GitHub 문서를 참조하세요.\n2단계: 릴리스 생성하기 이 단계에서는 제출할 준비가 된 플러그인 릴리스를 준비합니다.\nmanifest.json에서 version을 시맨틱 버전 관리(Semantic Versioning) 사양을 따르는 새 버전으로 업데이트합니다(예: 초기 릴리스의 경우 1.0.0). 버전은 x.y.z 형식만 지원됩니다.\nGitHub 릴리스를 생성합니다. 릴리스의 “태그 버전\"은 manifest.json의 버전과 일치해야 합니다.\n릴리스 이름을 입력하고 설명 필드에 설명합니다. Obsidian은 릴리스 이름을 아무것도 사용하지 않으므로 원하는 대로 이름을 지정해도 됩니다.\n다음 플러그인 자산을 릴리스에 바이너리 첨부 파일로 업로드합니다:\nmain.js manifest.json styles.css (선택 사항) 3단계: 검토를 위해 플러그인 제출하기 이 단계에서는 검토를 위해 Obsidian 팀에 플러그인을 제출합니다.\ncommunity-plugins.json에서 JSON 배열의 끝에 새 항목을 추가합니다.\n{ \"id\": \"doggo-dictation\", \"name\": \"Doggo Dictation\", \"author\": \"John Dolittle\", \"description\": \"Transcribes dog speech into notes.\", \"repo\": \"drdolittle/doggo-dictation\" } id, name, author, description은 플러그인이 사용자에게 어떻게 표시되는지를 결정하며, [[Manifest]]의 해당 속성과 일치해야 합니다. id는 플러그인에 고유합니다. community-plugins.json을 검색하여 동일한 ID를 가진 기존 플러그인이 없는지 확인하세요. id는 obsidian을 포함할 수 없습니다. repo는 GitHub 리포지토리의 경로입니다. 예를 들어, GitHub 리포지토리가 https://github.com/your-username/your-repo-name에 있는 경우 경로는 your-username/your-repo-name입니다. 이전 항목의 닫는 중괄호 } 뒤에 쉼표를 추가하는 것을 잊지 마세요.\n오른쪽 상단에서 **Commit changes…**를 선택합니다.\nPropose changes를 선택합니다.\nCreate pull request를 선택합니다.\nPreview를 선택한 다음 Community Plugin을 선택합니다.\nCreate pull request를 클릭합니다.\n풀 리퀘스트 이름에 “Add plugin: […]“을 입력합니다. 여기서 […]는 플러그인 이름입니다.\n풀 리퀘스트 설명에 세부 정보를 입력합니다. 확인란의 경우 대괄호 사이에 x를 삽입하여 [x] 완료로 표시합니다.\nCreate pull request를 클릭합니다 (마지막으로 🤞).\n이제 Obsidian 플러그인 디렉토리에 플러그인을 제출했습니다. 편안히 앉아 친절한 봇의 초기 검증을 기다리세요. 결과가 준비되기까지 몇 분이 걸릴 수 있습니다.\nPR에 Ready for review 레이블이 표시되면 제출이 자동 검증을 통과한 것입니다. PR에 Validation failed 레이블이 표시되면, 봇이 Ready for review 레이블을 할당할 때까지 나열된 모든 문제를 해결해야 합니다. 제출이 검토 준비가 되면, 편안히 앉아 Obsidian 팀이 검토하기를 기다릴 수 있습니다.\n[!question] 플러그인 검토에 얼마나 걸리나요? 제출 검토에 걸리는 시간은 Obsidian 팀의 현재 작업량에 따라 다릅니다. 팀은 아직 작으므로 플러그인이 검토될 때까지 인내심을 가져주세요. 현재로서는 제출 검토 시기에 대한 추정치를 제공할 수 없습니다.\n4단계: 리뷰 의견 해결하기 리뷰어가 플러그인을 검토하면, 풀 리퀘스트에 리뷰 결과와 함께 댓글을 추가할 것입니다. 리뷰어는 플러그인을 업데이트하도록 요구하거나 개선 방법에 대한 제안을 할 수 있습니다.\n필요한 변경 사항을 해결하고 새 변경 사항으로 GitHub 릴리스를 업데이트하세요. 피드백을 해결했음을 알리기 위해 PR에 댓글을 남기세요. 새 PR을 열지 마세요.\n필요한 모든 변경 사항이 해결되었는지 확인하는 즉시 플러그인을 게시할 것입니다.\n[!note] Obsidian 팀원만 플러그인을 게시할 수 있지만, 다른 커뮤니티 구성원도 그동안 제출물을 검토해 줄 수 있습니다.\n다음 단계 플러그인을 검토하고 게시한 후에는 커뮤니티에 알릴 시간입니다:\n포럼의 Share \u0026 showcase에서 발표하세요. Discord의 #updates 채널에서 발표하세요. #updates에 게시하려면 developer 역할이 필요합니다. ","categories":"","description":"","excerpt":"플러그인을 Obsidian 커뮤니티와 공유하고 싶다면, 가장 좋은 방법은 공식 플러그인 목록에 제출하는 것입니다. 우리가 플러 …","ref":"/ko/plugins/releasing/submit-your-plugin/","tags":"","title":""},{"body":"This page gives you an overview of how to add or change the Obsidian user interface.\nYou can see some of the user interface components when you first open Obsidian.\n[[Ribbon actions]] [[Views]] [[Plugins/User interface/Status bar|Status bar]] To modify the editor, refer to [[Editor]] and [[Editor extensions]].\n","categories":"","description":"","excerpt":"This page gives you an overview of how to add or change the Obsidian …","ref":"/plugins/user-interface/about-user-interface/","tags":"","title":""},{"body":"이 페이지는 Obsidian 사용자 인터페이스를 추가하거나 변경하는 방법에 대한 개요를 제공합니다.\nObsidian을 처음 열면 일부 사용자 인터페이스 구성 요소를 볼 수 있습니다.\n[[Ribbon actions]] [[Views]] [[Plugins/User interface/Status bar|Status bar]] 에디터를 수정하려면 [[Editor]] 및 [[Editor extensions]]를 참조하세요.\n","categories":"","description":"","excerpt":"이 페이지는 Obsidian 사용자 인터페이스를 추가하거나 변경하는 방법에 대한 개요를 제공합니다.\nObsidian을 처음 열 …","ref":"/ko/plugins/user-interface/about-user-interface/","tags":"","title":""},{"body":"Commands are actions that the user can perform from the Command Palette or by using a hot key.\n![[command.png]]\nTo register a new command for your plugin, call the [[addCommand|addCommand()]] method inside the onload() method:\nimport { Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { this.addCommand({ id: 'print-greeting-to-console', name: 'Print greeting to console', callback: () =\u003e { console.log('Hey, you!'); }, }); } } Conditional commands If your command is only able to run under certain conditions, then consider using [[checkCallback|checkCallback()]] instead.\nThe checkCallback runs twice. First, to perform a preliminary check to determine whether the command can run. Second, to perform the action.\nSince time may pass between the two runs, you need to perform the check during both calls.\nTo determine whether the callback should perform a preliminary check or an action, a checking argument is passed to the callback.\nIf checking is set to true, perform a preliminary check. If checking is set to false, perform an action. The command in the following example depends on a required value. In both runs, the callback checks that the value is present but only performs the action if checking is false.\nthis.addCommand({ id: 'example-command', name: 'Example command', // highlight-next-line checkCallback: (checking: boolean) =\u003e { const value = getRequiredValue(); if (value) { if (!checking) { doCommand(value); } return true } return false; }, }); Editor commands If your command needs access to the editor, you can also use the [[editorCallback|editorCallback()]], which provides the active editor and its view as arguments.\nthis.addCommand({ id: 'example-command', name: 'Example command', editorCallback: (editor: Editor, view: MarkdownView) =\u003e { const sel = editor.getSelection() console.log(`You have selected: ${sel}`); }, } [!note] Editor commands only appear in the Command Palette when there’s an active editor available.\nIf the editor callback can only run given under certain conditions, consider using the [[editorCheckCallback|editorCheckCallback()]] instead. For more information, refer to [[#Conditional commands]].\nthis.addCommand({ id: 'example-command', name: 'Example command', editorCheckCallback: (checking: boolean, editor: Editor, view: MarkdownView) =\u003e { const value = getRequiredValue(); if (value) { if (!checking) { doCommand(value); } return true } return false; }, }); Hot keys The user can run commands using a keyboard shortcut, or hot key. While they can configure this themselves, you can also provide a default hot key.\n[!warning] Avoid setting default hot keys for plugins that you intend for others to use. Hot keys are highly likely to conflict with those defined by other plugins or by the user themselves.\nIn this example, the user can run the command by pressing and holding Ctrl (or Cmd on Mac) and Shift together, and then pressing the letter a on their keyboard.\nthis.addCommand({ id: 'example-command', name: 'Example command', hotkeys: [{ modifiers: ['Mod', 'Shift'], key: 'a' }], callback: () =\u003e { console.log('Hey, you!'); }, }); [!note] The Mod key is a special modifier key that becomes Ctrl on Windows and Linux, and Cmd on macOS.\n","categories":"","description":"","excerpt":"Commands are actions that the user can perform from the Command …","ref":"/plugins/user-interface/commands/","tags":"","title":""},{"body":"명령어는 사용자가 명령어 팔레트(Command Palette)에서 또는 단축키를 사용하여 수행할 수 있는 작업입니다.\n![[../../Assets/command.png]]\n플러그인에 새 명령어를 등록하려면 onload() 메소드 내에서 [[addCommand|addCommand()]] 메소드를 호출합니다:\nimport { Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { this.addCommand({ id: 'print-greeting-to-console', name: 'Print greeting to console', callback: () =\u003e { console.log('Hey, you!'); }, }); } } 조건부 명령어 명령어가 특정 조건에서만 실행될 수 있는 경우, 대신 [[checkCallback|checkCallback()]] 사용을 고려하세요.\ncheckCallback은 두 번 실행됩니다. 첫째, 명령어가 실행될 수 있는지 예비 확인을 수행합니다. 둘째, 작업을 수행합니다.\n두 실행 사이에 시간이 경과할 수 있으므로, 두 호출 모두에서 확인을 수행해야 합니다.\n콜백이 예비 확인을 수행해야 하는지 또는 작업을 수행해야 하는지 결정하기 위해 checking 인수가 콜백에 전달됩니다.\nchecking이 true로 설정된 경우, 예비 확인을 수행합니다. checking이 false로 설정된 경우, 작업을 수행합니다. 다음 예제의 명령어는 필수 값에 따라 달라집니다. 두 실행 모두에서 콜백은 값이 있는지 확인하지만 checking이 false인 경우에만 작업을 수행합니다.\nthis.addCommand({ id: 'example-command', name: 'Example command', // highlight-next-line checkCallback: (checking: boolean) =\u003e { const value = getRequiredValue(); if (value) { if (!checking) { doCommand(value); } return true } return false; }, }); 에디터 명령어 명령어가 에디터에 접근해야 하는 경우, 활성 에디터와 해당 뷰를 인수로 제공하는 [[editorCallback|editorCallback()]]을 사용할 수도 있습니다.\nthis.addCommand({ id: 'example-command', name: 'Example command', editorCallback: (editor: Editor, view: MarkdownView) =\u003e { const sel = editor.getSelection() console.log(`You have selected: ${sel}`); }, } [!note] 에디터 명령어는 활성 에디터를 사용할 수 있을 때만 명령어 팔레트에 나타납니다.\n에디터 콜백이 특정 조건에서만 실행될 수 있는 경우, 대신 [[editorCheckCallback|editorCheckCallback()]] 사용을 고려하세요. 자세한 내용은 [[#Conditional commands]]를 참조하세요.\nthis.addCommand({ id: 'example-command', name: 'Example command', editorCheckCallback: (checking: boolean, editor: Editor, view: MarkdownView) =\u003e { const value = getRequiredValue(); if (value) { if (!checking) { doCommand(value); } return true } return false; }, }); 단축키(Hot keys) 사용자는 키보드 단축키 또는 단축키(hot key) 를 사용하여 명령어를 실행할 수 있습니다. 사용자가 직접 구성할 수도 있지만, 기본 단축키를 제공할 수도 있습니다.\n[!warning] 다른 사람이 사용하도록 의도된 플러그인에 기본 단축키를 설정하지 마세요. 단축키는 다른 플러그인이나 사용자 자신이 정의한 단축키와 충돌할 가능성이 높습니다.\n이 예제에서 사용자는 Ctrl(Mac에서는 Cmd)과 Shift를 함께 누른 다음 키보드에서 a 키를 눌러 명령어를 실행할 수 있습니다.\nthis.addCommand({ id: 'example-command', name: 'Example command', hotkeys: [{ modifiers: ['Mod', 'Shift'], key: 'a' }], callback: () =\u003e { console.log('Hey, you!'); }, }); [!note] Mod 키는 Windows 및 Linux에서는 Ctrl이 되고 macOS에서는 Cmd가 되는 특수 수정자 키입니다.\n","categories":"","description":"","excerpt":"명령어는 사용자가 명령어 팔레트(Command Palette)에서 또는 단축키를 사용하여 수행할 수 있는 작업입니다. …","ref":"/ko/plugins/user-interface/commands/","tags":"","title":""},{"body":"If you want to open up a context menu, use [[Menu|Menu]]:\nimport { Menu, Notice, Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { this.addRibbonIcon('dice', 'Open menu', (event) =\u003e { const menu = new Menu(); menu.addItem((item) =\u003e item .setTitle('Copy') .setIcon('documents') .onClick(() =\u003e { new Notice('Copied'); }) ); menu.addItem((item) =\u003e item .setTitle('Paste') .setIcon('paste') .onClick(() =\u003e { new Notice('Pasted'); }) ); menu.showAtMouseEvent(event); }); } } [[showAtMouseEvent|showAtMouseEvent()]] opens the menu where you clicked with the mouse.\n[!tip] If you need more control of where the menu appears, you can use menu.showAtPosition({ x: 20, y: 20 }) to open the menu at a position relative to the top-left corner of the Obsidian window.\nFor more information on what icons you can use, refer to [[Plugins/User interface/Icons|Icons]].\nYou can also add an item to the file menu, or the editor menu, by subscribing to the file-menu and editor-menu workspace events:\n![[context-menu-positions.png]]\nimport { Notice, Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { this.registerEvent( this.app.workspace.on('file-menu', (menu, file) =\u003e { menu.addItem((item) =\u003e { item .setTitle('Print file path 👈') .setIcon('document') .onClick(async () =\u003e { new Notice(file.path); }); }); }) ); this.registerEvent( this.app.workspace.on(\"editor-menu\", (menu, editor, view) =\u003e { menu.addItem((item) =\u003e { item .setTitle('Print file path 👈') .setIcon('document') .onClick(async () =\u003e { new Notice(view.file.path); }); }); }) ); } } For more information on handling events, refer to [[Events]].\n","categories":"","description":"","excerpt":"If you want to open up a context menu, use [[Menu|Menu]]:\nimport { …","ref":"/plugins/user-interface/context-menus/","tags":"","title":""},{"body":"컨텍스트 메뉴를 열고 싶다면 [[Menu|Menu]]를 사용하세요:\nimport { Menu, Notice, Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { this.addRibbonIcon('dice', 'Open menu', (event) =\u003e { const menu = new Menu(); menu.addItem((item) =\u003e item .setTitle('Copy') .setIcon('documents') .onClick(() =\u003e { new Notice('Copied'); }) ); menu.addItem((item) =\u003e item .setTitle('Paste') .setIcon('paste') .onClick(() =\u003e { new Notice('Pasted'); }) ); menu.showAtMouseEvent(event); }); } } [[showAtMouseEvent|showAtMouseEvent()]]는 마우스로 클릭한 위치에 메뉴를 엽니다.\n[!tip] 메뉴가 나타나는 위치를 더 세밀하게 제어해야 하는 경우, menu.showAtPosition({ x: 20, y: 20 })을 사용하여 Obsidian 창의 왼쪽 상단 모서리를 기준으로 한 위치에 메뉴를 열 수 있습니다.\n사용할 수 있는 아이콘에 대한 자세한 내용은 [[Plugins/User interface/Icons|Icons]]를 참조하세요.\nfile-menu 및 editor-menu 작업 공간 이벤트를 구독하여 파일 메뉴 또는 에디터 메뉴에 항목을 추가할 수도 있습니다:\n![[../../Assets/context-menu-positions.png]]\nimport { Notice, Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { this.registerEvent( this.app.workspace.on('file-menu', (menu, file) =\u003e { menu.addItem((item) =\u003e { item .setTitle('Print file path 👈') .setIcon('document') .onClick(async () =\u003e { new Notice(file.path); }); }); }) ); this.registerEvent( this.app.workspace.on(\"editor-menu\", (menu, editor, view) =\u003e { menu.addItem((item) =\u003e { item .setTitle('Print file path 👈') .setIcon('document') .onClick(async () =\u003e { new Notice(view.file.path); }); }); }) ); } } 이벤트 처리에 대한 자세한 내용은 [[Events]]를 참조하세요.\n","categories":"","description":"","excerpt":"컨텍스트 메뉴를 열고 싶다면 [[Menu|Menu]]를 사용하세요:\nimport { Menu, Notice, Plugin } …","ref":"/ko/plugins/user-interface/context-menus/","tags":"","title":""},{"body":"Several components in the Obsidian API, such as the [[Settings]], expose container elements:\nimport { App, PluginSettingTab } from 'obsidian'; class ExampleSettingTab extends PluginSettingTab { plugin: ExamplePlugin; constructor(app: App, plugin: ExamplePlugin) { super(app, plugin); this.plugin = plugin; } display(): void { // highlight-next-line let { containerEl } = this; // ... } } Container elements are HTMLElement objects that make it possible to create custom interfaces within Obsidian.\nCreate HTML elements using createEl() Every HTMLElement, including the container element, exposes a createEl() method that creates an HTMLElement under the original element.\nFor example, here’s how you can add an \u003ch1\u003e heading element inside the container element:\ncontainerEl.createEl('h1', { text: 'Heading 1' }); createEl() returns a reference to the new element:\nconst book = containerEl.createEl('div'); book.createEl('div', { text: 'How to Take Smart Notes' }); book.createEl('small', { text: 'Sönke Ahrens' }); Style your elements You can add custom CSS styles to your plugin by adding a styles.css file in the plugin root directory. To add some styles for the previous book example:\n.book { border: 1px solid var(--background-modifier-border); padding: 10px; } .book__title { font-weight: 600; } .book__author { color: var(--text-muted); } [!tip] --background-modifier-border and --text-muted are CSS variables that are defined and used by Obsidian itself. If you use these variables for your styles, your plugin will look great even if the user has a different theme! 🌈\nTo make the HTML elements use the styles, set the cls property for the HTML element:\nconst book = containerEl.createEl('div', { cls: 'book' }); book.createEl('div', { text: 'How to Take Smart Notes', cls: 'book__title' }); book.createEl('small', { text: 'Sönke Ahrens', cls: 'book__author' }); Now it looks much better! 🎉\n![[styles.png]]\nConditional styles Use the toggleClass method if you want to change the style of an element based on the user’s settings or other values:\nelement.toggleClass('danger', status === 'error'); ","categories":"","description":"","excerpt":"Several components in the Obsidian API, such as the [[Settings]], …","ref":"/plugins/user-interface/html-elements/","tags":"","title":""},{"body":"Obsidian API의 여러 구성 요소, 예를 들어 [[Settings]]는 컨테이너 요소(container elements) 를 노출합니다:\nimport { App, PluginSettingTab } from 'obsidian'; class ExampleSettingTab extends PluginSettingTab { plugin: ExamplePlugin; constructor(app: App, plugin: ExamplePlugin) { super(app, plugin); this.plugin = plugin; } display(): void { // highlight-next-line let { containerEl } = this; // ... } } 컨테이너 요소는 Obsidian 내에서 사용자 정의 인터페이스를 만들 수 있게 해주는 HTMLElement 객체입니다.\ncreateEl()을 사용하여 HTML 요소 생성하기 컨테이너 요소를 포함한 모든 HTMLElement는 원본 요소 아래에 HTMLElement를 생성하는 createEl() 메소드를 노출합니다.\n예를 들어, 컨테이너 요소 내부에 \u003ch1\u003e 제목 요소를 추가하는 방법은 다음과 같습니다:\ncontainerEl.createEl('h1', { text: 'Heading 1' }); createEl()은 새 요소에 대한 참조를 반환합니다:\nconst book = containerEl.createEl('div'); book.createEl('div', { text: 'How to Take Smart Notes' }); book.createEl('small', { text: 'Sönke Ahrens' }); 요소 스타일링하기 플러그인 루트 디렉토리에 styles.css 파일을 추가하여 플러그인에 사용자 정의 CSS 스타일을 추가할 수 있습니다. 이전 책 예제에 대한 스타일을 추가하려면:\n.book { border: 1px solid var(--background-modifier-border); padding: 10px; } .book__title { font-weight: 600; } .book__author { color: var(--text-muted); } [!tip] --background-modifier-border와 --text-muted는 Obsidian 자체에서 정의하고 사용하는 CSS 변수입니다. 스타일에 이 변수들을 사용하면 사용자가 다른 테마를 사용하더라도 플러그인이 멋지게 보일 것입니다! 🌈\nHTML 요소가 스타일을 사용하도록 하려면 HTML 요소의 cls 속성을 설정하세요:\nconst book = containerEl.createEl('div', { cls: 'book' }); book.createEl('div', { text: 'How to Take Smart Notes', cls: 'book__title' }); book.createEl('small', { text: 'Sönke Ahrens', cls: 'book__author' }); 이제 훨씬 좋아 보입니다! 🎉\n![[../../Assets/styles.png]]\n조건부 스타일 사용자 설정이나 다른 값에 따라 요소의 스타일을 변경하려면 toggleClass 메소드를 사용하세요:\nelement.toggleClass('danger', status === 'error'); ","categories":"","description":"","excerpt":"Obsidian API의 여러 구성 요소, 예를 들어 [[Settings]]는 컨테이너 요소(container …","ref":"/ko/plugins/user-interface/html-elements/","tags":"","title":""},{"body":"Several of the UI components in the Obsidian API lets you configure an accompanying icon. You can choose from one of the built-in icons, or you can add your own.\nBrowse available icons Browse to lucide.dev to see all available icons and their corresponding names.\nPlease note: Only icons up to v0.446.0 are supported at this time.\nUse icons If you’d like to use icons in your custom interfaces, use the [[setIcon|setIcon()]] utility function to add an icon to an [[HTML elements|HTML element]]. The following example adds icon to the status bar:\nimport { Plugin, setIcon } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { const item = this.addStatusBarItem(); setIcon(item, 'info'); } } To change the size of the icon, set the --icon-size [[Reference/CSS variables/Foundations/Icons|CSS variable]] on the element containing the icon using preset sizes:\ndiv { --icon-size: var(--icon-size-m); } Add your own icon To add a custom icon for your plugin, use the [[addIcon|addIcon()]] utility:\nimport { addIcon, Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { addIcon('circle', `\u003ccircle cx=\"50\" cy=\"50\" r=\"50\" fill=\"currentColor\" /\u003e`); this.addRibbonIcon('circle', 'Click me', () =\u003e { console.log('Hello, you!'); }); } } addIcon takes two arguments:\nA name to uniquely identify your icon. The SVG content for the icon, without the surrounding \u003csvg\u003e tag. Note that your icon needs to fit within a 0 0 100 100 view box to be drawn properly.\nAfter the call to addIcon, you can use the icon just like any of the built-in icons.\nIcon design guidelines For compatibility and cohesiveness with the Obsidian interface, your icons should follow Lucide’s guidelines:\nIcons must be designed on a 24 by 24 pixels canvas Icons must have at least 1 pixel padding within the canvas Icons must have a stroke width of 2 pixels Icons must use round joins Icons must use round caps Icons must use centered strokes Shapes (such as rectangles) in icons must have border radius of 2 pixels Distinct elements must have 2 pixels of spacing between each other Lucide also provides templates and guides for vector editors such as Illustrator, Figma, and Inkscape.\n","categories":"","description":"","excerpt":"Several of the UI components in the Obsidian API lets you configure an …","ref":"/plugins/user-interface/icons/","tags":"","title":""},{"body":"Obsidian API의 여러 UI 구성 요소를 사용하면 함께 제공되는 아이콘을 구성할 수 있습니다. 내장된 아이콘 중 하나를 선택하거나 직접 추가할 수 있습니다.\n사용 가능한 아이콘 찾아보기 lucide.dev로 이동하여 사용 가능한 모든 아이콘과 해당 이름을 확인하세요.\n참고: 현재 v0.446.0까지의 아이콘만 지원됩니다.\n아이콘 사용하기 사용자 정의 인터페이스에서 아이콘을 사용하려면 [[setIcon|setIcon()]] 유틸리티 함수를 사용하여 [[HTML elements|HTML 요소]]에 아이콘을 추가하세요. 다음 예제는 상태 표시줄에 아이콘을 추가합니다:\nimport { Plugin, setIcon } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { const item = this.addStatusBarItem(); setIcon(item, 'info'); } } 아이콘 크기를 변경하려면 아이콘을 포함하는 요소에 사전 설정된 크기를 사용하여 --icon-size [[Reference/CSS variables/Foundations/Icons|CSS 변수]]를 설정하세요:\ndiv { --icon-size: var(--icon-size-m); } 나만의 아이콘 추가하기 플러그인에 사용자 정의 아이콘을 추가하려면 [[addIcon|addIcon()]] 유틸리티를 사용하세요:\nimport { addIcon, Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { addIcon('circle', `\u003ccircle cx=\"50\" cy=\"50\" r=\"50\" fill=\"currentColor\" /\u003e`); this.addRibbonIcon('circle', 'Click me', () =\u003e { console.log('Hello, you!'); }); } } addIcon은 두 개의 인수를 받습니다:\n아이콘을 고유하게 식별할 이름. 주변 \u003csvg\u003e 태그를 제외한 아이콘의 SVG 내용. 아이콘이 제대로 그려지려면 0 0 100 100 뷰 박스 안에 맞아야 합니다.\naddIcon을 호출한 후에는 내장된 아이콘처럼 아이콘을 사용할 수 있습니다.\n아이콘 디자인 가이드라인 Obsidian 인터페이스와의 호환성 및 통일성을 위해 아이콘은 Lucide의 가이드라인을 따라야 합니다:\n아이콘은 24x24 픽셀 캔버스에서 디자인되어야 합니다. 아이콘은 캔버스 내에 최소 1픽셀의 여백이 있어야 합니다. 아이콘은 2픽셀의 획 두께를 가져야 합니다. 아이콘은 둥근 조인을 사용해야 합니다. 아이콘은 둥근 캡을 사용해야 합니다. 아이콘은 중앙 정렬된 획을 사용해야 합니다. 아이콘의 도형(예: 사각형)은 2픽셀의 테두리 반경을 가져야 합니다. 개별 요소는 서로 2픽셀의 간격이 있어야 합니다. Lucide는 또한 Illustrator, Figma, Inkscape와 같은 벡터 편집기를 위한 템플릿과 가이드를 제공합니다.\n","categories":"","description":"","excerpt":"Obsidian API의 여러 UI 구성 요소를 사용하면 함께 제공되는 아이콘을 구성할 수 있습니다. …","ref":"/ko/plugins/user-interface/icons/","tags":"","title":""},{"body":"Modals display information and accept input from the user. To create a modal, create a class that extends [[Reference/TypeScript API/Modal|Modal]]:\nimport { App, Modal } from 'obsidian'; export class ExampleModal extends Modal { constructor(app: App) { super(app); this.setContent('Look at me, I\\'m a modal! 👀') } } To open a modal, create a new instance of ExampleModal and call [[Reference/TypeScript API/Modal/open|open()]] on it:\nimport { Plugin } from 'obsidian'; import { ExampleModal } from './modal'; export default class ExamplePlugin extends Plugin { async onload() { this.addCommand({ id: 'display-modal', name: 'Display modal', callback: () =\u003e { new ExampleModal(this.app).open(); }, }); } } Accept user input The modal in the previous example only displayed some text. Let’s look at a little more complex example that handles input from the user.\n![[modal-input.png]]\nimport { App, Modal, Setting } from 'obsidian'; export class ExampleModal extends Modal { constructor(app: App, onSubmit: (result: string) =\u003e void) { super(app); this.setTitle('What\\'s your name?'); let name = ''; new Setting(this.contentEl) .setName('Name') .addText((text) =\u003e text.onChange((value) =\u003e { name = value; })); new Setting(this.contentEl) .addButton((btn) =\u003e btn .setButtonText('Submit') .setCta() .onClick(() =\u003e { this.close(); onSubmit(name); })); } } The result is returned in the onSubmit callback when the user clicks Submit:\nnew ExampleModal(this.app, (result) =\u003e { new Notice(`Hello, ${result}!`); }).open(); Select from list of suggestions [[SuggestModal|SuggestModal]] is a special modal that lets you display a list of suggestions to the user.\n![[suggest-modal.gif]]\nimport { App, Notice, SuggestModal } from 'obsidian'; interface Book { title: string; author: string; } const ALL_BOOKS = [ { title: 'How to Take Smart Notes', author: 'Sönke Ahrens', }, { title: 'Thinking, Fast and Slow', author: 'Daniel Kahneman', }, { title: 'Deep Work', author: 'Cal Newport', }, ]; export class ExampleModal extends SuggestModal\u003cBook\u003e { // Returns all available suggestions. getSuggestions(query: string): Book[] { return ALL_BOOKS.filter((book) =\u003e book.title.toLowerCase().includes(query.toLowerCase()) ); } // Renders each suggestion item. renderSuggestion(book: Book, el: HTMLElement) { el.createEl('div', { text: book.title }); el.createEl('small', { text: book.author }); } // Perform action on the selected suggestion. onChooseSuggestion(book: Book, evt: MouseEvent | KeyboardEvent) { new Notice(`Selected ${book.title}`); } } In addition to SuggestModal, the Obsidian API provides an even more specialized type of modal for suggestions: the [[FuzzySuggestModal|FuzzySuggestModal]]. While it doesn’t give you the same control of how each item is rendered, you get fuzzy string search out-of-the-box.\n![[fuzzy-suggestion-modal.png]]\nexport class ExampleModal extends FuzzySuggestModal\u003cBook\u003e { getItems(): Book[] { return ALL_BOOKS; } getItemText(book: Book): string { return book.title; } onChooseItem(book: Book, evt: MouseEvent | KeyboardEvent) { new Notice(`Selected ${book.title}`); } } ","categories":"","description":"","excerpt":"Modals display information and accept input from the user. To create a …","ref":"/plugins/user-interface/modals/","tags":"","title":""},{"body":"모달은 정보를 표시하고 사용자로부터 입력을 받습니다. 모달을 생성하려면 [[Reference/TypeScript API/Modal|Modal]]을 확장하는 클래스를 만듭니다:\nimport { App, Modal } from 'obsidian'; export class ExampleModal extends Modal { constructor(app: App) { super(app); this.setContent('Look at me, I\\'m a modal! 👀') } } 모달을 열려면 ExampleModal의 새 인스턴스를 만들고 [[Reference/TypeScript API/Modal/open|open()]]을 호출합니다:\nimport { Plugin } from 'obsidian'; import { ExampleModal } from './modal'; export default class ExamplePlugin extends Plugin { async onload() { this.addCommand({ id: 'display-modal', name: 'Display modal', callback: () =\u003e { new ExampleModal(this.app).open(); }, }); } } 사용자 입력 받기 이전 예제의 모달은 텍스트만 표시했습니다. 사용자 입력을 처리하는 좀 더 복잡한 예제를 살펴보겠습니다.\n![[../../Assets/modal-input.png]]\nimport { App, Modal, Setting } from 'obsidian'; export class ExampleModal extends Modal { constructor(app: App, onSubmit: (result: string) =\u003e void) { super(app); this.setTitle('What\\'s your name?'); let name = ''; new Setting(this.contentEl) .setName('Name') .addText((text) =\u003e text.onChange((value) =\u003e { name = value; })); new Setting(this.contentEl) .addButton((btn) =\u003e btn .setButtonText('Submit') .setCta() .onClick(() =\u003e { this.close(); onSubmit(name); })); } } 사용자가 Submit을 클릭하면 onSubmit 콜백에서 결과가 반환됩니다:\nnew ExampleModal(this.app, (result) =\u003e { new Notice(`Hello, ${result}!`); }).open(); 제안 목록에서 선택하기 [[SuggestModal|SuggestModal]]은 사용자에게 제안 목록을 표시할 수 있는 특수 모달입니다.\n![[../../Assets/suggest-modal.gif]]\nimport { App, Notice, SuggestModal } from 'obsidian'; interface Book { title: string; author: string; } const ALL_BOOKS = [ { title: 'How to Take Smart Notes', author: 'Sönke Ahrens', }, { title: 'Thinking, Fast and Slow', author: 'Daniel Kahneman', }, { title: 'Deep Work', author: 'Cal Newport', }, ]; export class ExampleModal extends SuggestModal\u003cBook\u003e { // 사용 가능한 모든 제안을 반환합니다. getSuggestions(query: string): Book[] { return ALL_BOOKS.filter((book) =\u003e book.title.toLowerCase().includes(query.toLowerCase()) ); } // 각 제안 항목을 렌더링합니다. renderSuggestion(book: Book, el: HTMLElement) { el.createEl('div', { text: book.title }); el.createEl('small', { text: book.author }); } // 선택된 제안에 대한 작업을 수행합니다. onChooseSuggestion(book: Book, evt: MouseEvent | KeyboardEvent) { new Notice(`Selected ${book.title}`); } } Obsidian API는 SuggestModal 외에도 제안을 위한 훨씬 더 전문화된 유형의 모달인 [[FuzzySuggestModal|FuzzySuggestModal]]을 제공합니다. 각 항목이 렌더링되는 방식에 대한 동일한 제어권을 제공하지는 않지만, 기본적으로 유사 문자열 검색(fuzzy string search)을 사용할 수 있습니다.\n![[../../Assets/fuzzy-suggestion-modal.png]]\nexport class ExampleModal extends FuzzySuggestModal\u003cBook\u003e { getItems(): Book[] { return ALL_BOOKS; } getItemText(book: Book): string { return book.title; } onChooseItem(book: Book, evt: MouseEvent | KeyboardEvent) { new Notice(`Selected ${book.title}`); } } ","categories":"","description":"","excerpt":"모달은 정보를 표시하고 사용자로부터 입력을 받습니다. 모달을 생성하려면 [[Reference/TypeScript …","ref":"/ko/plugins/user-interface/modals/","tags":"","title":""},{"body":"The sidebar on the left side of the Obsidian interface is mainly known as the ribbon. The purpose of the ribbon is to host actions defined by plugins.\nTo add an action to the ribbon, use the [[addRibbonIcon|addRibbonIcon()]] method:\nimport { Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { this.addRibbonIcon('dice', 'Print to console', () =\u003e { console.log('Hello, you!'); }); } } The first argument specifies which icon to use. For more information on the available icons, and how to add your own, refer to [[Plugins/User interface/Icons|Icons]].\n[!note] Users can remove your plugin’s icon from the ribbon, or even opt to hide the ribbon entirely. Therefore it’s advisable to include alternate ways of accessing functionality that’s in the ribbon, such as creating a [[Plugins/User interface/Commands|command]].\n","categories":"","description":"","excerpt":"The sidebar on the left side of the Obsidian interface is mainly known …","ref":"/plugins/user-interface/ribbon-actions/","tags":"","title":""},{"body":"Obsidian 인터페이스의 왼쪽에 있는 사이드바는 주로 리본(ribbon) 으로 알려져 있습니다. 리본의 목적은 플러그인에 의해 정의된 작업을 호스팅하는 것입니다.\n리본에 작업을 추가하려면 [[addRibbonIcon|addRibbonIcon()]] 메소드를 사용하세요:\nimport { Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { this.addRibbonIcon('dice', 'Print to console', () =\u003e { console.log('Hello, you!'); }); } } 첫 번째 인수는 사용할 아이콘을 지정합니다. 사용 가능한 아이콘 및 자신만의 아이콘을 추가하는 방법에 대한 자세한 내용은 [[Plugins/User interface/Icons|Icons]]를 참조하세요.\n[!note] 사용자는 리본에서 플러그인의 아이콘을 제거하거나 리본을 완전히 숨기도록 선택할 수 있습니다. 따라서 [[Plugins/User interface/Commands|명령어]]를 생성하는 것과 같이 리본에 있는 기능에 접근할 수 있는 대체 방법을 포함하는 것이 좋습니다.\n","categories":"","description":"","excerpt":"Obsidian 인터페이스의 왼쪽에 있는 사이드바는 주로 리본(ribbon) 으로 알려져 있습니다. 리본의 목적은 플러그인에  …","ref":"/ko/plugins/user-interface/ribbon-actions/","tags":"","title":""},{"body":" [!Warning] New in Obsidian 1.6 Obsidian 1.6 contains many improvements for right-to-left languages, with mirrored UI and mixed language support. These changes can affect themes and plugins.\nObsidian supports right-to-left (RTL) languages such as Arabic, Dhivehi, Hebrew, Farsi, Syriac, and Urdu. These languages are spoken by more than 600 million people. When developing plugins and themes for Obsidian it is important consider how your interface changes will adapt to the direction of the language interface and content.\nRTL languages can be present in two important contexts within Obsidian: the app interface and the content of notes.\nThe app interface is defined by the language selected in Obsidian Settings. If the user selects an RTL language, the app interface is automatically reversed, and a .mod-rtl class is added to the body element. The specific interface language is also is added to the lang attribute on the html element. The content of notes can be written in left-to-right (LTR) languages, RTL languages, or mix both LTR and RTL languages within the same note. Obsidian automatically detects the direction of the language in the editor and adds the dir attribute to each line. When the user selects an RTL language as their interface language, or sets RTL as the default editor direction in Obsidian settings, the dir=\"rtl\" attribute is added to the editor.\n[!INFO] Mixed direction support Be aware that many RTL users choose to use a LTR language for the interface while writing some notes in a RTL language, or mix LTR and RTL languages within the same note.\nUser expectations for RTL interfaces Major operating systems reverse the interface for RTL language users. User interface components provided by the operating system are typically mirrored horizontally. Apps that do not behave this way can feel out of place to RTL users.\nThe following guides provide a useful reference for designing interfaces that work both LTR and RTL:\nApple RTL human interface guidelines RTL Styling 101 MDN logical properties and values Make plugins and themes agnostic of language direction Obsidian is built using web technologies which means it uses existing CSS and HTML features to make the interface adapt to the language direction.\nUse logical properties, avoid directional properties Whenever you use CSS to add positioning and spacing, use logical properties and values such start and end rather than directional alternatives such as left and right. See the MDN documentation for a full list of logical properties and values.\nPrefer logical over directional properties:\nProperties Directional Logical Margins margin-left margin-inline-start margin-right margin-inline-end Padding padding-left padding-inline-start padding-right padding-inline-end Borders border-left border-inline-start border-right border-inline-end Absolute positioning left inset-inline-start right inset-inline-end Prefer logical over directional values:\nValues Directional Logical Float float: left float: inline-start float: right float: inline-end Text alignment text-align: left text-align: start text-align: right text-align: end Use fallback values when necessary Some users may be using older Obsidian installers that do not include the latest versions of Chromium.\nSelectors that use newer selectors should be guarded by @supports to prevent the entire block from breaking. If there is a property that doesn’t have 100% support, split the rule into 2 lines. The first line should provide the fallback. The second line should attempt to apply the new value. If this line fails, the previous style will get applied and it will fallback gracefully. .supported, .unsupported { /* this won't run */ } .supported { /* this will run */ } .unsupported { /* this won't run */ } @supports selector(:dir(*)) { /* will run if :dir() is supported */ } Obsidian CSS helpers and rules for RTL Selectors for language direction Global selectors The .mod-rtl class is added to the body element when an RTL language is selected in Settings → General. Changing the interface language requires the user to restart Obsidian.\nYou can use .mod-rtl to set the direction of interface elements in your plugin or theme. For example:\n.mod-rtl .plugin-class { direction: rtl; } Additionally, the specific interface language is also is added to the lang attribute on the html element. For example lang=\"ar\" for Arabic.\nEditor selectors The dir=\"rtl\" attribute is added to the .markdown-source-view element when the user chooses an RTL interface language in Settings → General, or sets RTL as the default editor direction in Settings → Editor.\nWhen editing a file, the dir attribute is set to rtl or ltr per line on .cm-line elements by detecting the first strongly directional character. If no strongly directional character is present, the editor defaults to the direction of the previous strongly directional line.\nIn reading mode, the direction of lines is set automatically using the dir=\"auto\" attribute on each block.\nIcons are mirrored automatically Obsidian uses the Lucide icon library. Because almost all icons are either symmetric or have a LTR bias Obsidian automatically reverses the direction of icons when the interface is in RTL mode. To prevent reversing a specific icon in RTL mode you must explicitly unset the transformation.\nFor example if you want .left-icon to not be mirrored for RTL languages:\n.mod-rtl svg.svg-icon.left-icon { transform: unset; } Use the direction variable for horizontal calculations The CSS variable --direction is available for calculations such as translateX() so that elements can be shifted horizontally according to language direction where logical values are not available.\nVariable LTR value RTL value --direction 1 -1 Choose the best bidirectional handling for an element The CSS unicode-bidi property can be used to determine how bidirectional content is treated.\nUsing the plaintext value can be useful in certain cases. In the Obsidian UI the plaintext value is used whenever a single line of content is present that could be either LTR or RTL. For example, file names, outline items, tooltips, status bar elements. This ensures the correct direction of the content and trimming of long names with ellipses (…) when necessary.\n","categories":"","description":"Obsidian supports right-to-left (RTL) languages such as Arabic, Dhivehi, Hebrew, Farsi, Syriac, and Urdu. These languages are spoken by more than 600 million people. When developing plugins and themes for Obsidian it is important consider how your interface changes will adapt to the direction of the language interface and content.","excerpt":"Obsidian supports right-to-left (RTL) languages such as Arabic, …","ref":"/plugins/user-interface/right-to-left/","tags":"","title":""},{"body":" [!Warning] Obsidian 1.6의 새로운 기능 Obsidian 1.6에는 미러링된 UI와 혼합 언어 지원 등 오른쪽에서 왼쪽으로 쓰는 언어에 대한 많은 개선 사항이 포함되어 있습니다. 이러한 변경 사항은 테마와 플러그인에 영향을 줄 수 있습니다.\nObsidian은 아랍어, 디베히어, 히브리어, 페르시아어, 시리아어, 우르두어와 같은 오른쪽에서 왼쪽으로 쓰는(RTL) 언어를 지원합니다. 이러한 언어는 6억 명 이상이 사용합니다. Obsidian용 플러그인과 테마를 개발할 때 인터페이스 변경 사항이 언어 인터페이스 및 콘텐츠의 방향에 어떻게 적응할지 고려하는 것이 중요합니다.\nRTL 언어는 Obsidian 내에서 두 가지 중요한 맥락으로 존재할 수 있습니다: 앱 인터페이스와 노트의 콘텐츠.\n앱 인터페이스는 Obsidian 설정에서 선택한 언어에 의해 정의됩니다. 사용자가 RTL 언어를 선택하면 앱 인터페이스가 자동으로 반전되고 body 요소에 .mod-rtl 클래스가 추가됩니다. 특정 인터페이스 언어는 html 요소의 lang 속성에도 추가됩니다. 노트의 콘텐츠는 왼쪽에서 오른쪽으로(LTR) 쓰는 언어, RTL 언어로 작성되거나 동일한 노트 내에서 LTR 및 RTL 언어를 혼합하여 작성할 수 있습니다. Obsidian은 에디터에서 언어의 방향을 자동으로 감지하고 각 줄에 dir 속성을 추가합니다. 사용자가 인터페이스 언어로 RTL 언어를 선택하거나 Obsidian 설정에서 RTL을 기본 에디터 방향으로 설정하면 에디터에 dir=\"rtl\" 속성이 추가됩니다.\n[!INFO] 혼합 방향 지원 많은 RTL 사용자는 인터페이스에 LTR 언어를 사용하면서 일부 노트를 RTL 언어로 작성하거나 동일한 노트 내에서 LTR 및 RTL 언어를 혼합하여 사용하는 것을 선택합니다.\nRTL 인터페이스에 대한 사용자 기대치 주요 운영 체제는 RTL 언어 사용자를 위해 인터페이스를 반전시킵니다. 운영 체제에서 제공하는 사용자 인터페이스 구성 요소는 일반적으로 수평으로 미러링됩니다. 이렇게 작동하지 않는 앱은 RTL 사용자에게 어색하게 느껴질 수 있습니다.\n다음 가이드는 LTR 및 RTL 모두에서 작동하는 인터페이스를 디자인하는 데 유용한 참조를 제공합니다:\nApple RTL 휴먼 인터페이스 가이드라인 RTL 스타일링 101 MDN 논리적 속성 및 값 플러그인과 테마를 언어 방향에 구애받지 않도록 만들기 Obsidian은 웹 기술을 사용하여 구축되었으므로 기존 CSS 및 HTML 기능을 사용하여 인터페이스가 언어 방향에 적응하도록 합니다.\n논리적 속성 사용, 방향성 속성 피하기 CSS를 사용하여 위치 및 간격을 추가할 때마다 left 및 right와 같은 방향성 대안 대신 start 및 end와 같은 논리적 속성 및 값을 사용하세요. 논리적 속성 및 값의 전체 목록은 MDN 문서를 참조하세요.\n방향성 속성보다 논리적 속성을 선호하세요:\n속성 방향성 논리적 여백(Margins) margin-left margin-inline-start margin-right margin-inline-end 안쪽 여백(Padding) padding-left padding-inline-start padding-right padding-inline-end 테두리(Borders) border-left border-inline-start border-right border-inline-end 절대 위치(Absolute) left inset-inline-start right inset-inline-end 방향성 값보다 논리적 값을 선호하세요:\n값 방향성 논리적 플로트(Float) float: left float: inline-start float: right float: inline-end 텍스트 정렬(Align) text-align: left text-align: start text-align: right text-align: end 필요한 경우 대체 값 사용하기 일부 사용자는 최신 버전의 Chromium이 포함되지 않은 이전 Obsidian 설치 프로그램을 사용할 수 있습니다.\n최신 선택자를 사용하는 선택자는 전체 블록이 깨지는 것을 방지하기 위해 @supports로 보호해야 합니다. 100% 지원되지 않는 속성이 있는 경우 규칙을 2줄로 나눕니다. 첫 번째 줄은 대체를 제공해야 합니다. 두 번째 줄은 새 값을 적용하려고 시도해야 합니다. 이 줄이 실패하면 이전 스타일이 적용되고 정상적으로 대체됩니다. .supported, .unsupported { /* 실행되지 않음 */ } .supported { /* 실행됨 */ } .unsupported { /* 실행되지 않음 */ } @supports selector(:dir(*)) { /* :dir()이 지원되는 경우 실행됨 */ } RTL을 위한 Obsidian CSS 헬퍼 및 규칙 언어 방향 선택자 전역 선택자 Settings → General에서 RTL 언어를 선택하면 body 요소에 .mod-rtl 클래스가 추가됩니다. 인터페이스 언어를 변경하려면 사용자가 Obsidian을 다시 시작해야 합니다.\n.mod-rtl을 사용하여 플러그인 또는 테마의 인터페이스 요소 방향을 설정할 수 있습니다. 예:\n.mod-rtl .plugin-class { direction: rtl; } 또한 특정 인터페이스 언어는 html 요소의 lang 속성에도 추가됩니다. 예: 아랍어의 경우 lang=\"ar\".\n에디터 선택자 사용자가 Settings → General에서 RTL 인터페이스 언어를 선택하거나 Settings → Editor에서 RTL을 기본 에디터 방향으로 설정하면 .markdown-source-view 요소에 dir=\"rtl\" 속성이 추가됩니다.\n파일을 편집할 때, 첫 번째 강력한 방향성 문자를 감지하여 .cm-line 요소에 dir 속성이 rtl 또는 ltr로 설정됩니다. 강력한 방향성 문자가 없는 경우, 에디터는 이전 강력한 방향성 줄의 방향을 기본값으로 사용합니다.\n읽기 모드에서는 각 블록에 dir=\"auto\" 속성을 사용하여 줄의 방향이 자동으로 설정됩니다.\n아이콘은 자동으로 미러링됩니다 Obsidian은 Lucide 아이콘 라이브러리를 사용합니다. 거의 모든 아이콘이 대칭이거나 LTR 편향을 가지고 있기 때문에 Obsidian은 인터페이스가 RTL 모드일 때 아이콘의 방향을 자동으로 반전시킵니다. RTL 모드에서 특정 아이콘이 반전되는 것을 방지하려면 변환을 명시적으로 해제해야 합니다.\n예를 들어 .left-icon이 RTL 언어에 대해 미러링되지 않도록 하려면:\n.mod-rtl svg.svg-icon.left-icon { transform: unset; } 수평 계산에 방향 변수 사용하기 CSS 변수 --direction은 논리적 값을 사용할 수 없는 경우 언어 방향에 따라 요소를 수평으로 이동시키기 위해 translateX()와 같은 계산에 사용할 수 있습니다.\n변수 LTR 값 RTL 값 --direction 1 -1 요소에 가장 적합한 양방향 처리 선택하기 CSS unicode-bidi 속성은 양방향 콘텐츠가 처리되는 방식을 결정하는 데 사용할 수 있습니다.\nplaintext 값을 사용하는 것은 특정 경우에 유용할 수 있습니다. Obsidian UI에서는 LTR 또는 RTL일 수 있는 단일 줄의 콘텐츠가 있을 때마다 plaintext 값이 사용됩니다. 예를 들어, 파일 이름, 개요 항목, 툴팁, 상태 표시줄 요소 등이 있습니다. 이렇게 하면 콘텐츠의 올바른 방향을 보장하고 필요한 경우 줄임표(…)로 긴 이름을 자를 수 있습니다.\n","categories":"","description":"Obsidian은 아랍어, 디베히어, 히브리어, 페르시아어, 시리아어, 우르두어와 같은 오른쪽에서 왼쪽으로 쓰는(RTL) 언어를 지원합니다. 이러한 언어는 6억 명 이상이 사용합니다. Obsidian용 플러그인과 테마를 개발할 때 인터페이스 변경 사항이 언어 인터페이스 및 콘텐츠의 방향에 어떻게 적응할지 고려하는 것이 중요합니다.","excerpt":"Obsidian은 아랍어, 디베히어, 히브리어, 페르시아어, 시리아어, 우르두어와 같은 오른쪽에서 왼쪽으로 쓰는(RTL) 언어 …","ref":"/ko/plugins/user-interface/right-to-left/","tags":"","title":""},{"body":"If you want users to be able to configure parts of your plugin themselves, you can expose them as settings.\nIn this guide, you’ll learn how to create a settings page like this 👇\n![[settings.png]]\nThe main reason to add settings to a plugin is to store configuration that persists even after the user quits Obsidian. The following example demonstrates how to save and load settings from disk:\nimport { Plugin } from 'obsidian'; import { ExampleSettingTab } from './settings'; interface ExamplePluginSettings { dateFormat: string; } const DEFAULT_SETTINGS: Partial\u003cExamplePluginSettings\u003e = { dateFormat: 'YYYY-MM-DD', }; export default class ExamplePlugin extends Plugin { settings: ExamplePluginSettings; async onload() { await this.loadSettings(); this.addSettingTab(new ExampleSettingTab(this.app, this)); } async loadSettings() { this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData()); } async saveSettings() { await this.saveData(this.settings); } } [!warning] Nested properties in settings Object.assign() copies the references to any nested property (shallow copy). If your settings object contains nested properties, you need to copy each nested property recursively (deep copy). Otherwise, any changes to a nested property will apply to all objects that were copied using Object.assign().\nThere’s a lot going on here 🤯, so let’s look closer at each part.\nCreate a settings definition First, you need to create a definition, ExamplePluginSettings, for what settings you want the user to be able to configure. While the plugin is enabled, you can access the settings from the settings member variable.\ninterface ExamplePluginSettings { dateFormat: string; } export default class ExamplePlugin extends Plugin { settings: ExamplePluginSettings; // ... } Save and load the settings object [[loadData|loadData()]] and [[saveData|saveData()]] provide an easy way to store and retrieve data from disk. The example also introduces two helper methods that makes it easier to use loadData() and saveData() from other parts of the plugin.\nexport default class ExamplePlugin extends Plugin { // ... async loadSettings() { this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData()); } async saveSettings() { await this.saveData(this.settings); } } Finally, make sure to load the settings when the plugin loads:\nasync onload() { await this.loadSettings(); // ... } Provide default values When the user enables the plugin for the first time, none of the settings have been configured yet. The preceding example provides default values for any missing settings.\nTo understand how this work, let’s look at the following code:\nObject.assign({}, DEFAULT_SETTINGS, await this.loadData()) Object.assign() is a JavaScript function that copies all properties from one object to another. Any properties that are returned by loadData() override the properties in DEFAULT_SETTINGS.\nconst DEFAULT_SETTINGS: Partial\u003cExamplePluginSettings\u003e = { dateFormat: 'YYYY-MM-DD', }; [!tip] Partial\u003cType\u003e is a TypeScript utility that returns a type with all properties of Type set to optional. It enables type checking while letting you only define the properties you want to provide defaults for.\nRegister a settings tab The plugin can now save and load plugin configuration, but the user doesn’t yet have any way of changing any of the settings. By adding a settings tab you can provide an easy-to-use interface for the user to update their plugin settings:\nthis.addSettingTab(new ExampleSettingTab(this.app, this)); Here, the ExampleSettingTab is a class that extends [[PluginSettingTab|PluginSettingTab]]:\nimport ExamplePlugin from './main'; import { App, PluginSettingTab, Setting } from 'obsidian'; export class ExampleSettingTab extends PluginSettingTab { plugin: ExamplePlugin; constructor(app: App, plugin: ExamplePlugin) { super(app, plugin); this.plugin = plugin; } display(): void { let { containerEl } = this; containerEl.empty(); new Setting(containerEl) .setName('Date format') .setDesc('Default date format') .addText((text) =\u003e text .setPlaceholder('MMMM dd, yyyy') .setValue(this.plugin.settings.dateFormat) .onChange(async (value) =\u003e { this.plugin.settings.dateFormat = value; await this.plugin.saveSettings(); }) ); } } display() is where you build the content for the settings tab. For more information, refer to [[HTML elements]].\nnew Setting(containerEl) appends a setting to the container element. This example uses a text field using addText(), but there are several other setting types available.\nUpdate the settings object whenever the value of the text field changes, and then save it to disk:\n.onChange(async (value) =\u003e { this.plugin.settings.dateFormat = value; await this.plugin.saveSettings(); }) Nice work! 💪 Your users will thank you for giving them a way to customize how they interact with your plugin. Before heading to the next guide, experiment with what you’ve learned by adding another setting.\n","categories":"","description":"","excerpt":"If you want users to be able to configure parts of your plugin …","ref":"/plugins/user-interface/settings/","tags":"","title":""},{"body":"사용자가 플러그인의 일부를 직접 구성할 수 있도록 하려면 설정(settings) 으로 노출할 수 있습니다.\n이 가이드에서는 다음과 같은 설정 페이지를 만드는 방법을 배웁니다 👇\n![[../../Assets/settings.png]]\n플러그인에 설정을 추가하는 주된 이유는 사용자가 Obsidian을 종료한 후에도 유지되는 구성을 저장하기 위함입니다. 다음 예제는 디스크에서 설정을 저장하고 로드하는 방법을 보여줍니다:\nimport { Plugin } from 'obsidian'; import { ExampleSettingTab } from './settings'; interface ExamplePluginSettings { dateFormat: string; } const DEFAULT_SETTINGS: Partial\u003cExamplePluginSettings\u003e = { dateFormat: 'YYYY-MM-DD', }; export default class ExamplePlugin extends Plugin { settings: ExamplePluginSettings; async onload() { await this.loadSettings(); this.addSettingTab(new ExampleSettingTab(this.app, this)); } async loadSettings() { this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData()); } async saveSettings() { await this.saveData(this.settings); } } [!warning] 설정의 중첩된 속성 Object.assign()은 중첩된 속성에 대한 참조를 복사합니다(얕은 복사). 설정 객체에 중첩된 속성이 포함된 경우, 각 중첩된 속성을 재귀적으로 복사해야 합니다(깊은 복사). 그렇지 않으면 중첩된 속성에 대한 변경 사항이 Object.assign()을 사용하여 복사된 모든 객체에 적용됩니다.\n여기에는 많은 내용이 있으니 🤯, 각 부분을 자세히 살펴보겠습니다.\n설정 정의 생성하기 먼저, 사용자가 구성할 수 있도록 하려는 설정에 대한 정의 ExamplePluginSettings를 만들어야 합니다. 플러그인이 활성화되어 있는 동안 settings 멤버 변수에서 설정에 접근할 수 있습니다.\ninterface ExamplePluginSettings { dateFormat: string; } export default class ExamplePlugin extends Plugin { settings: ExamplePluginSettings; // ... } 설정 객체 저장 및 로드하기 [[loadData|loadData()]] 및 [[saveData|saveData()]]는 디스크에서 데이터를 저장하고 검색하는 쉬운 방법을 제공합니다. 이 예제는 또한 플러그인의 다른 부분에서 loadData() 및 saveData()를 더 쉽게 사용할 수 있도록 하는 두 가지 헬퍼 메소드를 소개합니다.\nexport default class ExamplePlugin extends Plugin { // ... async loadSettings() { this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData()); } async saveSettings() { await this.saveData(this.settings); } } 마지막으로, 플러그인이 로드될 때 설정을 로드해야 합니다:\nasync onload() { await this.loadSettings(); // ... } 기본값 제공하기 사용자가 플러그인을 처음 활성화하면 설정이 아직 구성되지 않았습니다. 앞의 예제는 누락된 설정에 대한 기본값을 제공합니다.\n이것이 어떻게 작동하는지 이해하기 위해 다음 코드를 살펴보겠습니다:\nObject.assign({}, DEFAULT_SETTINGS, await this.loadData()) Object.assign()은 한 객체에서 다른 객체로 모든 속성을 복사하는 JavaScript 함수입니다. loadData()에서 반환된 모든 속성은 DEFAULT_SETTINGS의 속성을 덮어씁니다.\nconst DEFAULT_SETTINGS: Partial\u003cExamplePluginSettings\u003e = { dateFormat: 'YYYY-MM-DD', }; [!tip] Partial\u003cType\u003e은 Type의 모든 속성을 선택적으로 설정한 타입을 반환하는 TypeScript 유틸리티입니다. 기본값을 제공하려는 속성만 정의하면서 타입 검사를 활성화할 수 있습니다.\n설정 탭 등록하기 이제 플러그인은 플러그인 구성을 저장하고 로드할 수 있지만, 사용자는 아직 설정을 변경할 방법이 없습니다. 설정 탭을 추가하면 사용자가 플러그인 설정을 업데이트할 수 있는 사용하기 쉬운 인터페이스를 제공할 수 있습니다:\nthis.addSettingTab(new ExampleSettingTab(this.app, this)); 여기서 ExampleSettingTab은 [[PluginSettingTab|PluginSettingTab]]을 확장하는 클래스입니다:\nimport ExamplePlugin from './main'; import { App, PluginSettingTab, Setting } from 'obsidian'; export class ExampleSettingTab extends PluginSettingTab { plugin: ExamplePlugin; constructor(app: App, plugin: ExamplePlugin) { super(app, plugin); this.plugin = plugin; } display(): void { let { containerEl } = this; containerEl.empty(); new Setting(containerEl) .setName('Date format') .setDesc('Default date format') .addText((text) =\u003e text .setPlaceholder('MMMM dd, yyyy') .setValue(this.plugin.settings.dateFormat) .onChange(async (value) =\u003e { this.plugin.settings.dateFormat = value; await this.plugin.saveSettings(); }) ); } } display()는 설정 탭의 내용을 빌드하는 곳입니다. 자세한 내용은 [[HTML elements]]를 참조하세요.\nnew Setting(containerEl)은 컨테이너 요소에 설정을 추가합니다. 이 예제는 addText()를 사용하여 텍스트 필드를 사용하지만, 다른 여러 설정 유형을 사용할 수 있습니다.\n텍스트 필드의 값이 변경될 때마다 설정 객체를 업데이트한 다음 디스크에 저장합니다:\n.onChange(async (value) =\u003e { this.plugin.settings.dateFormat = value; await this.plugin.saveSettings(); }) 잘했습니다! 💪 사용자들은 플러그인과 상호 작용하는 방식을 사용자 정의할 수 있는 방법을 제공해 준 것에 대해 감사할 것입니다. 다음 가이드로 넘어가기 전에, 배운 내용을 바탕으로 다른 설정을 추가하여 실험해보세요.\n","categories":"","description":"","excerpt":"사용자가 플러그인의 일부를 직접 구성할 수 있도록 하려면 설정(settings) 으로 노출할 수 있습니다.\n이 가이드에서는 다 …","ref":"/ko/plugins/user-interface/settings/","tags":"","title":""},{"body":"To create a new block in the status bar, call the [[addStatusBarItem|addStatusBarItem()]] in the onload() method. The addStatusBarItem() method returns an [[HTML elements]] that you can add your own elements to.\n[!caution] Obsidian mobile Custom status bar items are not supported on Obsidian mobile apps.\nimport { Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { const item = this.addStatusBarItem(); item.createEl('span', { text: 'Hello from the status bar 👋' }); } } [!note] For more information on how to use the createEl() method, refer to [[HTML elements]].\nYou can add multiple status bar items by calling addStatusBarItem() multiple times. Since Obsidian adds a gap between them, you need to create multiple HTML element on the same status bar item if you need more control of spacing.\nimport { Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { const fruits = this.addStatusBarItem(); fruits.createEl('span', { text: '🍎' }); fruits.createEl('span', { text: '🍌' }); const veggies = this.addStatusBarItem(); veggies.createEl('span', { text: '🥦' }); veggies.createEl('span', { text: '🥬' }); } } The example above results in the following status bar:\n![[status-bar.png]]\n","categories":"","description":"","excerpt":"To create a new block in the status bar, call the …","ref":"/plugins/user-interface/status-bar/","tags":"","title":""},{"body":"상태 표시줄에 새 블록을 만들려면 onload() 메소드에서 [[addStatusBarItem|addStatusBarItem()]]을 호출하세요. addStatusBarItem() 메소드는 자신만의 요소를 추가할 수 있는 [[HTML elements]]를 반환합니다.\n[!caution] Obsidian 모바일 사용자 정의 상태 표시줄 항목은 Obsidian 모바일 앱에서 지원되지 않습니다.\nimport { Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { const item = this.addStatusBarItem(); item.createEl('span', { text: 'Hello from the status bar 👋' }); } } [!note] createEl() 메소드 사용 방법에 대한 자세한 내용은 [[HTML elements]]를 참조하세요.\naddStatusBarItem()을 여러 번 호출하여 여러 상태 표시줄 항목을 추가할 수 있습니다. Obsidian은 항목들 사이에 간격을 추가하므로, 간격을 더 세밀하게 제어해야 하는 경우 동일한 상태 표시줄 항목에 여러 HTML 요소를 만들어야 합니다.\nimport { Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { const fruits = this.addStatusBarItem(); fruits.createEl('span', { text: '🍎' }); fruits.createEl('span', { text: '🍌' }); const veggies = this.addStatusBarItem(); veggies.createEl('span', { text: '🥦' }); veggies.createEl('span', { text: '🥬' }); } } 위 예제는 다음 상태 표시줄을 결과로 보여줍니다:\n![[../../Assets/status-bar.png]]\n","categories":"","description":"","excerpt":"상태 표시줄에 새 블록을 만들려면 onload() …","ref":"/ko/plugins/user-interface/status-bar/","tags":"","title":""},{"body":"Views determine how Obsidian displays content. The file explorer, graph view, and the Markdown view are all examples of views, but you can also create your own custom views that display content in a way that makes sense for your plugin.\nTo create a custom view, create a class that extends the [[ItemView|ItemView]] interface:\nimport { ItemView, WorkspaceLeaf } from 'obsidian'; export const VIEW_TYPE_EXAMPLE = 'example-view'; export class ExampleView extends ItemView { constructor(leaf: WorkspaceLeaf) { super(leaf); } getViewType() { return VIEW_TYPE_EXAMPLE; } getDisplayText() { return 'Example view'; } async onOpen() { const container = this.contentEl; container.empty(); container.createEl('h4', { text: 'Example view' }); } async onClose() { // Nothing to clean up. } } [!note] For more information on how to use the createEl() method, refer to [[HTML elements]].\nEach view is uniquely identified by a text string and several operations require that you specify the view you’d like to use. Extracting it to a constant, VIEW_TYPE_EXAMPLE, is a good idea—as you will see later in this guide.\ngetViewType() returns a unique identifier for the view. getDisplayText() returns a human-friendly name for the view. onOpen() is called when the view is opened within a new leaf and is responsible for building the content of your view. onClose() is called when the view should close and is responsible for cleaning up any resources used by the view. Custom views need to be registered when the plugin is enabled, and cleaned up when the plugin is disabled:\nimport { Plugin, WorkspaceLeaf } from 'obsidian'; import { ExampleView, VIEW_TYPE_EXAMPLE } from './view'; export default class ExamplePlugin extends Plugin { async onload() { this.registerView( VIEW_TYPE_EXAMPLE, (leaf) =\u003e new ExampleView(leaf) ); this.addRibbonIcon('dice', 'Activate view', () =\u003e { this.activateView(); }); } async onunload() { } async activateView() { const { workspace } = this.app; let leaf: WorkspaceLeaf | null = null; const leaves = workspace.getLeavesOfType(VIEW_TYPE_EXAMPLE); if (leaves.length \u003e 0) { // A leaf with our view already exists, use that leaf = leaves[0]; } else { // Our view could not be found in the workspace, create a new leaf // in the right sidebar for it leaf = workspace.getRightLeaf(false); await leaf.setViewState({ type: VIEW_TYPE_EXAMPLE, active: true }); } // \"Reveal\" the leaf in case it is in a collapsed sidebar workspace.revealLeaf(leaf); } } The second argument to [[registerView|registerView()]] is a factory function that returns an instance of the view you want to register.\n[!warning] Never manage references to views in your plugin. Obsidian may call the view factory function multiple times. Avoid side effects in your view, and use getLeavesOfType() whenever you need to access your view instances.\nthis.app.workspace.getLeavesOfType(VIEW_TYPE_EXAMPLE).forEach((leaf) =\u003e { if (leaf.view instanceof ExampleView) { // Access your view instance. } }); ","categories":"","description":"","excerpt":"Views determine how Obsidian displays content. The file explorer, …","ref":"/plugins/user-interface/views/","tags":"","title":""},{"body":"뷰(Views)는 Obsidian이 콘텐츠를 표시하는 방법을 결정합니다. 파일 탐색기, 그래프 뷰, 마크다운 뷰는 모두 뷰의 예시이지만, 플러그인에 맞는 방식으로 콘텐츠를 표시하는 사용자 정의 뷰를 만들 수도 있습니다.\n사용자 정의 뷰를 만들려면 [[ItemView|ItemView]] 인터페이스를 확장하는 클래스를 만듭니다:\nimport { ItemView, WorkspaceLeaf } from 'obsidian'; export const VIEW_TYPE_EXAMPLE = 'example-view'; export class ExampleView extends ItemView { constructor(leaf: WorkspaceLeaf) { super(leaf); } getViewType() { return VIEW_TYPE_EXAMPLE; } getDisplayText() { return 'Example view'; } async onOpen() { const container = this.contentEl; container.empty(); container.createEl('h4', { text: 'Example view' }); } async onClose() { // 정리할 것이 없습니다. } } [!note] createEl() 메소드 사용 방법에 대한 자세한 내용은 [[HTML elements]]를 참조하세요.\n각 뷰는 텍스트 문자열로 고유하게 식별되며, 여러 작업에서 사용하려는 뷰를 지정해야 합니다. 이 가이드의 뒷부분에서 보게 될 것처럼, 이를 상수 VIEW_TYPE_EXAMPLE로 추출하는 것이 좋습니다.\ngetViewType()은 뷰의 고유 식별자를 반환합니다. getDisplayText()는 뷰의 사람이 읽기 쉬운 이름을 반환합니다. onOpen()은 새 리프(leaf) 내에서 뷰가 열릴 때 호출되며 뷰의 콘텐츠를 빌드하는 역할을 합니다. onClose()는 뷰가 닫혀야 할 때 호출되며 뷰에서 사용하는 모든 리소스를 정리하는 역할을 합니다. 사용자 정의 뷰는 플러그인이 활성화될 때 등록되고 플러그인이 비활성화될 때 정리되어야 합니다:\nimport { Plugin, WorkspaceLeaf } from 'obsidian'; import { ExampleView, VIEW_TYPE_EXAMPLE } from './view'; export default class ExamplePlugin extends Plugin { async onload() { this.registerView( VIEW_TYPE_EXAMPLE, (leaf) =\u003e new ExampleView(leaf) ); this.addRibbonIcon('dice', 'Activate view', () =\u003e { this.activateView(); }); } async onunload() { } async activateView() { const { workspace } = this.app; let leaf: WorkspaceLeaf | null = null; const leaves = workspace.getLeavesOfType(VIEW_TYPE_EXAMPLE); if (leaves.length \u003e 0) { // 우리 뷰가 있는 리프가 이미 존재하므로 그것을 사용합니다. leaf = leaves[0]; } else { // 작업 공간에서 우리 뷰를 찾을 수 없으므로 // 오른쪽 사이드바에 새 리프를 만듭니다. leaf = workspace.getRightLeaf(false); await leaf.setViewState({ type: VIEW_TYPE_EXAMPLE, active: true }); } // 축소된 사이드바에 있는 경우 리프를 \"드러냅니다\". workspace.revealLeaf(leaf); } } [[registerView|registerView()]]의 두 번째 인수는 등록하려는 뷰의 인스턴스를 반환하는 팩토리 함수입니다.\n[!warning] 플러그인에서 뷰에 대한 참조를 절대 관리하지 마세요. Obsidian은 뷰 팩토리 함수를 여러 번 호출할 수 있습니다. 뷰에서 부작용을 피하고, 뷰 인스턴스에 접근해야 할 때마다 getLeavesOfType()을 사용하세요.\nthis.app.workspace.getLeavesOfType(VIEW_TYPE_EXAMPLE).forEach((leaf) =\u003e { if (leaf.view instanceof ExampleView) { // 뷰 인스턴스에 접근합니다. } }); ","categories":"","description":"","excerpt":"뷰(Views)는 Obsidian이 콘텐츠를 표시하는 방법을 결정합니다. 파일 탐색기, 그래프 뷰, 마크다운 뷰는 모두 뷰의  …","ref":"/ko/plugins/user-interface/views/","tags":"","title":""},{"body":"Obsidian lets you configure what content is visible to you at any given time. Hide the file explorer when you don’t need it, display multiple documents side by side, or show an outline of your document while you’re working on it. The configuration of visible content within your application window is known as the workspace.\nThe workspace is implemented as a tree data structure, where each node in the tree is referred to as a [[WorkspaceItem|workspace item]]. There are two types of workspace items: [[WorkspaceParent|parents]] and [[WorkspaceLeaf|leaves]]. The main difference is that parent items can contain child items, including other parent items, whereas leaf items can’t contain any workspace items at all.\nThere are two types of parent items, [[WorkspaceSplit|splits]] and [[WorkspaceTabs|tabs]], which determine how the children are presented to the user:\nflowchart TD split{Split} split --\u003e A((Leaf)) split --\u003e B((Leaf)) split --\u003e C((Leaf)) tabs{Tabs} tabs --\u003e X((Leaf)) tabs --\u003e Y((Leaf)) tabs --\u003e Z((Leaf)) A split item lays out its child items one after another along a vertical or horizontal direction. A tabs item only displays one child item at a time and hides the others. The workspace has three special split items under it: left, right, and root. The following diagram shows a example of what a typical workspace could look like:\nflowchart TD Workspace --\u003e Left{Left split} Workspace --\u003e Root{Root split} Workspace --\u003e Right{Right split} Left --\u003e leftTabs{Tabs} leftTabs --\u003e A((Leaf)) leftTabs --\u003e B((Leaf)) Root --\u003e C{Split} Root --\u003e D((Leaf)) C --\u003e E((Leaf)) C --\u003e F((Leaf)) Right --\u003e rightTabs{Tabs} rightTabs --\u003e I((Leaf)) rightTabs --\u003e J((Leaf)) rightTabs --\u003e K((Leaf)) A leaf is a window that can display content in different ways. The type of leaf determines how content is displayed, and correspond to a specific view. For example, a leaf of type graph displays the graph view.\nSplits By default, the direction of the root split is set to vertical. When you create a new leaf to it, Obsidian creates a new column in the user interface. When you split a leaf, the resulting leaves are added to a new split item. While there’s no defined limit to the number of levels you can create under the root split, in practice their usefulness diminish for each level.\nflowchart TD rootBefore{\"Root split\\n(before)\"} rootBefore --\u003e leaf1((Leaf)) rootBefore --\u003e leaf2((Leaf)) rootAfter{\"Root split\\n(after)\"} rootAfter --\u003e split{Split} rootAfter --\u003e leaf3((Leaf)) split --\u003e leaf4((Leaf)) split --\u003e leaf5((Leaf)) The left and right splits work a little differently. When you split a leaf in the side docks, Obsidian generates a new tabs item and adds the new leaf under it. Effectively, this means they can only have three levels of workspace items at any time, and any direct children must be tabs items.\nflowchart TD split1{\"Right split\\n(before)\"} tabs1{Tabs} leaf1((Leaf)) leaf2((Leaf)) split1 --\u003e tabs1 tabs1 --\u003e leaf1 tabs1 --\u003e leaf2 split2{\"Right split\\n(after)\"} tabs2{Tabs} tabs3{Tabs} leaf3((Leaf)) leaf4((Leaf)) leaf5((Leaf)) split2 --\u003e tabs2 tabs2 --\u003e leaf3 tabs2 --\u003e leaf4 split2 --\u003e tabs3 tabs3 --\u003e leaf5 Inspect the workspace You can access the workspace through the [[App|App]] object. The following example prints the type of every leaf in the workspace:\nimport { Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { this.addRibbonIcon('dice', 'Print leaf types', () =\u003e { this.app.workspace.iterateAllLeaves((leaf) =\u003e { console.log(leaf.getViewState().type); }); }); } } Leaf lifecycle Plugins can add leaves of any type to the workspace, as well as define new leaf types through [[Views|custom views]]. Here are a few ways to add a leaf to the workspace. For more ways, refer to [[Reference/TypeScript API/Workspace|Workspace]].\nIf you want to add a new leaf in the root split, use [[getLeaf|getLeaf(true)]]. If you want to add a new leaf in any of the side bars, use [[getLeftLeaf|getLeftLeaf()]] and [[getRightLeaf|getRightLeaf()]]. Both let you decide whether to add the leaf to a new split. You can also explicitly add the leaf in the split of your choice, using [[createLeafInParent|createLeafInParent()]].\nUnless explicitly removed, any leaves that a plugin add to the workspace remain even after the plugin is disabled. Plugins are responsible for removing any leaves they add to the workspace.\nTo remove a leaf from the workspace, call [[detach|detach()]] on the leaf you want to remove. You can also remove all leaves of a certain type, by using [[detachLeavesOfType|detachLeavesOfType()]].\nLeaf groups You can create linked views by assigning multiple leaves to the same group, using [[setGroup|setGroup()]].\nleaves.forEach((leaf) =\u003e leaf.setGroup('group1'); ","categories":"","description":"","excerpt":"Obsidian lets you configure what content is visible to you at any …","ref":"/plugins/user-interface/workspace/","tags":"","title":""},{"body":"Obsidian은 언제든지 어떤 콘텐츠를 볼 수 있는지 구성할 수 있게 해줍니다. 필요 없을 때 파일 탐색기를 숨기거나, 여러 문서를 나란히 표시하거나, 작업하는 동안 문서의 개요를 표시할 수 있습니다. 애플리케이션 창 내에서 보이는 콘텐츠의 구성을 작업 공간(workspace) 이라고 합니다.\n작업 공간은 트리 데이터 구조로 구현되며, 트리의 각 노드는 [[WorkspaceItem|작업 공간 항목]]이라고 합니다. 작업 공간 항목에는 [[WorkspaceParent|부모]]와 [[WorkspaceLeaf|리프]] 두 가지 유형이 있습니다. 주요 차이점은 부모 항목은 다른 부모 항목을 포함한 자식 항목을 포함할 수 있지만, 리프 항목은 어떤 작업 공간 항목도 포함할 수 없다는 것입니다.\n부모 항목에는 [[WorkspaceSplit|분할]]과 [[WorkspaceTabs|탭]] 두 가지 유형이 있으며, 이는 자식이 사용자에게 어떻게 표시되는지를 결정합니다:\nflowchart TD\rsplit{Split}\rsplit --\u003e A((Leaf))\rsplit --\u003e B((Leaf))\rsplit --\u003e C((Leaf))\rtabs{Tabs}\rtabs --\u003e X((Leaf))\rtabs --\u003e Y((Leaf))\rtabs --\u003e Z((Leaf)) 분할 항목은 자식 항목을 수직 또는 수평 방향으로 차례로 배치합니다. 탭 항목은 한 번에 하나의 자식 항목만 표시하고 나머지는 숨깁니다. 작업 공간에는 왼쪽, 오른쪽, _루트_라는 세 가지 특별한 분할 항목이 있습니다. 다음 다이어그램은 일반적인 작업 공간이 어떻게 보일 수 있는지 보여주는 예입니다:\nflowchart TD\rWorkspace --\u003e Left{Left split}\rWorkspace --\u003e Root{Root split}\rWorkspace --\u003e Right{Right split}\rLeft --\u003e leftTabs{Tabs}\rleftTabs --\u003e A((Leaf))\rleftTabs --\u003e B((Leaf))\rRoot --\u003e C{Split}\rRoot --\u003e D((Leaf))\rC --\u003e E((Leaf))\rC --\u003e F((Leaf))\rRight --\u003e rightTabs{Tabs}\rrightTabs --\u003e I((Leaf))\rrightTabs --\u003e J((Leaf))\rrightTabs --\u003e K((Leaf)) 리프는 다양한 방식으로 콘텐츠를 표시할 수 있는 창입니다. 리프의 유형은 콘텐츠가 표시되는 방식을 결정하며, 특정 _뷰_에 해당합니다. 예를 들어, graph 유형의 리프는 그래프 뷰를 표시합니다.\n분할(Splits) 기본적으로 루트 분할의 방향은 수직으로 설정됩니다. 여기에 새 리프를 만들면 Obsidian은 사용자 인터페이스에 새 열을 만듭니다. 리프를 분할하면 결과 리프가 새 분할 항목에 추가됩니다. 루트 분할 아래에 만들 수 있는 수준의 수에는 정의된 제한이 없지만, 실제로는 각 수준마다 유용성이 감소합니다.\nflowchart TD\rrootBefore{\"Root split\\n(before)\"}\rrootBefore --\u003e leaf1((Leaf))\rrootBefore --\u003e leaf2((Leaf))\rrootAfter{\"Root split\\n(after)\"}\rrootAfter --\u003e split{Split}\rrootAfter --\u003e leaf3((Leaf))\rsplit --\u003e leaf4((Leaf))\rsplit --\u003e leaf5((Leaf)) 왼쪽 및 오른쪽 분할은 약간 다르게 작동합니다. 사이드 도크에서 리프를 분할하면 Obsidian은 새 탭 항목을 생성하고 그 아래에 새 리프를 추가합니다. 사실상, 이는 언제든지 세 가지 수준의 작업 공간 항목만 가질 수 있으며, 모든 직접 자식은 탭 항목이어야 함을 의미합니다.\nflowchart TD\rsplit1{\"Right split\\n(before)\"}\rtabs1{Tabs}\rleaf1((Leaf))\rleaf2((Leaf))\rsplit1 --\u003e tabs1\rtabs1 --\u003e leaf1\rtabs1 --\u003e leaf2\rsplit2{\"Right split\\n(after)\"}\rtabs2{Tabs}\rtabs3{Tabs}\rleaf3((Leaf))\rleaf4((Leaf))\rleaf5((Leaf))\rsplit2 --\u003e tabs2\rtabs2 --\u003e leaf3\rtabs2 --\u003e leaf4\rsplit2 --\u003e tabs3\rtabs3 --\u003e leaf5 작업 공간 검사하기 [[App|App]] 객체를 통해 작업 공간에 접근할 수 있습니다. 다음 예제는 작업 공간의 모든 리프 유형을 출력합니다:\nimport { Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { this.addRibbonIcon('dice', 'Print leaf types', () =\u003e { this.app.workspace.iterateAllLeaves((leaf) =\u003e { console.log(leaf.getViewState().type); }); }); } } 리프 생명주기 플러그인은 작업 공간에 모든 유형의 리프를 추가할 수 있으며, [[Views|사용자 정의 뷰]]를 통해 새 리프 유형을 정의할 수도 있습니다. 작업 공간에 리프를 추가하는 몇 가지 방법은 다음과 같습니다. 더 많은 방법은 [[Reference/TypeScript API/Workspace|Workspace]]를 참조하세요.\n루트 분할에 새 리프를 추가하려면 [[getLeaf|getLeaf(true)]]를 사용하세요. 사이드바 중 하나에 새 리프를 추가하려면 [[getLeftLeaf|getLeftLeaf()]] 및 [[getRightLeaf|getRightLeaf()]]를 사용하세요. 둘 다 새 분할에 리프를 추가할지 여부를 결정할 수 있습니다. [[createLeafInParent|createLeafInParent()]]를 사용하여 선택한 분할에 명시적으로 리프를 추가할 수도 있습니다.\n명시적으로 제거하지 않는 한, 플러그인이 작업 공간에 추가한 모든 리프는 플러그인이 비활성화된 후에도 남아 있습니다. 플러그인은 작업 공간에 추가한 모든 리프를 제거할 책임이 있습니다.\n작업 공간에서 리프를 제거하려면 제거하려는 리프에서 [[detach|detach()]]를 호출하세요. [[detachLeavesOfType|detachLeavesOfType()]]을 사용하여 특정 유형의 모든 리프를 제거할 수도 있습니다.\n리프 그룹 [[setGroup|setGroup()]]을 사용하여 여러 리프를 동일한 그룹에 할당하여 연결된 뷰를 만들 수 있습니다.\nleaves.forEach((leaf) =\u003e leaf.setGroup('group1'); ","categories":"","description":"","excerpt":"Obsidian은 언제든지 어떤 콘텐츠를 볼 수 있는지 구성할 수 있게 해줍니다. 필요 없을 때 파일 탐색기를 숨기거나, …","ref":"/ko/plugins/user-interface/workspace/","tags":"","title":""},{"body":"Each collection of notes in Obsidian is known as a Vault. A Vault consists of a folder, and any sub-folders within it.\nWhile your plugin can access the file system like any other Node.js application, the [[Reference/TypeScript API/Vault|Vault]] module aims to make it easier to work with files and folders within a Vault.\nThe following example recursively prints the paths of all Markdown files in a Vault:\nconst files = this.app.vault.getMarkdownFiles() for (let i = 0; i \u003c files.length; i++) { console.log(files[i].path); } [!tip] If you want to list all files, and not just Markdown documents, use [[getFiles|getFiles()]] instead.\nRead files There are two methods for reading the content of a file: [[Reference/TypeScript API/Vault/read|read()]] and [[cachedRead|cachedRead()]].\nIf you only want to display the content to the user, then use cachedRead() to avoid reading the file from disk multiple times. If you want to read the content, change it, and then write it back to disk, then use read() to avoid potentially overwriting the file with a stale copy. [!info] The only difference between cachedRead() and read() is when the file was modified outside of Obsidian just before the plugin reads it. As soon as the file system notifies Obsidian that the file has changed from the outside, cachedRead() behaves exactly like read(). Similarly, if you save the file within Obsidian, the read cache is flushed as well.\nThe following example reads the content of all Markdown files in the Vault and returns the average document size:\nimport { Notice, Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { this.addRibbonIcon('info', 'Calculate average file length', async () =\u003e { const fileLength = await this.averageFileLength(); new Notice(`The average file length is ${fileLength} characters.`); }); } async averageFileLength(): Promise\u003cnumber\u003e { const { vault } = this.app; const fileContents: string[] = await Promise.all( vault.getMarkdownFiles().map((file) =\u003e vault.cachedRead(file)) ); let totalLength = 0; fileContents.forEach((content) =\u003e { totalLength += content.length; }); return totalLength / fileContents.length; } } Modify files To write text content to an existing file, use [[modify|Vault.modify()]].\nfunction writeCurrentDate(vault: Vault, file: TFile): Promise\u003cvoid\u003e { return vault.modify(file, `Today is ${new Intl.DateTimeFormat().format(new Date())}.`); } If you want to modify a file based on its current content, use [[process|Vault.process()]] instead. The second argument is a callback that provides the current file content and returns the modified content.\n// emojify replaces all occurrences of :) with 🙂. function emojify(vault: Vault, file: TFile): Promise\u003cstring\u003e { return vault.process(file, (data) =\u003e { return data.replace(':)', '🙂'); }) } Vault.process() is an abstraction on top of [[Reference/TypeScript API/Vault/read|Vault.read()]] and [[modify|Vault.modify()]] that guarantees that the file doesn’t change between reading the current content and writing the updated content. Always prefer Vault.process() over Vault.read()/Vault.modify() to avoid unintentional loss of data.\nAsynchronous modifications [[process|Vault.process()]] only supports synchronous modifications. If you need to modify a file asynchronously:\nRead the file using [[cachedRead|Vault.cachedRead()]]. Perform the async operations. Update the file using [[Reference/TypeScript API/Vault/process|Vault.process()]]. Remember to check that the data in the process() callback is the same as the data returned by cachedRead(). If they aren’t the same, that means that the file was changed by a different process, and you may want to ask the user for confirmation, or try again.\nDelete files There are two methods to delete a file, [[delete|delete()]], and [[trash|trash()]]. Which one you should use depends on if you want to allow the user to change their mind.\ndelete() removes the file without a trace. trash() moves the file to the trash bin. When you use trash(), you have the option to move the file to the system’s trash bin, or to a local .trash folder at the root of the user’s Vault.\nIs it a file or folder? Some operations return or accept a [[TAbstractFile|TAbstractFile]] object, which can be either a file or a folder. Always check the concrete type of a TAbstractFile before you use it.\nconst folderOrFile = this.app.vault.getAbstractFileByPath('folderOrFile'); if (folderOrFile instanceof TFile) { console.log('It\\'s a file!'); } else if (folderOrFile instanceof TFolder) { console.log('It\\'s a folder!'); } ","categories":"","description":"","excerpt":"Each collection of notes in Obsidian is known as a Vault. A Vault …","ref":"/plugins/vault/","tags":"","title":""},{"body":"Obsidian에서 노트들의 모음을 볼트(Vault)라고 합니다. 볼트는 하나의 폴더와 그 하위 폴더들로 구성됩니다.\n플러그인은 다른 Node.js 애플리케이션처럼 파일 시스템에 접근할 수 있지만, [[Reference/TypeScript API/Vault|Vault]] 모듈은 볼트 내의 파일과 폴더를 더 쉽게 다룰 수 있도록 도와줍니다.\n다음 예제는 볼트 내의 모든 마크다운 파일 경로를 재귀적으로 출력합니다:\nconst files = this.app.vault.getMarkdownFiles() for (let i = 0; i \u003c files.length; i++) { console.log(files[i].path); } [!tip] 마크다운 문서뿐만 아니라 모든 파일을 나열하려면 [[getFiles|getFiles()]]를 사용하세요.\n파일 읽기 파일 내용을 읽는 두 가지 메서드가 있습니다: [[Reference/TypeScript API/Vault/read|read()]]와 [[cachedRead|cachedRead()]].\n내용을 사용자에게 표시만 하려면 cachedRead()를 사용하여 디스크에서 여러 번 읽는 것을 피하세요. 내용을 읽고 변경한 후 디스크에 다시 쓰려면 read()를 사용하여 오래된 복사본으로 파일을 덮어쓰는 것을 피하세요. [!info] cachedRead()와 read()의 유일한 차이점은 플러그인이 파일을 읽기 직전에 Obsidian 외부에서 파일이 수정되었을 때입니다. 파일 시스템이 Obsidian에 외부에서 파일이 변경되었음을 알리자마자 cachedRead()는 read()와 똑같이 동작합니다. 마찬가지로 Obsidian 내에서 파일을 저장하면 읽기 캐시도 플러시됩니다.\n다음 예제는 볼트 내의 모든 마크다운 파일 내용을 읽고 평균 문서 크기를 반환합니다:\nimport { Notice, Plugin } from 'obsidian'; export default class ExamplePlugin extends Plugin { async onload() { this.addRibbonIcon('info', '파일 평균 길이 계산', async () =\u003e { const fileLength = await this.averageFileLength(); new Notice(`파일 평균 길이는 ${fileLength}자 입니다.`); }); } async averageFileLength(): Promise\u003cnumber\u003e { const { vault } = this.app; const fileContents: string[] = await Promise.all( vault.getMarkdownFiles().map((file) =\u003e vault.cachedRead(file)) ); let totalLength = 0; fileContents.forEach((content) =\u003e { totalLength += content.length; }); return totalLength / fileContents.length; } } 파일 수정 기존 파일에 텍스트 내용을 쓰려면 [[modify|Vault.modify()]]를 사용하세요.\nfunction writeCurrentDate(vault: Vault, file: TFile): Promise\u003cvoid\u003e { return vault.modify(file, `오늘은 ${new Intl.DateTimeFormat().format(new Date())}입니다.`); } 파일의 현재 내용을 기반으로 수정하려면 [[process|Vault.process()]]를 사용하세요. 두 번째 인자는 현재 파일 내용을 제공하고 수정된 내용을 반환하는 콜백입니다.\n// emojify는 모든 :)를 🙂로 바꿉니다. function emojify(vault: Vault, file: TFile): Promise\u003cstring\u003e { return vault.process(file, (data) =\u003e { return data.replace(':)', '🙂'); }) } Vault.process()는 [[Reference/TypeScript API/Vault/read|Vault.read()]]와 [[modify|Vault.modify()]] 위에 구축된 추상화로, 현재 내용을 읽고 업데이트된 내용을 쓰는 사이에 파일이 변경되지 않음을 보장합니다. 의도하지 않은 데이터 손실을 피하기 위해 항상 Vault.process()를 Vault.read()/Vault.modify()보다 선호하세요.\n비동기 수정 [[process|Vault.process()]]는 동기식 수정만 지원합니다. 파일을 비동기적으로 수정해야 하는 경우:\n[[cachedRead|Vault.cachedRead()]]로 파일을 읽으세요. 비동기 작업을 수행하세요. [[Reference/TypeScript API/Vault/process|Vault.process()]]로 파일을 업데이트하세요. process() 콜백의 data가 cachedRead()가 반환한 데이터와 같은지 확인하는 것을 잊지 마세요. 같지 않다면 다른 프로세스에 의해 파일이 변경된 것이므로 사용자에게 확인을 요청하거나 다시 시도할 수 있습니다.\n파일 삭제 파일을 삭제하는 두 가지 메서드가 있습니다: [[delete|delete()]]와 [[trash|trash()]]. 사용자가 마음을 바꿀 수 있도록 허용할지 여부에 따라 사용할 메서드가 달라집니다.\ndelete()는 흔적 없이 파일을 제거합니다. trash()는 파일을 휴지통으로 이동합니다. trash()를 사용할 때는 시스템의 휴지통으로 이동할지, 아니면 사용자 볼트 루트의 .trash 폴더로 이동할지 선택할 수 있습니다.\n파일인가 폴더인가? 일부 작업은 파일이나 폴더일 수 있는 [[TAbstractFile|TAbstractFile]] 객체를 반환하거나 받아들입니다. TAbstractFile을 사용하기 전에 항상 구체적인 타입을 확인하세요.\nconst folderOrFile = this.app.vault.getAbstractFileByPath('folderOrFile'); if (folderOrFile instanceof TFile) { console.log('파일입니다!'); } else if (folderOrFile instanceof TFolder) { console.log('폴더입니다!'); } ","categories":"","description":"","excerpt":"Obsidian에서 노트들의 모음을 볼트(Vault)라고 합니다. 볼트는 하나의 폴더와 그 하위 폴더들로 구성됩니다.\n플러그인 …","ref":"/ko/plugins/vault/","tags":"","title":""},{"body":"The Obsidian app uses Cascading Style Sheets (CSS) to control the design of the user interface. CSS is the same markup language used for websites and web-based apps, which means you can find many resources online to help you learn how to use and edit CSS.\nObsidian includes hundreds of [[CSS variables]] that enable consistently beautiful user interfaces.\nFor plugins By using the built-in CSS variables for your own custom elements, you can create native-looking user interfaces in your plugin that look beautiful and are compatible with community themes.\nstyles.css:\n.todo-list { background-color: var(--background-secondary); } For themes and snippets By overriding the default values for the Obsidian CSS variables, you can create beautiful themes without the need for complex CSS selectors.\ntheme.css:\n.theme-dark { --background-primary: #18004F; --background-secondary: #220070; } .theme-light { --background-primary: #ECE4FF; --background-secondary: #D9C9FF; } To learn more about how to build a theme using CSS variables, refer to [[Build a theme]].\n","categories":"","description":"","excerpt":"The Obsidian app uses Cascading Style Sheets (CSS) to control the …","ref":"/reference/css-variables/about-styling/","tags":"","title":""},{"body":"Obsidian 앱은 Cascading Style Sheets(CSS)를 사용하여 사용자 인터페이스의 디자인을 제어합니다. CSS는 웹사이트 및 웹 기반 앱에 사용되는 것과 동일한 마크업 언어이므로 온라인에서 CSS 사용 및 편집 방법을 배우는 데 도움이 되는 많은 리소스를 찾을 수 있습니다.\nObsidian에는 일관되게 아름다운 사용자 인터페이스를 가능하게 하는 수백 개의 [[CSS variables]]가 포함되어 있습니다.\n플러그인용 자신만의 사용자 정의 요소에 내장된 CSS 변수를 사용하면 플러그인에서 아름답고 커뮤니티 테마와 호환되는 네이티브 느낌의 사용자 인터페이스를 만들 수 있습니다.\nstyles.css:\n.todo-list { background-color: var(--background-secondary); } 테마 및 스니펫용 Obsidian CSS 변수의 기본값을 재정의하여 복잡한 CSS 선택자 없이도 아름다운 테마를 만들 수 있습니다.\ntheme.css:\n.theme-dark { --background-primary: #18004F; --background-secondary: #220070; } .theme-light { --background-primary: #ECE4FF; --background-secondary: #D9C9FF; } CSS 변수를 사용하여 테마를 만드는 방법에 대해 자세히 알아보려면 [[Build a theme]]을 참조하세요.\n","categories":"","description":"","excerpt":"Obsidian 앱은 Cascading Style Sheets(CSS)를 사용하여 사용자 인터페이스의 디자인을 제어합니다. …","ref":"/ko/reference/css-variables/about-styling/","tags":"","title":""},{"body":"This page lists CSS variables for buttons. For button colors, refer to [[Colors#Interactive colors|Interactive colors]].\nCSS variables Variable Description --button-radius Button radius ","categories":"","description":"","excerpt":"This page lists CSS variables for buttons. For button colors, refer to …","ref":"/reference/css-variables/components/button/","tags":"","title":""},{"body":"This page lists CSS variables for checkboxes and text inside of task lists.\nCSS variables Variable Description --checkbox-radius Radius --checkbox-size Height and width --checkbox-marker-color Marker color for the check itself --checkbox-color Background color --checkbox-color-hover Background color (hover) --checkbox-border-color Unchecked border color --checkbox-border-color-hover Unchecked border color (hover) --checklist-done-decoration Checked text decoration --checklist-done-color Checked text color --checkbox-margin-inline-start start margin ","categories":"","description":"","excerpt":"This page lists CSS variables for checkboxes and text inside of task …","ref":"/reference/css-variables/components/checkbox/","tags":"","title":""},{"body":"This page lists CSS variables for color inputs, such as the accent color picker.\nCSS variables Variable Description --swatch-radius Color swatch radius --swatch-height Color swatch height --swatch-width Color swatch width --swatch-shadow Color swatch shadow ","categories":"","description":"","excerpt":"This page lists CSS variables for color inputs, such as the accent …","ref":"/reference/css-variables/components/color-input/","tags":"","title":""},{"body":"This page lists CSS variables for dialogs. A dialog is a smaller modal that’s primarily used for confirmation.\nCSS variables Variable Description --dialog-width Dialog default width --dialog-max-width Dialog maximum width --dialog-max-height Dialog maximum height ","categories":"","description":"","excerpt":"This page lists CSS variables for dialogs. A dialog is a smaller modal …","ref":"/reference/css-variables/components/dialog/","tags":"","title":""},{"body":"Obsidian displays dragging affordances while the user drag files or tabs.\nCSS variables Variable Description --drag-ghost-background Drag ghost background color --drag-ghost-text-color Drag ghost text color ","categories":"","description":"","excerpt":"Obsidian displays dragging affordances while the user drag files or …","ref":"/reference/css-variables/components/dragging/","tags":"","title":""},{"body":"This page lists CSS variables for dropdowns and select elements.\nCSS variables Variable Description --dropdown-background Background color --dropdown-background-blend-mode Background blend mode --dropdown-background-hover Background color (hover) --dropdown-background-position Background position --dropdown-background-size Background size --dropdown-padding Padding ","categories":"","description":"","excerpt":"This page lists CSS variables for dropdowns and select elements.\nCSS …","ref":"/reference/css-variables/components/dropdowns/","tags":"","title":""},{"body":"This page lists CSS variables for indentation guides. Indentation guides visualize the indentation level in nested lists.\nCSS variables Variable Description --indentation-guide-width Indentation guide border width --indentation-guide-width-active Indentation guide border width (active) --indentation-guide-color Indentation guide border color --indentation-guide-color-active Indentation guide border color (active) --indentation-guide-editing-indent Width of the indent in edit mode --indentation-guide-reading-indent Width of the indent in read mode --indentation-guide-source-indent Width of the indent in source mode ","categories":"","description":"","excerpt":"This page lists CSS variables for indentation guides. Indentation …","ref":"/reference/css-variables/components/indentation-guides/","tags":"","title":""},{"body":"This page lists CSS variables for modals, such as the settings window and [[Dialog|dialogs]].\nCSS variables Variable Description --modal-background Modal background color --modal-width Modal default width --modal-height Modal default height --modal-max-width Modal maximum width --modal-max-height Modal maximum height --modal-max-width-narrow Narrow modal maximum width --modal-border-width Modal border thickness --modal-border-color Modal border color --modal-radius Modal radius --modal-community-sidebar-width Community plugin/theme sidebar width ","categories":"","description":"","excerpt":"This page lists CSS variables for modals, such as the settings window …","ref":"/reference/css-variables/components/modal/","tags":"","title":""},{"body":"This page lists CSS variables for multi-select inputs. For example, used in List type [[Properties]].\nCSS variables Variable Description --pill-color Pill text color --pill-color-hover Pill text color (hover) --pill-color-remove Pill text color when removing --pill-color-remove-hover Pill text color when removing (hover) --pill-decoration Pill text decoration --pill-decoration-hover Pill text decoration (hover) --pill-background Pill background color --pill-background-hover Pill background color (hover) --pill-border-color Pill border color --pill-border-color-hover Pill border color (hover) --pill-border-width Pill border width --pill-padding-x Pill left/right padding --pill-padding-y Pill top/bottom padding --pill-radius Pill corner radius --pill-weight Pill font weight ","categories":"","description":"","excerpt":"This page lists CSS variables for multi-select inputs. For example, …","ref":"/reference/css-variables/components/multi-select/","tags":"","title":""},{"body":"This page lists CSS variables for navigational items, such as files and folders in [[File explorer]].\nCSS variables Variable Description --nav-item-size Nav item font size --nav-item-color Nav item text color --nav-item-color-hover Nav item text color (hover) --nav-item-color-active Nav item text color (active) --nav-item-color-selected Nav item text color (selected) --nav-item-color-highlighted Nav item text color (highlighted) --nav-item-background-hover Nav item background color (hover) --nav-item-background-active Nav item background color (active) --nav-item-background-selected Nav item background color (selected) --nav-item-padding Nav item padding --nav-item-parent-padding Nav item padding for parent elements --nav-item-children-padding-start Nav item children start padding --nav-item-children-margin-start Nav item children start margin --nav-item-weight Nav item font weight --nav-item-weight-hover Nav item font weight (hover) --nav-item-weight-active Nav item font weight (active) --nav-item-white-space Nav item white-space --nav-indentation-guide-width Nav item indentation guide border width --nav-indentation-guide-color Nav item indentation guide border color --nav-collapse-icon-color Nav item collapse chevron color --nav-collapse-icon-color-collapsed Nav item collapse chevron color (collapsed) Navigation headings Navigation headings are used for collapsible navigation sections, such as linked mentions in the Backlinks and Outlinks plugin.\nVariable Description --nav-heading-color Nav heading text color --nav-heading-color-hover Nav heading text color (hover) --nav-heading-color-collapsed Collapsed nav heading text color --nav-heading-color-colapsed-hover Collapsed nav heading text color (hover) --nav-heading-weight Nav heading font weight --nav-heading-weight-hover Nav heading font weight (hover) ","categories":"","description":"","excerpt":"This page lists CSS variables for navigational items, such as files …","ref":"/reference/css-variables/components/navigation/","tags":"","title":""},{"body":"This page lists CSS variables for popovers and file previews.\nCSS variables Variable Description --popover-width Popover default width --popover-height Popover default height --popover-max-height Popover maximum height --popover-font-size Popover font size --popover-pdf-width PDF file preview width --popover-pdf-height PDF file preview height ","categories":"","description":"","excerpt":"This page lists CSS variables for popovers and file previews.\nCSS …","ref":"/reference/css-variables/components/popover/","tags":"","title":""},{"body":"This page lists CSS variables for prompts, such as the Quick switcher and Command palette.\nCSS variables Variable Description --prompt-input-height Prompt input height --prompt-width Prompt width --prompt-max-width Prompt max width (for narrow windows) --prompt-max-height Prompt max height --prompt-border-width Prompt border width --prompt-border-color Prompt border color ","categories":"","description":"","excerpt":"This page lists CSS variables for prompts, such as the Quick switcher …","ref":"/reference/css-variables/components/prompt/","tags":"","title":""},{"body":"This page lists CSS variables for slider controls.\nCSS variables Variable Description --slider-thumb-border-width Slider thumb border width --slider-thumb-border-color Slider thumb border color --slider-thumb-height Slider thumb height --slider-thumb-width Slider thumb width --slider-thumb-y Slider thumb Y position --slider-thumb-radius Slider thumb radius --slider-track-background Slider track background color --slider-track-height Slider track height ","categories":"","description":"","excerpt":"This page lists CSS variables for slider controls.\nCSS variables …","ref":"/reference/css-variables/components/slider/","tags":"","title":""},{"body":"This page lists CSS variables for tabs.\nCSS variables Variable Description --tab-background-active Tab background color (active tab) --tab-text-color Tab text color --tab-text-color-active Tab text color (non-focused window, active) --tab-text-color-focused Tab text color (focused window) --tab-text-color-focused-active Tab text color (focused window, active) --tab-text-color-focused-highlighted Tab text color (focused window, highlighted) --tab-text-color-focused-active-current Tab text color (focused window, current tab) --tab-font-size Tab font size --tab-font-weight Tab font weight --tab-container-background Tab container background color --tab-divider-color Tab divider color --tab-outline-color Tab outline color --tab-outline-width Tab outline width --tab-curve Tab curve radius --tab-radius Tab outer radius --tab-radius-active Tab outer radius (active tab) --tab-width Tab default width --tab-max-width Tab maximum width Tab stacks Styling for stacked tabs\nVariable Description --tab-stacked-pane-width Stacked pane width --tab-stacked-header-width Stacked header width --tab-stacked-font-size Stacked tab font size --tab-stacked-font-weight Stacked tab font weight --tab-stacked-text-align Stacked tab text alignment --tab-stacked-text-transform Stacked tab text transform --tab-stacked-text-writing-mode Stacked tab text writing mode --tab-stacked-shadow Stacked tab shadow ","categories":"","description":"","excerpt":"This page lists CSS variables for tabs.\nCSS variables Variable …","ref":"/reference/css-variables/components/tabs/","tags":"","title":""},{"body":"This page lists CSS variables for text inputs.\nCSS variables Variable Description --input-height Input height --input-radius Input radius --input-font-weight Input font weight --input-border-width Input border width ","categories":"","description":"","excerpt":"This page lists CSS variables for text inputs.\nCSS variables Variable …","ref":"/reference/css-variables/components/text-input/","tags":"","title":""},{"body":"This page lists CSS variables toggles.\nCSS variables Variable Description --toggle-border-width Toggle border width --toggle-width Toggle width --toggle-radius Toggle radius --toggle-thumb-color Toggle thumb background color --toggle-thumb-radius Toggle thumb radius --toggle-thumb-height Toggle thumb height --toggle-thumb-width Toggle thumb width --toggle-s-border-width Small toggle border width --toggle-s-width Small toggle width --toggle-s-thumb-height Small toggle thumb height --toggle-s-thumb-width Small toggle thumb width ","categories":"","description":"","excerpt":"This page lists CSS variables toggles.\nCSS variables Variable …","ref":"/reference/css-variables/components/toggle/","tags":"","title":""},{"body":"Foundations Abstracted variables for colors, spacing, typography and more\n[[Borders]] [[Colors]] [[Cursor]] [[Reference/CSS variables/Foundations/Icons|Icons]] [[Layers]] [[Radiuses]] [[Spacing]] [[Typography]] Components Interactive components used throughout the app\n[[Button]] [[Checkbox]] [[Color input]] [[Dialog]] [[Dragging]] [[Indentation guides]] [[Modal]] [[Multi-select]] [[Navigation]] [[Popover]] [[Slider]] [[Tabs]] [[Text input]] [[Toggle]] Editor Content types and variables used for editing and reading text files\n[[Block]] [[Blockquote]] [[Callout]] [[Code]] [[Embed]] [[File]] [[Footnote]] [[Headings]] [[Horizontal rule]] [[Inline title]] [[Link]] [[List]] [[Properties]] [[Table]] [[Tag]] Plugins Variables related to interface elements in core plugins\n[[Canvas]] [[File explorer]] [[Graph]] [[Search]] Window Variables related to the window chrome for the Obsidian app\n[[Divider]] [[Ribbon]] [[Scrollbar]] [[Reference/CSS variables/Window/Status bar|Status bar]] [[Window frame]] [[Reference/CSS variables/Window/Workspace|Workspace]] Obsidian Publish Variables for Obsidian Publish sites\n[[Site fonts]] [[Site header]] [[Site navigation]] [[Site components]] [[Site sidebars]] [[Site pages]] ","categories":"","description":"","excerpt":"Foundations Abstracted variables for colors, spacing, typography and …","ref":"/reference/css-variables/css-variables/","tags":"","title":""},{"body":"기초 색상, 간격, 타이포그래피 등을 위한 추상화된 변수\n[[Borders]] [[Colors]] [[Cursor]] [[Reference/CSS variables/Foundations/Icons|Icons]] [[Layers]] [[Radiuses]] [[Spacing]] [[Typography]] 구성 요소 앱 전체에서 사용되는 대화형 구성 요소\n[[Button]] [[Checkbox]] [[Color input]] [[Dialog]] [[Dragging]] [[Indentation guides]] [[Modal]] [[Multi-select]] [[Navigation]] [[Popover]] [[Slider]] [[Tabs]] [[Text input]] [[Toggle]] 에디터 텍스트 파일 편집 및 읽기에 사용되는 콘텐츠 유형 및 변수\n[[Block]] [[Blockquote]] [[Callout]] [[Code]] [[Embed]] [[File]] [[Footnote]] [[Headings]] [[Horizontal rule]] [[Inline title]] [[Link]] [[List]] [[Properties]] [[Table]] [[Tag]] 플러그인 코어 플러그인의 인터페이스 요소와 관련된 변수\n[[Canvas]] [[File explorer]] [[Graph]] [[Search]] 창 Obsidian 앱의 창 크롬과 관련된 변수\n[[Divider]] [[Ribbon]] [[Scrollbar]] [[Reference/CSS variables/Window/Status bar|Status bar]] [[Window frame]] [[Reference/CSS variables/Window/Workspace|Workspace]] Obsidian Publish Obsidian Publish 사이트용 변수\n[[Site fonts]] [[Site header]] [[Site navigation]] [[Site components]] [[Site sidebars]] [[Site pages]] ","categories":"","description":"","excerpt":"기초 색상, 간격, 타이포그래피 등을 위한 추상화된 변수\n[[Borders]] [[Colors]] [[Cursor]] …","ref":"/ko/reference/css-variables/css-variables/","tags":"","title":""},{"body":"This page lists CSS variables for rendered blocks in Live Preview.\nCSS variables Variable Description --embed-block-shadow-hover Hover shadow for rendered embed blocks in Live Preview ","categories":"","description":"","excerpt":"This page lists CSS variables for rendered blocks in Live Preview.\nCSS …","ref":"/reference/css-variables/editor/block/","tags":"","title":""},{"body":"This page lists CSS variables for blockquotes.\nCSS variables Variable Description --blockquote-background-color Blockquote background color --blockquote-border-thickness Blockquote left border thickness --blockquote-border-color Blockquote left border color --blockquote-font-style Blockquote font style (e.g. normal, italic) --blockquote-color Blockquote text color ","categories":"","description":"","excerpt":"This page lists CSS variables for blockquotes.\nCSS variables Variable …","ref":"/reference/css-variables/editor/blockquote/","tags":"","title":""},{"body":"This page lists CSS variables for Callouts.\nCSS variables Variable Description --callout-border-width Callout border width --callout-border-opacity Callout border opacity --callout-padding Callout padding --callout-radius Callout radius --callout-blend-mode Callout blend mode, allows color mixing for nested callouts --callout-title-color Callout title text color --callout-title-padding Callout title padding --callout-title-size Callout title font size --callout-title-weight Callout title weight --callout-content-padding Callout content padding --callout-content-background Callout content background color Type colors Callout types have unique icons and colors, and may have multiple aliases.\nVariable Callout type --callout-bug bug --callout-default default, note --callout-error error, danger --callout-example example --callout-fail fail, failure, missing --callout-important important --callout-info info --callout-question question, help, faq --callout-success success, check, done --callout-summary summary, abstract, tldr --callout-tip tip, hint --callout-todo todo --callout-warning warning, caution, attention --callout-quote quote, cite ","categories":"","description":"","excerpt":"This page lists CSS variables for Callouts.\nCSS variables Variable …","ref":"/reference/css-variables/editor/callout/","tags":"","title":""},{"body":"This page lists CSS variables for code.\nCSS variables Variable Description --code-background Code background color --code-white-space Code white-space --code-size Code font size Syntax highlighting [!note] Since Obsidian uses two different libraries for syntax highlighting—one for Editing view and another for Reading view—styling may not match perfectly between the two.\nVariable Description --code-normal Non-highlighted syntax --code-comment Comments --code-function Functions --code-important Important, regex --code-keyword Keywords --code-operator Operators --code-property Properties --code-punctuation Punctuation --code-string Strings --code-tag Tags, symbols, constants --code-value Values ","categories":"","description":"","excerpt":"This page lists CSS variables for code.\nCSS variables Variable …","ref":"/reference/css-variables/editor/code/","tags":"","title":""},{"body":"This page lists CSS variables for embedded files.\nCSS variables Variable Description --embed-max-height Embed max height --embed-canvas-max-height Embedded Canvas element max height --embed-background Embed background color --embed-border-end Embed end border, shorthand property --embed-border-start Embed start border, shorthand property --embed-border-top Embed top border, shorthand property --embed-border-bottom Embed bottom border, shorthand property --embed-padding Embedd padding --embed-font-style Embed font-style ","categories":"","description":"","excerpt":"This page lists CSS variables for embedded files.\nCSS variables …","ref":"/reference/css-variables/editor/embed/","tags":"","title":""},{"body":"This page lists CSS variables for open files in the editor.\nCSS variables Variable Description --file-line-width Width of a line when readable line width is turned on --file-folding-offset Width of the line offset for fold indicators --file-margins File margins --file-header-font-size File header font size --file-header-font-weight File header font weight --file-header-border File header border-bottom property --file-header-justify File header text alignment, uses justify-content ","categories":"","description":"","excerpt":"This page lists CSS variables for open files in the editor.\nCSS …","ref":"/reference/css-variables/editor/file/","tags":"","title":""},{"body":"This page lists CSS variables for footnotes.\nCSS variables Variable Description --footnote-size Footnote font size ","categories":"","description":"","excerpt":"This page lists CSS variables for footnotes.\nCSS variables Variable …","ref":"/reference/css-variables/editor/footnote/","tags":"","title":""},{"body":"This page lists CSS variables for headings.\nCSS variables Variable Description --heading-formatting Text color for Markdown heading depth syntax --heading-spacing Spacing above headings, see [[Typography]] --h1-color H1 text color --h2-color H2 text color --h3-color H3 text color --h4-color H4 text color --h5-color H5 text color --h6-color H6 text color --h1-font H1 font family --h2-font H2 font family --h3-font H3 font family --h4-font H4 font family --h5-font H5 font family --h6-font H6 font family --h1-line-height H1 line height --h2-line-height H2 line height --h3-line-height H3 line height --h4-line-height H4 line height --h5-line-height H5 line height --h6-line-height H6 line height --h1-size H1 font size --h2-size H2 font size --h3-size H3 font size --h4-size H4 font size --h5-size H5 font size --h6-size H6 font size --h1-style H1 font style --h2-style H2 font style --h3-style H3 font style --h4-style H4 font style --h5-style H5 font style --h6-style H6 font style --h1-variant H1 font variant --h2-variant H2 font variant --h3-variant H3 font variant --h4-variant H4 font variant --h5-variant H5 font variant --h6-variant H6 font variant --h1-weight H1 font weight --h2-weight H2 font weight --h3-weight H3 font weight --h4-weight H4 font weight --h5-weight H5 font weight --h6-weight H6 font weight ","categories":"","description":"","excerpt":"This page lists CSS variables for headings.\nCSS variables Variable …","ref":"/reference/css-variables/editor/headings/","tags":"","title":""},{"body":"This page lists CSS variables for horizontal rules.\nCSS variables Variable Description --hr-color Horizontal rule border color --hr-thickness Horizontal rule border thickness ","categories":"","description":"","excerpt":"This page lists CSS variables for horizontal rules.\nCSS variables …","ref":"/reference/css-variables/editor/horizontal-rule/","tags":"","title":""},{"body":"This page lists CSS variables for inline titles.\n[!note] To see inline titles, you need to enable Settings → Appearance → Show inline title.\nCSS variables Variable Description --inline-title-color Inline title text color --inline-title-font Inline title font family --inline-title-line-height Inline title line height --inline-title-size Inline title font size --inline-title-style Inline title font style --inline-title-variant Inline title font variant --inline-title-weight Inline title font weight ","categories":"","description":"","excerpt":"This page lists CSS variables for inline titles.\n[!note] To see inline …","ref":"/reference/css-variables/editor/inline-title/","tags":"","title":""},{"body":"This page lists CSS variables for links.\nObsidian supports three different types of links:\nResolved internal links link to an existing note. Unresolved internal links link to a non-existing note. External links link to an external URL or URI. CSS variables Variable Description --link-color Resolved link text color --link-color-hover Resolved link text color (hover) --link-decoration Resolved link text decoration --link-decoration-hover Resolved link text decoration (hover) --link-decoration-thickness Resolved link text decoration thickness --link-weight Link font weight --link-unresolved-color Unresolved link text color --link-unresolved-opacity Unresolved link opacity --link-unresolved-filter Unresolved link filter, e.g. hue-rotate --link-unresolved-decoration-style Unresolved link text decoration style --link-unresolved-decoration-color Unresolved link text decoration color --link-external-color External link text color --link-external-color-hover External link text color (hover) --link-external-decoration External link text decoration --link-external-decoration-hover External link text decoration (hover) ","categories":"","description":"","excerpt":"This page lists CSS variables for links.\nObsidian supports three …","ref":"/reference/css-variables/editor/link/","tags":"","title":""},{"body":"This page lists CSS variables for ordered and unordered lists.\nCSS variables Variable Description --list-indent Indentation width for nested items --list-indent-editing Indent width in Live Preview --list-indent-source Indent width in source mode --list-spacing Vertical spacing between list items --list-marker-color Marker color --list-marker-color-hover Marker color (hover) --list-marker-color-collapsed Marker color for collapsed items --list-bullet-border Bullet border --list-bullet-end-padding Padding after the bullet --list-bullet-radius Bullet radius --list-bullet-size Bullet width/height --list-bullet-transform Bullet transform property --list-numbered-style list-style-type for numbered lists ","categories":"","description":"","excerpt":"This page lists CSS variables for ordered and unordered lists.\nCSS …","ref":"/reference/css-variables/editor/list/","tags":"","title":""},{"body":"This page lists CSS variables for Properties, the YAML metadata editor for frontmatter. See also [[Checkbox]], [[Text input]] and [[Multi-select]] for variables related to the input types.\nCSS variables Properties container These variables apply to the entire Properties container.\nVariable Description --metadata-background Background color --metadata-display-editing Display in editing mode --metadata-display-reading Display in reading mode --metadata-max-width Max width --metadata-padding Padding --metadata-border-color Border color --metadata-border-radius Corner radius --metadata-border-width Border width --metadata-gap Gap between properties Individual properties These variables apply to individual properties in the list.\nVariable Description --metadata-divider-color Color of divider lines between properties --metadata-divider-color-hover Color of dividers when property (hover) --metadata-divider-color-focus Color of dividers when property (focused) --metadata-divider-width Width of divider lines --metadata-property-padding Property padding --metadata-property-radius Property corner radius --metadata-property-radius-hover Property corner radius (hover) --metadata-property-radius-focus Property corner radius (focus) --metadata-property-background Property background color --metadata-property-background-hover Property background color (hover) --metadata-property-background-active Property background color (active) --metadata-label-background-hover Property label background color (hover) --metadata-label-background-active Property label background color (active) --metadata-label-font-size Property label font size --metadata-label-font-weight Property label font weight --metadata-sidebar-label-font-size Property label font size (sidebar) --metadata-label-text-color Property label text color --metadata-label-text-color-hover Property label text color (hover) --metadata-label-width Property label width --metadata-input-height Property input height --metadata-input-text-color Property input text color --metadata-input-font-size Property input font size --metadata-sidebar-input-font-size Property input font size (sidebar) --metadata-input-background Property input background color --metadata-input-background-hover Property input background color (hover) --metadata-input-background-active Property input background color (active) ","categories":"","description":"","excerpt":"This page lists CSS variables for Properties, the YAML metadata editor …","ref":"/reference/css-variables/editor/properties/","tags":"","title":""},{"body":"This page lists CSS variables for tables.\nCSS variables Variable Description --table-background Table background color --table-border-width Table border width --table-border-color Table border color --table-cell-vertical-alignment Cell vertical alignment --table-white-space Table white-space property --table-header-background Table header background color --table-header-background-hover Table header background color (hover) --table-header-border-width Table header border width --table-header-border-color Table header border color --table-header-font Table header font family --table-header-size Table header font size --table-header-weight Table header font weight --table-header-color Table header text color --table-line-height Line height for cell text --table-text-size Cell font size --table-text-color Cell text color --table-column-max-width Column maximum width --table-column-alt-background Alternating column background color --table-column-first-border-width First column left border width --table-column-last-border-width Last column right border width --table-row-background-hover Row background color (hover) --table-row-alt-background Alternating row background color --table-row-alt-background-hover Alternating row background color (hover) --table-row-last-border-width Last row bottom border width --table-selection Selection background color --table-selection-blend-mode Selection blend mode --table-selection-border-color Selection border color --table-selection-border-width Selection border width --table-selection-border-radius Selection border radius --table-drag-handle-background Drag handle background color --table-drag-handle-background-active Drag handle background color (active) --table-drag-handle-color Drag handle icon color --table-drag-handle-color-active Drag handle icon color (active) --table-add-button-background “Add” button background color --table-add-button-border-width “Add” button border width --table-add-button-border-color “Add” button border color ","categories":"","description":"","excerpt":"This page lists CSS variables for tables.\nCSS variables Variable …","ref":"/reference/css-variables/editor/table/","tags":"","title":""},{"body":"This page lists CSS variables for tags.\nCSS variables Variable Description --tag-size Tag font size --tag-color Tag text color --tag-color-hover Tag text color (hover) --tag-decoration Tag text decoration --tag-decoration-hover Tag text decoration (hover) --tag-background Tag background color --tag-background-hover Tag background color (hover) --tag-border-color Tag border color --tag-border-color-hover Tag border color (hover) --tag-border-width Tag border width --tag-padding-x Tag left/right padding --tag-padding-y Tag top/down padding --tag-radius Tag radius --tag-weight Tag font weight ","categories":"","description":"","excerpt":"This page lists CSS variables for tags.\nCSS variables Variable …","ref":"/reference/css-variables/editor/tag/","tags":"","title":""},{"body":"Border thicknesses applied to UI elements.\nVariable Default value --border-width 1px ","categories":"","description":"","excerpt":"Border thicknesses applied to UI elements.\nVariable Default value …","ref":"/reference/css-variables/foundations/borders/","tags":"","title":""},{"body":"The Obsidian color palette defines a range of colors used in the app.\nBase colors The base colors is a neutral color palette ranging from light to dark. These values should typically only be defined by themes.\nVariable Default value (light mode) Default value (dark mode) --color-base-00 #ffffff #1e1e1e --color-base-05 #fcfcfc #212121 --color-base-10 #fafafa #242424 --color-base-20 #f6f6f6 #262626 --color-base-25 #e3e3e3 #2a2a2a --color-base-30 #e0e0e0 #363636 --color-base-35 #d4d4d4 #3f3f3f --color-base-40 #bdbdbd #555555 --color-base-50 #ababab #666666 --color-base-60 #707070 #999999 --color-base-70 #5a5a5a #bababa --color-base-100 #222222 #dadada Accent color The accent color is used to draw attention to interactive elements, such as links and primary buttons, and can be overridden by the user under Settings → Appearance in the Obsidian app.\nVariable Default value Description --accent-h 254 Accent hue --accent-s 80% Accent saturation --accent-l 68% Accent lightness [!tip] You can use CSS calculations to create a variety of shades based on the accent color.\nExtended colors Extended color variables define the broader range of colors used for status messages (errors, warnings, success), callouts, syntax highlighting, graph nodes, and Canvas elements.\nEach extended color has an additional RGB variable with a -rgb suffix that you can use to create colors with opacity, using the rgba function.\nFor example, the following snippet uses the default variable to set the text color, and the RGB variable to set a background color to red with 20% opacity.\ncolor: var(--color-red); background-color: rgba(var(--color-red-rgb), 0.2); Variable Default value (light mode) Default value (dark mode) --color-red #e93147 #fb464c --color-orange #ec7500 #e9973f --color-yellow #e0ac00 #e0de71 --color-green #08b94e #44cf6e --color-cyan #00bfbc #53dfdd --color-blue #086ddd #027aff --color-purple #7852ee #a882ff --color-pink #d53984 #fa99cd --color-red-rgb 233, 49, 71 251, 70, 76 --color-orange-rgb 236, 117, 0 233, 151, 63 --color-yellow-rgb 224, 172, 0 224, 222, 113 --color-green-rgb 8, 185, 78 68, 207, 110 --color-cyan-rgb 0, 191, 188 83, 223, 221 --color-blue-rgb 8, 109, 221 2, 122, 255 --color-purple-rgb 120, 82, 238 168, 130, 255 --color-pink-rgb 213, 57, 132 250, 153, 205 Black and white Black and white colors let you create masks with opacity.\nVariable Default value (light mode) Default value (dark mode) --mono-rgb-0 255, 255, 255 0, 0, 0 --mono-rgb-100 0, 0, 0 255, 255, 255 [!warning] Avoid changing the value of black and white variables.\nSemantic colors Semantic colors are derived from the base color palette based on their intended use.\nSurface colors Primary background Alt. primary background Secondary background Alt. secondary background Variable Description --background-primary Primary background --background-primary-alt Background for surfaces on top of primary background --background-secondary Secondary background --background-secondary-alt Background for surfaces on top of secondary background --background-modifier-hover Hovered elements --background-modifier-active-hover Active hovered elements --background-modifier-border Border color --background-modifier-border-hover Border color (hover) --background-modifier-border-focus Border color (focus) --background-modifier-error-rgb Error background, RGB value --background-modifier-error Error background --background-modifier-error-hover Error background (hover) --background-modifier-success-rgb Success background, RGB value --background-modifier-success Success background --background-modifier-message Messages background --background-modifier-form-field Form field background Interactive colors Variable Description --interactive-normal Background for standard interactive elements --interactive-hover Background for standard interactive elements (hover) --interactive-accent Background for accented interactive elements --interactive-accent-hsl Background for accented interactive elements in HSL --interactive-accent-hover Background for accented interactive elements (hover) Text colors Text foreground colors Variable Description --text-normal Normal text --text-muted Muted text --text-faint Faint text --text-on-accent Text on accent background when accent is dark --text-on-accent-inverted Text on accent background when accent is light --text-success Success text --text-warning Warning text --text-error Error text --text-accent Accent text --text-accent-hover Accent text (hover) Text background colors Variable Description --text-selection Selected text background --text-highlight-bg Highlighted text background Caret color Defines the color of the caret, the blinking text entry cursor.\nVariable Description --caret-color Caret color ","categories":"","description":"","excerpt":"The Obsidian color palette defines a range of colors used in the app. …","ref":"/reference/css-variables/foundations/colors/","tags":"","title":""},{"body":"Obsidian follows operating system conventions for cursors, which means interactive elements use the arrow cursor instead of the pointer cursor.\nVariable Default value Description --cursor default Cursor for interactive elements --cursor-link pointer Cursor for links ","categories":"","description":"","excerpt":"Obsidian follows operating system conventions for cursors, which means …","ref":"/reference/css-variables/foundations/cursor/","tags":"","title":""},{"body":"Icons communicate messages at a glance, and draw attention to important information.\nObsidian uses the Lucide icon library, which includes more than 800 icons. You can find all available icons on their website.\n[!important] Custom icons If you want to create your own icons for Obsidian, you need to follow the Icon Design Principles. You can find templates and guides for vector editors, such as Illustrator, Figma, and Inkscape.\nVariable Description --icon-size Shorthand for icon width and length --icon-stroke Shorthand for icon stroke width --icon-color Icon color --icon-color-hover Icon color (hovered) --icon-color-active Icon color (active) --icon-color-focused Icon color (focused) --icon-opacity Icon opacity --icon-opacity-hover Icon opacity (hovered) --icon-opacity-active Icon opacity (active) --clickable-icon-radius Clickable icon button radius Icon sizes Variable Default value --icon-xs 14px --icon-s 16px --icon-m 18px --icon-l 18px --icon-xl 32px --icon-xs-stroke-width 2px --icon-s-stroke-width 2px --icon-m-stroke-width 1.75px --icon-l-stroke-width 1.75px --icon-xl-stroke-width 1.25px ","categories":"","description":"","excerpt":"Icons communicate messages at a glance, and draw attention to …","ref":"/reference/css-variables/foundations/icons/","tags":"","title":""},{"body":"Layers define the depth, or z-index, of an element.\nVariable Default value --layer-cover 5 --layer-sidedock 10 --layer-status-bar 15 --layer-popover 30 --layer-slides 45 --layer-modal 50 --layer-notice 60 --layer-menu 65 --layer-tooltip 70 --layer-dragged-item 80 ","categories":"","description":"","excerpt":"Layers define the depth, or z-index, of an element.\nVariable Default …","ref":"/reference/css-variables/foundations/layers/","tags":"","title":""},{"body":"Radiuses define the rounded corners for UI elements.\nVariable Default value --radius-s 4px --radius-m 8px --radius-l 12px --radius-xl 16px ","categories":"","description":"","excerpt":"Radiuses define the rounded corners for UI elements.\nVariable Default …","ref":"/reference/css-variables/foundations/radiuses/","tags":"","title":""},{"body":"Obsidian uses a 4-pixel grid to structure UI elements. By using multiples of 4 for padding and margin, the grid provides convenient ratios for layouts and allows the interface to scale up and down across high and low DPI screens.\nTo align with the 4-pixel grid, all elements should use the predefined --size CSS variables for spacing and dimensions properties.\nEach size variable contains two numbers which represent the base and the multiple.\n--size-4-1 represents 4px (4x1) --size-4-2 represents 8px (4x2) --size-4-4 represents 16px (4x4) In addition to the 4-pixel grid, Obsidan also provides a set of variables that uses a 2-pixel grid. Use these sparingly and only when you need more fine-grained spacing.\nVariable Default value --size-2-1 2px --size-2-2 4px --size-2-3 6px --size-4-1 4px --size-4-2 8px --size-4-3 12px --size-4-4 16px --size-4-5 20px --size-4-6 24px --size-4-8 32px --size-4-9 36px --size-4-12 48px --size-4-16 64px --size-4-18 72px ","categories":"","description":"","excerpt":"Obsidian uses a 4-pixel grid to structure UI elements. By using …","ref":"/reference/css-variables/foundations/spacing/","tags":"","title":""},{"body":"Fonts Variable Description --font-interface-theme Font used for UI elements --font-text-theme Font used for text in the editor --font-monospace-theme Font used for monospaced content such as code blocks and inline code Font size Obsidian uses both relative and fixed font sizes depending on the context.\nUse --font-* (relative) variables in the editor. Use --font-ui-* (fixed) variables for UI elements. Variable Default value Description --font-text-size 16px Editor font size. Defined by the user under Appearance settings. --font-smallest 0.8em --font-smaller 0.875em --font-small 0.933em --font-ui-smaller 12px --font-ui-small 13px --font-ui-medium 15px --font-ui-larger 20px Font weight Variable Default value --font-thin 100 --font-extralight 200 --font-light 300 --font-normal 400 --font-medium 500 --font-semibold 600 --font-bold 700 --font-extrabold 800 --font-black 900 Text formatting As of Obsidian 1.6 --bold-modifier is the recommended way to change the weight of bolded text. The bold modifier value stacks on top of other font weights. This allows text which may already be bolded to have an even heavier weight, e.g. ## Bold **bolder**. Recommended values for --bold-modifier are between 100 and 300.\nVariable Description --font-weight Regular text weight --bold-modifier Added weight for bolded text --bold-weight Bold text font weight --bold-color Bold text color --italic-color Italic text color Line heights Variable Default value Description --line-height-normal 1.5 Default line height --line-height-tight 1.3 Used in search results, tree items, tooltips, and other smaller spaces Paragraph spacing Variable Description --heading-spacing Spacing above headings --p-spacing Spacing between paragraphs ","categories":"","description":"","excerpt":"Fonts Variable Description --font-interface-theme Font used for UI …","ref":"/reference/css-variables/foundations/typography/","tags":"","title":""},{"body":"This page lists CSS variables used by the Canvas plugin.\nCSS variables Variable Description --canvas-background Canvas background color --canvas-card-label-color Canvas card label text color --canvas-dot-pattern Canvas dot pattern color --canvas-color-1 Canvas card color 1 --canvas-color-2 Canvas card color 2 --canvas-color-3 Canvas card color 3 --canvas-color-4 Canvas card color 4 --canvas-color-5 Canvas card color 5 --canvas-color-6 Canvas card color 6 ","categories":"","description":"","excerpt":"This page lists CSS variables used by the Canvas plugin.\nCSS variables …","ref":"/reference/css-variables/plugins/canvas/","tags":"","title":""},{"body":"This page lists CSS variables used by the File explorer plugin. It currently shares the same variables as [[Vault profile]].\nCSS variables Variable Description --vault-profile-display display property for the vault profile --vault-profile-actions-display dsiplay property for the action buttons in the vault profile --vault-profile-font-size Font size --vault-profile-font-weight Font weight --vault-profile-color Text color --vault-profile-color-hover Text color (hover) ","categories":"","description":"","excerpt":"This page lists CSS variables used by the File explorer plugin. It …","ref":"/reference/css-variables/plugins/file-explorer/","tags":"","title":""},{"body":"This page lists CSS variables used by the Graph view plugin.\nCSS variables Variable Description --graph-controls-width Graph controls width --graph-text Node text color --graph-line Line color --graph-node Resolved node color --graph-node-unresolved Unresolved node color --graph-node-focused Focused node color --graph-node-tag Tag node color --graph-node-attachment Attachment node color ","categories":"","description":"","excerpt":"This page lists CSS variables used by the Graph view plugin.\nCSS …","ref":"/reference/css-variables/plugins/graph/","tags":"","title":""},{"body":"This page lists CSS variables used by the Search plugin.\nCSS variables Variable Description --search-clear-button-color Clear search button color --search-clear-button-size Clear search button size --search-icon-color Search magnifying glass icon color --search-icon-size Search icon size --search-result-background Search result background color ","categories":"","description":"","excerpt":"This page lists CSS variables used by the Search plugin.\nCSS variables …","ref":"/reference/css-variables/plugins/search/","tags":"","title":""},{"body":"This page lists CSS variables used by the Sync plugin.\nCSS variables Variable Description --sync-avatar-color-current-user Avatar color for current user --sync-avatar-color-1 --sync-avatar-color-2 --sync-avatar-color-3 --sync-avatar-color-4 --sync-avatar-color-5 --sync-avatar-color-6 --sync-avatar-color-7 --sync-avatar-color-8 ","categories":"","description":"","excerpt":"This page lists CSS variables used by the Sync plugin.\nCSS variables …","ref":"/reference/css-variables/plugins/sync/","tags":"","title":""},{"body":"Introduction Many of the [[CSS variables]] utilised in the Obsidian app can also be employed in Obsidian Publish (Publish), with corresponding selectors. However, to address to the differing requirements of Publish, the variables in this section were specifically created for Publish, and are to be inserted within the .published-container selector.\nSee [[Build a Publish theme]] for more details.\nIndex [[Site fonts]] [[Site header]] [[Site navigation]] [[Site components]] [[Site sidebars]] [[Site pages]] ","categories":"","description":"","excerpt":"Introduction Many of the [[CSS variables]] utilised in the Obsidian …","ref":"/reference/css-variables/publish/publish/","tags":"","title":""},{"body":"This page lists CSS variables used for Obsidian Publish site components.\nCSS variables Publish-specific variables should be defined on the .published-container.\nComponent titles Styles for the title above components such as Backlinks, Graph, Table of contents, when these components are turned on in the site settings.\nVariable Description --component-title-color Font color --component-title-font Font family --component-title-size Font size --component-title-style Font style, e.g. normal or italic --component-title-transform Text transform, e.g. uppercase --component-title-variant Font variant --component-title-weight Font weight Outline When activated in Publish settings, a table of contents is displayed in the right sidebar showing a navigable list of headings on the page.\nVariable Description --outline-heading-color Font color for inactive headings --outline-heading-color-hover Font color for hovered heading --outline-heading-color-active Font color for active heading --outline-heading-weight-active Font weight for active heading Graph The graph component can be turned on in Publish settings. More graph CSS variables for node and line colors are present in the inherited CSS.\nVariable Description --graph-height Height of the graph component ","categories":"","description":"","excerpt":"This page lists CSS variables used for Obsidian Publish site …","ref":"/reference/css-variables/publish/site-components/","tags":"","title":""},{"body":"To load remote fonts we recommend using CSS with @import or defining your fonts with @font-face and an absolute URL. Learn more.\nFor example you can use Google Fonts in your publish.css file. Here’s how you would use the font Poppins:\n/* @import must always be at the top of your publish.css file */ @import url('https://fonts.googleapis.com/css2?family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900\u0026display=swap'); body { --font-text-theme: 'Poppins'; } CSS variables Obsidian Publish shares many [[CSS variables]] with the Obsidian app. You can change these variables on the body element.\nVariable Description --font-text-size Font size for page text --font-text-theme Font family for page text --font-monospace-theme Font family for code --font-interface-theme Font family for interface elements such as navigation Publish-specific CSS variables should be defined on the .published-container. See [[Build a Publish theme]].\nVariable Description --page-title-font Font family for [[Site pages|page titles]] ","categories":"","description":"","excerpt":"To load remote fonts we recommend using CSS with @import or defining …","ref":"/reference/css-variables/publish/site-fonts/","tags":"","title":""},{"body":"The site footer contains the text “Powered by Obsidian Publish”. To hide the site footer you can set --footer-display to none.\nCSS variables Publish-specific variables should be defined on the .published-container.\nVariable Description --footer-display Footer display ","categories":"","description":"","excerpt":"The site footer contains the text “Powered by Obsidian Publish”. To …","ref":"/reference/css-variables/publish/site-footer/","tags":"","title":""},{"body":"The site header contains the site logo (if added in Publish settings), the site name, and the mobile hamburger menu if navigation is turned on.\nThe site header appears as a horizontal header at the top of the page on mobile devices and when navigation is turned off. When navigation is turned on in Publish settings, the site name and logo appear in the left sidebar.\nThis page lists CSS variables used for Obsidian Publish site header, site logo, and site name\nCSS variables Publish-specific variables should be defined on the .published-container.\nVariable Description --logo-width Logo default width --logo-height Logo default height --logo-max-width Logo max width --logo-max-height Logo max height --logo-radius Logo corner radius --header-height Height of the site header --site-name-color Site name color --site-name-color-hover Site name hovered color --site-name-font Site name font family --site-name-size Site name font size --site-name-weight Site name font weight --site-menu-icon-color Mobile menu icon color --site-menu-icon-color-hover Mobile menu hovered icon color --site-menu-icon-size Mobile menu icon size ","categories":"","description":"","excerpt":"The site header contains the site logo (if added in Publish settings), …","ref":"/reference/css-variables/publish/site-header/","tags":"","title":""},{"body":"When activated in Publish settings, navigation is placed in the left sidebar and can be styled with the following variables. Top-level items and folders can be treated differently than nested items.\nCSS variables Publish-specific variables should be defined on the .published-container.\nVariable Description --nav-collapse-icon-color Collapse icon color --nav-collapse-icon-color-hover Collapse icon color (hovered) --nav-parent-item-color Font color for folders and top-level items --nav-parent-item-color-active Font color for active top-level items --nav-parent-item-weight Font weight for top-level items --nav-item-color Font color for nested items --nav-item-color-hover Font color for hovered nested items --nav-item-color-active Font color for active nested items --nav-item-border-color Border color for nested items --nav-item-border-color-hover Border color for hovered nested items --nav-item-border-color-active Border color for active nested items --nav-item-weight-active Font weight for active nested items ","categories":"","description":"","excerpt":"When activated in Publish settings, navigation is placed in the left …","ref":"/reference/css-variables/publish/site-navigation/","tags":"","title":""},{"body":"This page lists CSS variables used for Obsidian Publish pages.\nCSS variables Publish-specific variables should be defined on the .published-container.\nPage width and padding Variable Description --page-width Width of a note when readable line width is on --page-padding Padding around a note Page title The note title displayed at the top of the page. This title can be hidden in the Publish site settings using the “Hide page title” option.\nVariable Description --page-title-color Font color --page-title-font Font family, see [[Site fonts]] --page-title-line-height Line height --page-title-size Font size --page-title-style Font style, e.g. normal or italic --page-title-variant Font variant --page-title-weight Font weight ","categories":"","description":"","excerpt":"This page lists CSS variables used for Obsidian Publish pages.\nCSS …","ref":"/reference/css-variables/publish/site-pages/","tags":"","title":""},{"body":"The left sidebar is present when [[Site navigation]] is turned on. The right sidebar is present when the Graph and/or Table of Contents [[Site components]] are turned on. When these components are turned off, the following variables have no effect.\nCSS variables Publish-specific variables should be defined on the .published-container.\nVariable Description --sidebar-left-width Width of the left sidebar --sidebar-left-background Background color of left sidebar --sidebar-left-border-width Right border width of left sidebar --sidebar-left-border-color Right border color of left sidebar --sidebar-right-width Width of the right sidebar --sidebar-right-background Background color of right sidebar --sidebar-right-border-width Left border width of right sidebar --sidebar-right-border-color Left border color of right sidebar ","categories":"","description":"","excerpt":"The left sidebar is present when [[Site navigation]] is turned on. The …","ref":"/reference/css-variables/publish/site-sidebars/","tags":"","title":""},{"body":"This page lists CSS variables for dividers and resize handles between sidebars, tabs, and split panes.\nCSS variables Variable Description --divider-color Divider border color --divider-color-hover Divider border color (hover) --divider-width Divider border width --divider-width-hover Divider border width (hover) --divider-vertical-height Divider vertical height ","categories":"","description":"","excerpt":"This page lists CSS variables for dividers and resize handles between …","ref":"/reference/css-variables/window/divider/","tags":"","title":""},{"body":"This page lists CSS variables for the Ribbon.\nCSS variables Variable Description --ribbon-background Ribbon background color --ribbon-background-collapsed Ribbon background color (collapsed sidebar) --ribbon-width Ribbon width --ribbon-padding Ribbon padding ","categories":"","description":"","excerpt":"This page lists CSS variables for the Ribbon.\nCSS variables Variable …","ref":"/reference/css-variables/window/ribbon/","tags":"","title":""},{"body":"This page lists CSS variables for non-native scrollbars.\n[!note] Custom scrollbars are only used on Windows and Linux.\nCSS variables Variable Description --scrollbar-bg Scrollbar background color --scrollbar-thumb-bg Scrollbar thumb background color --scrollbar-active-thumb-bg Scrollbar thumb background color (active) ","categories":"","description":"","excerpt":"This page lists CSS variables for non-native scrollbars.\n[!note] …","ref":"/reference/css-variables/window/scrollbar/","tags":"","title":""},{"body":"This page lists CSS variables for the Sidebar.\nCSS variables Variable Description --sidebar-markdown-font-size Font size for Markdown files in sidebars --sidebar-tab-text-display display property for tab text in sidebars ","categories":"","description":"","excerpt":"This page lists CSS variables for the Sidebar.\nCSS variables Variable …","ref":"/reference/css-variables/window/sidebar/","tags":"","title":""},{"body":"This page lists CSS variables for the Status bar.\nCSS variables Variable Description --status-bar-background Status bar background color --status-bar-border-color Status bar border color --status-bar-border-width Status bar border width --status-bar-font-size Status bar font size --status-bar-text-color Status bar text color --status-bar-position Status bar position property --status-bar-radius Status bar radius --status-bar-scroll-padding Status bar scroll padding ","categories":"","description":"","excerpt":"This page lists CSS variables for the Status bar.\nCSS variables …","ref":"/reference/css-variables/window/status-bar/","tags":"","title":""},{"body":"This page lists CSS variables for the Vault profile component, in the bottom of the primary sidebar.\nCSS variables Variable Description --vault-profile-display display property for the vault profile --vault-profile-actions-display dsiplay property for the action buttons in the vault profile --vault-profile-font-size Font size --vault-profile-font-weight Font weight --vault-profile-color Text color --vault-profile-color-hover Text color (hover) ","categories":"","description":"","excerpt":"This page lists CSS variables for the Vault profile component, in the …","ref":"/reference/css-variables/window/vault-profile/","tags":"","title":""},{"body":"This page lists CSS variables for the window frame, including the title bar.\n[!note] To see the title bar, you need to change Settings → Appearance → Window frame style to Obsidian frame.\nCSS variables Variable Description --titlebar-background Titlebar background color --titlebar-background-focused Titlebar background color (focused window) --titlebar-border-width Titlebar border width --titlebar-border-color Titlebar border color --titlebar-text-color Titlebar text color --titlebar-text-color-focused Titlebar text color (focused window) --titlebar-text-weight Titlebar font weight --header-height Default height for frame elements ","categories":"","description":"","excerpt":"This page lists CSS variables for the window frame, including the …","ref":"/reference/css-variables/window/window-frame/","tags":"","title":""},{"body":"This page lists CSS variables the workspace.\nCSS variables Variable Description --workspace-background-translucent Background for translucent windows ","categories":"","description":"","excerpt":"This page lists CSS variables the workspace.\nCSS variables Variable …","ref":"/reference/css-variables/window/workspace/","tags":"","title":""},{"body":"This page describes the schema for the manifest, manifest.json.\nProperties The following properties are available for both plugins and themes.\nProperty Type Required Description author string Yes The author’s name. minAppVersion string Yes The minimum required Obsidian version. name string Yes The display name. version string Yes The version, using Semantic Versioning in the format x.y.z. authorUrl string No A URL to the author’s website. fundingUrl string or object No A URL or multiple URLs to where the users can support your project financially. Plugin-specific properties The following properties are only available to plugins.\nProperty Type Required Description description string Yes A description of your plugin. id string Yes The ID of your plugin. isDesktopOnly boolean Yes Whether your plugin uses NodeJS or Electron APIs. [!note] For local development, the id should match the plugin’s folder name; otherwise some methods, such as onExternalSettingsChange, won’t be called.\nfundingUrl fundingUrl can either be a string with a single URL, or an object with multiple URLs.\nSingle URL:\n{ \"fundingUrl\": \"https://buymeacoffee.com\" } Multiple URLs:\n{ \"fundingUrl\": { \"Buy Me a Coffee\": \"https://buymeacoffee.com\", \"GitHub Sponsor\": \"https://github.com/sponsors\", \"Patreon\": \"https://www.patreon.com/\" } } ","categories":"","description":"","excerpt":"This page describes the schema for the manifest, manifest.json. …","ref":"/reference/manifest/","tags":"","title":""},{"body":"이 페이지는 매니페스트 manifest.json의 스키마를 설명합니다.\n속성 다음 속성은 플러그인과 테마 모두에 사용할 수 있습니다.\n속성 타입 필수 설명 author string 예 저자 이름. minAppVersion string 예 최소 필수 Obsidian 버전. name string 예 표시 이름. version string 예 유의적 버전을 사용하는 x.y.z 형식의 버전. authorUrl string 아니요 저자 웹사이트 URL. fundingUrl string 또는 object 아니요 사용자가 프로젝트를 재정적으로 지원할 수 있는 URL 또는 여러 URL. 플러그인 관련 속성 다음 속성은 플러그인에서만 사용할 수 있습니다.\n속성 타입 필수 설명 description string 예 플러그인 설명. id string 예 플러그인 ID. isDesktopOnly boolean 예 플러그인이 NodeJS 또는 Electron API를 사용하는지 여부. [!note] 로컬 개발의 경우 id는 플러그인의 폴더 이름과 일치해야 합니다. 그렇지 않으면 onExternalSettingsChange와 같은 일부 메서드가 호출되지 않습니다.\nfundingUrl fundingUrl은 단일 URL이 있는 문자열이거나 여러 URL이 있는 객체일 수 있습니다.\n단일 URL:\n{ \"fundingUrl\": \"https://buymeacoffee.com\" } 여러 URL:\n{ \"fundingUrl\": { \"Buy Me a Coffee\": \"https://buymeacoffee.com\", \"GitHub Sponsor\": \"https://github.com/sponsors\", \"Patreon\": \"https://www.patreon.com/\" } } ","categories":"","description":"","excerpt":"이 페이지는 매니페스트 manifest.json의 스키마를 설명합니다.\n속성 다음 속성은 플러그인과 테마 모두에 사용할 수 있 …","ref":"/ko/reference/manifest/","tags":"","title":""},{"body":" obsidian package Classes Class Description AbstractTextComponent App ButtonComponent CapacitorAdapter Implementation of the vault adapter for mobile devices. ColorComponent Color picker component. Values are by default 6-digit hash-prefixed hex strings like #000000. Component DropdownComponent Events ExtraButtonComponent FileManager Manage the creation, deletion and renaming of files from the UI. FileSystemAdapter Implementation of the vault adapter for desktop. HoverPopover Keymap Manages keymap lifecycle for different Scopes. MarkdownEditView This is the editor for Obsidian Mobile as well as the upcoming WYSIWYG editor. MarkdownPreviewRenderer MarkdownPreviewView MarkdownRenderChild MarkdownView Menu MenuItem MenuSeparator MetadataCache Linktext is any internal link that is composed of a path and a subpath, such as ‘My note#Heading’ Linkpath (or path) is the path part of a linktext Subpath is the heading/block ID part of a linktext. Modal MomentFormatComponent Notice Notification component. Use to present timely, high-value information. ProgressBarComponent Scope A scope receives keyboard events and binds callbacks to given hotkeys. Only one scope is active at a time, but scopes may define parent scopes (in the constructor) and inherit their hotkeys. SearchComponent Setting SliderComponent Tasks TextAreaComponent TextComponent TFile TFolder ToggleComponent Vault Work with files and folders stored inside a vault. Workspace WorkspaceFloating WorkspaceLeaf WorkspaceMobileDrawer WorkspaceRibbon WorkspaceRoot WorkspaceSidedock WorkspaceSplit WorkspaceTabs WorkspaceWindow Abstract Classes Abstract Class Description AbstractInputSuggest Attach to an \u003cinput\u003e element or a \u003cdiv contentEditable\u003e to add type-ahead support. BaseComponent EditableFileView Editor A common interface that bridges the gap between CodeMirror 5 and CodeMirror 6. EditorSuggest FileView FuzzySuggestModal ItemView MarkdownRenderer Plugin PluginSettingTab Provides a unified interface for users to configure the plugin. PopoverSuggest Base class for adding a type-ahead popover. SettingTab SuggestModal TAbstractFile This can be either a TFile or a TFolder. TextFileView This class implements a plaintext-based editable file view, which can be loaded and saved given an editor.\nNote that by default, this view only saves when it’s closing. To implement auto-save, your editor should call this.requestSave() when the content is changed.\nValueComponent View WorkspaceContainer WorkspaceItem WorkspaceParent Enumerations Enumeration Description PopoverState Functions Function Description addIcon(iconId, svgContent) Adds an icon to the library. arrayBufferToBase64(buffer) arrayBufferToHex(data) base64ToArrayBuffer(base64) debounce(cb, timeout, resetTimer) A standard debounce function. Use this to have a time-delayed function only be called once in a given timeframe. displayTooltip(newTargetEl, content, options) Manually trigger a tooltip that will appear over the provided element.\nTo display a tooltip on hover, use setTooltip() instead.\nfinishRenderMath() Flush the MathJax stylesheet. getAllTags(cache) Combines all tags from frontmatter and note content into a single array. getBlobArrayBuffer(blob) getFrontMatterInfo(content) Given the contents of a file, get information about the frontmatter of the file, including whether there is a frontmatter block, the offsets of where it starts and ends, and the frontmatter text. getIcon(iconId) Create an SVG from an iconId. Returns null if no icon associated with the iconId. getIconIds() Get the list of registered icons. getLanguage() Get the ISO code for the currently configured app language. Defaults to ’en’. See https://github.com/obsidianmd/obsidian-translations?tab=readme-ov-file#existing-languages for list of options. getLinkpath(linktext) Converts the linktext to a linkpath. hexToArrayBuffer(hex) htmlToMarkdown(html) Converts HTML to a Markdown string. iterateCacheRefs(cache, cb) Iterate links and embeds. If callback returns true, the iteration process will be interrupted. iterateRefs(refs, cb) If callback returns true, the iteration process will be interrupted. loadMathJax() Load MathJax. loadMermaid() Load Mermaid and return a promise to the global mermaid object. Can also use mermaid after this promise resolves to get the same reference. loadPdfJs() Load PDF.js and return a promise to the global pdfjsLib object. Can also use window.pdfjsLib after this promise resolves to get the same reference. loadPrism() Load Prism.js and return a promise to the global Prism object. Can also use Prism after this promise resolves to get the same reference. normalizePath(path) parseFrontMatterAliases(frontmatter) parseFrontMatterEntry(frontmatter, key) parseFrontMatterStringArray(frontmatter, key, nospaces) parseFrontMatterTags(frontmatter) parseLinktext(linktext) Parses the linktext of a wikilink into its component parts. parseYaml(yaml) prepareFuzzySearch(query) Construct a fuzzy search callback that runs on a target string. Performance may be an issue if you are running the search for more than a few thousand times. If performance is a problem, consider using prepareSimpleSearch instead. prepareSimpleSearch(query) Construct a simple search callback that runs on a target string. removeIcon(iconId) Remove a custom icon from the library. renderMatches(el, text, matches, offset) renderMath(source, display) Render some LaTeX math using the MathJax engine. Returns an HTMLElement. Requires calling finishRenderMath when rendering is all done to flush the MathJax stylesheet. renderResults(el, text, result, offset) request(request) Similar to fetch(), request a URL using HTTP/HTTPS, without any CORS restrictions. Returns the text value of the response. requestUrl(request) Similar to fetch(), request a URL using HTTP/HTTPS, without any CORS restrictions. requireApiVersion(version) Returns true if the API version is equal or higher than the requested version. Use this to limit functionality that require specific API versions to avoid crashing on older Obsidian builds. resolveSubpath(cache, subpath) Resolve the given subpath to a reference in the MetadataCache. sanitizeHTMLToDom(html) setIcon(parent, iconId) Insert an SVG into the element from an iconId. Does nothing if no icon associated with the iconId. setTooltip(el, tooltip, options) sortSearchResults(results) stringifyYaml(obj) stripHeading(heading) Normalizes headings for link matching by stripping out special characters and shrinking consecutive spaces. stripHeadingForLink(heading) Prepares headings for linking by stripping out some bad combinations of special characters that could break links. Interfaces Interface Description BlockCache BlockSubpathResult CachedMetadata CacheItem CloseableComponent A closeable component that can get dismissed via the Android ‘back’ button. Command DataAdapter Work directly with files and folders inside a vault. If possible prefer using the Vault API over this. DataWriteOptions Debouncer EditorChange EditorPosition EditorRange EditorRangeOrCaret EditorScrollInfo EditorSelection EditorSelectionOrCaret EditorSuggestContext EditorSuggestTriggerInfo EditorTransaction EmbedCache EventRef FileStats FootnoteCache FootnoteRefCache FootnoteSubpathResult FrontMatterCache FrontMatterInfo FrontmatterLinkCache FuzzyMatch HeadingCache HeadingSubpathResult Hotkey HoverLinkSource HoverParent HSL Instruction ISuggestOwner KeymapContext KeymapEventHandler KeymapInfo LinkCache ListedFiles ListItemCache LivePreviewStateType The object stored in the view plugin livePreviewState Loc Location within a Markdown document MarkdownFileInfo MarkdownPostProcessor A post processor receives an element which is a section of the preview.\nPost processors can mutate the DOM to render various things, such as mermaid graphs, latex equations, or custom controls.\nIf your post processor requires lifecycle management, for example, to clear an interval, kill a subprocess, etc when this element is removed from the app, look into MarkdownPostProcessorContext.addChild()\nMarkdownPostProcessorContext MarkdownPreviewEvents * MarkdownSectionInformation MarkdownSubView MenuPositionDef ObsidianProtocolData OpenViewState PluginManifest Metadata about a Community plugin. Point Pos Describes a text range in a Markdown document. Reference Base interface for items that point to a different location. ReferenceCache ReferenceLinkCache RequestUrlParam RequestUrlResponse RequestUrlResponsePromise RGB SearchResult SearchResultContainer SectionCache Stat SubpathResult TagCache TooltipOptions ViewState ViewStateResult WorkspaceWindowInitData Variables Variable Description apiVersion This is the API version of the app, which follows the release cycle of the desktop app. Example: ‘0.13.21’ editorEditorField Use this StateField to get a reference to the EditorView editorInfoField Use this StateField to get information about this Markdown editor, such as the associated file, or the Editor. editorLivePreviewField Use this StateField to check whether Live Preview is active editorViewField This is now deprecated - it is now mapped directly to editorInfoField, which return a MarkdownFileInfo, which may be a MarkdownView but not necessarily. livePreviewState moment Platform Type Aliases Type Alias Description Constructor EditorCommandName HexString Hex strings are 6-digit hash-prefixed rgb strings in lowercase form. Example: #ffffff IconName KeymapEventListener Return false to automatically preventDefault MarkdownViewModeType Modifier Mod = Cmd on MacOS and Ctrl on other OS Ctrl = Ctrl key for every OS Meta = Cmd on MacOS and Win key on other OS ObsidianProtocolHandler PaneType SearchMatches SearchMatchPart Text position offsets within text file. Represents a text range [from offset, to offset]. Side SplitDirection TooltipPlacement UserEvent ViewCreator ","categories":"","description":"","excerpt":" obsidian package Classes Class Description AbstractTextComponent App …","ref":"/reference/typescript-api/","tags":"","title":""},{"body":"Every new version of Obsidian may introduce new capabilities for plugins. Unfortunately, using a recently introduced plugin capability in your plugin may break installations for users that haven’t yet updated to the latest version of Obsidian. To avoid this, versions.json lets you control the plugin version based on the version of the user’s Obsidian app.\nversions.json contains a JSON object, where the key is the plugin version, and the value is the corresponding minAppVersion.\nIf a user attempts to install a plugin where the Obsidian app version is lower than the minAppVersion in [[Reference/Manifest|Manifest]], then Obsidian looks for a versions.json file at the root of the plugin repository.\nIn the following example, the user has Obsidian 1.1.0 installed, but the plugin minAppVersion is 1.2.0.\nmanifest.json:\n{ // ... \"version\": \"1.0.0\", \"minAppVersion\": \"1.2.0\" } If the user runs version 1.1.0 of the Obsidian app, Obsidian then consults the versions.json to determine whether a fallback is available.\nversions.json:\n{ \"0.1.0\": \"1.0.0\", \"0.12.0\": \"1.1.0\", } In this case, the most recent plugin version for 1.1.0 is 0.12.0.\n[!important] You don’t need to list every plugin relese in the versions.json. You only need to update versions.json if you change the minAppVersion for your plugin.\n","categories":"","description":"","excerpt":"Every new version of Obsidian may introduce new capabilities for …","ref":"/reference/versions/","tags":"","title":""},{"body":"Obsidian의 새 버전마다 플러그인을 위한 새로운 기능이 도입될 수 있습니다. 안타깝게도 플러그인에서 최근에 도입된 기능을 사용하면 아직 최신 버전의 Obsidian으로 업데이트하지 않은 사용자의 설치가 중단될 수 있습니다. 이를 방지하기 위해 versions.json을 사용하면 사용자 Obsidian 앱 버전에 따라 플러그인 버전을 제어할 수 있습니다.\nversions.json에는 JSON 객체가 포함되어 있으며, 키는 플러그인 버전이고 값은 해당 minAppVersion입니다.\n사용자가 [[Reference/Manifest|매니페스트]]의 minAppVersion보다 낮은 Obsidian 앱 버전으로 플러그인을 설치하려고 하면 Obsidian은 플러그인 저장소의 루트에서 versions.json 파일을 찾습니다.\n다음 예에서 사용자는 Obsidian 1.1.0을 설치했지만 플러그인 minAppVersion은 1.2.0입니다.\nmanifest.json:\n{ // ... \"version\": \"1.0.0\", \"minAppVersion\": \"1.2.0\" } 사용자가 Obsidian 앱 버전 1.1.0을 실행하는 경우 Obsidian은 versions.json을 참조하여 대체 버전이 있는지 확인합니다.\nversions.json:\n{ \"0.1.0\": \"1.0.0\", \"0.12.0\": \"1.1.0\", } 이 경우 1.1.0에 대한 최신 플러그인 버전은 0.12.0입니다.\n[!important] versions.json에 모든 플러그인 릴리스를 나열할 필요는 없습니다. 플러그인의 minAppVersion을 변경하는 경우에만 versions.json을 업데이트하면 됩니다.\n","categories":"","description":"","excerpt":"Obsidian의 새 버전마다 플러그인을 위한 새로운 기능이 도입될 수 있습니다. …","ref":"/ko/reference/versions/","tags":"","title":""},{"body":"In this tutorial, you’ll learn how to start developing a theme for Obsidian. Themes let you customize how Obsidian looks and feels, using CSS.\nWhat you’ll learn After you’ve completed this tutorial, you’ll be able to:\nConfigure an environment for developing Obsidian themes. Use CSS variables to change how Obsidian looks. Create a theme that supports both light and dark color schemes. Prerequisites To complete this tutorial, you’ll need:\nGit installed on your local machine. A code editor, such as Visual Studio Code. Step 1: Download the sample theme In this step, you’ll download a sample theme to the themes directory in your vault’s .obsidian directory so that Obsidian can find it.\nThe sample theme you’ll use in this tutorial is available in a GitHub repository.\nOpen a terminal window and change the project directory to the themes directory.\ncd path/to/vault/.obsidian/themes Clone the sample theme using Git.\ngit clone https://github.com/obsidianmd/obsidian-sample-theme.git \"Sample Theme\" [!tip] GitHub template repository The repository for the sample theme is a GitHub template repository, which means you can create your own repository from the sample theme. To learn how, refer to Creating a repository from a template.\nRemember to use the URL to your own repository when cloning the sample theme.\nStep 2: Enable the theme In Obsidian, open Settings. In the side menu, select Appearance. Next to Themes, select Sample Theme from the dropdown list. You’ve enabled the sample theme. Next, we’ll make some changes to it.\nStep 3: Update the manifest In this step, you’ll rename the theme by updating the manifest, manifest.json. The manifest contains information about your theme, such as its name and description.\nOpen manifest.json in your code editor.\nChange name to a human-friendly name, such as \"Disco Lights\".\nRename the theme directory under themes to the same name. The name of the theme directory must exactly match the name property in manifest.json.\nmv \"Sample Theme\" \"Disco Lights\" Restart Obsidian to load the new changes to the manifest.\nGo back to Settings → Appearance → Themes and notice that the name of the theme has been changed.\nRemember to restart Obsidian whenever you make changes to manifest.json.\nStep 4: Change the font Obsidian uses CSS variables to style the user interface. In this step, you’ll use a CSS variable to change the font in the editor.\nCreate a new note, for example “Theme Development”.\nEnter the following text into the note:\nThemes let you make [Obsidian](https://obsidian.md) look the way **you** want it. In theme.css, add the following:\nbody { --font-text-theme: Georgia, serif; } The editor displays the note using the font you defined.\nStep 5: Change the background color Themes can support both light and dark color schemes. Define your CSS variables under .theme-dark or .theme-light.\nIn theme.css, add the following:\n.theme-dark { --background-primary: #18004F; --background-secondary: #220070; } .theme-light { --background-primary: #ECE4FF; --background-secondary: #D9C9FF; } In Obsidian, open Settings.\nUnder Appearance, toggle Base color scheme between “Light” and “Dark”.\nYou’ll see that Obsidian picks the colors based on the color scheme you’ve selected. Try changing the colors to red, green, or blue for a more dramatic change.\nStep 6: Change the input hover border color The :root selector is commonly used when you want a variable to be accessible by every child element within the theme. This selector is often filled with Plugin variables.\nHere’s an example to illustrate its usage:\n[!example] Let’s consider an input field that can be found in various places within Obsidian, such as settings and note content. To define the variables specific to this input field, we can use the :root selector.\n:root { --input-focus-border-color: Highlight; --input-focus-outline: 1px solid Canvas; --input-unfocused-border-color: transparent; --input-disabled-border-color: transparent; --input-hover-border-color: black; /* Default Input Variables for Root */ } Now, let’s modify the hover border color in our CSS:\n:root { --input-hover-border-color: red; /* Change from Black to Red */ } With this update, when you hover over any input field, the border color will change to a bright red.\n[!tip] When defining styles that should remain the same for both light and dark themes, it is recommended to use the body selector.\nOnly use .theme-dark or .theme-light selectors if you want the styles to change when switching between light and dark themes.\nIt’s also important to use :root with caution and consideration. If your variable can be placed within body, .theme-dark, or .theme-light selectors instead, it is recommended to do so.\nStep 7: Discover CSS variables in use Obsidian exposes more than 400 different CSS variables for customizing different parts of the user interface. You can find a list of many of these variables under available under [[CSS variables]]\nAlternatively, you can inspect the app to find the variable that is used to style a certain element. In this step, you’ll find the CSS variable for changing the ribbon background.\nIn Obsidian, open the Developer Tools by pressing Ctrl+Shift+I (or Cmd+Option+I on macOS). Open the Sources tab. Under Page → top → obsidian.md, select app.css. Scroll to the top of app.css to find all available CSS variables. Search for variables related to the ribbon by pressing Ctrl+F (or Cmd+F on macOS) and typing \" –ribbon-\". Notice the two blank spaces, which return the definitions rather than their uses. One of the results is --ribbon-background, which sounds promising. To be sure, you can also inspect the HTML to find the CSS variable used by a specific element.\nIn the upper-left corner of the Developer Tool, select the icon that looks like a cursor on top of a rectangle. Select the middle of the ribbon on the left side of the Obsidian window. In the Styles tab, on the right side of the Developer Tools, you can now see the CSS that is applied to the element you selected, such as background-color: var(--ribbon-background).\nNow that you know --ribbon-background controls the ribbon background color, add the following to theme.css:\nbody { --ribbon-background: magenta; } Conclusion In this tutorial, you’ve built your first Obsidian theme. You’ve modified the theme and reloaded it to reflect the changes inside Obsidian. You’ve also seen how you can find the CSS variables to style specific parts of the user interface.\n","categories":"","description":"","excerpt":"In this tutorial, you’ll learn how to start developing a theme for …","ref":"/themes/app-themes/build-a-theme/","tags":"","title":""},{"body":"이 튜토리얼에서는 Obsidian용 테마 개발을 시작하는 방법을 배웁니다. 테마를 사용하면 CSS를 사용하여 Obsidian의 모양과 느낌을 사용자 정의할 수 있습니다.\n학습 내용 이 튜토리얼을 완료하면 다음을 할 수 있게 됩니다:\nObsidian 테마 개발을 위한 환경 구성 CSS 변수를 사용하여 Obsidian의 모양 변경 라이트 및 다크 색상 구성표를 모두 지원하는 테마 만들기 필수 조건 이 튜토리얼을 완료하려면 다음이 필요합니다:\n로컬 머신에 설치된 Git Visual Studio Code와 같은 코드 에디터 1단계: 샘플 테마 다운로드 이 단계에서는 Obsidian이 찾을 수 있도록 볼트의 .obsidian 디렉토리 내 themes 디렉토리에 샘플 테마를 다운로드합니다.\n이 튜토리얼에서 사용할 샘플 테마는 GitHub 저장소에서 사용할 수 있습니다.\n터미널 창을 열고 프로젝트 디렉토리를 themes 디렉토리로 변경합니다.\ncd path/to/vault/.obsidian/themes Git을 사용하여 샘플 테마를 복제합니다.\ngit clone https://github.com/obsidianmd/obsidian-sample-theme.git \"Sample Theme\" [!tip] GitHub 템플릿 저장소 샘플 테마의 저장소는 GitHub 템플릿 저장소이므로 샘플 테마에서 자신만의 저장소를 만들 수 있습니다. 방법을 알아보려면 템플릿에서 저장소 만들기를 참조하세요.\n샘플 테마를 복제할 때는 자신의 저장소 URL을 사용하는 것을 잊지 마세요.\n2단계: 테마 활성화 Obsidian에서 설정을 엽니다. 사이드 메뉴에서 모양을 선택합니다. 테마 옆의 드롭다운 목록에서 Sample Theme을 선택합니다. 샘플 테마를 활성화했습니다. 다음으로 몇 가지 변경 사항을 적용해 보겠습니다.\n3단계: 매니페스트 업데이트 이 단계에서는 매니페스트 manifest.json을 업데이트하여 테마 이름을 변경합니다. 매니페스트에는 테마의 이름과 설명 같은 정보가 포함되어 있습니다.\n코드 에디터에서 manifest.json을 엽니다.\nname을 \"Disco Lights\"와 같은 사용자 친화적인 이름으로 변경합니다.\nthemes 아래의 테마 디렉토리 이름을 동일한 이름으로 변경합니다. 테마 디렉토리 이름은 manifest.json의 name 속성과 정확히 일치해야 합니다.\nmv \"Sample Theme\" \"Disco Lights\" 매니페스트의 새 변경 사항을 로드하려면 Obsidian을 다시 시작합니다.\n설정 → 모양 → 테마로 돌아가서 테마 이름이 변경된 것을 확인하세요.\nmanifest.json을 변경할 때마다 Obsidian을 다시 시작하는 것을 잊지 마세요.\n4단계: 글꼴 변경 Obsidian은 CSS 변수를 사용하여 사용자 인터페이스를 스타일링합니다. 이 단계에서는 CSS 변수를 사용하여 에디터의 글꼴을 변경합니다.\n예를 들어 “테마 개발\"이라는 새 노트를 만듭니다.\n노트에 다음 텍스트를 입력합니다:\n테마를 사용하면 [Obsidian](https://obsidian.md)을 원하는 대로 꾸밀 수 있습니다. theme.css에 다음을 추가합니다:\nbody { --font-text-theme: Georgia, serif; } 에디터는 정의한 글꼴을 사용하여 노트를 표시합니다.\n5단계: 배경색 변경 테마는 라이트 및 다크 색상 구성표를 모두 지원할 수 있습니다. .theme-dark 또는 .theme-light 아래에 CSS 변수를 정의하세요.\ntheme.css에 다음을 추가합니다:\n.theme-dark { --background-primary: #18004F; --background-secondary: #220070; } .theme-light { --background-primary: #ECE4FF; --background-secondary: #D9C9FF; } Obsidian에서 설정을 엽니다.\n모양 아래에서 기본 색상 구성표를 “라이트\"와 “다크” 사이에서 전환합니다.\nObsidian이 선택한 색상 구성표에 따라 색상을 선택하는 것을 볼 수 있습니다. 더 극적인 변화를 위해 색상을 red, green 또는 blue로 변경해 보세요.\n6단계: 입력 필드 호버 테두리 색상 변경 :root 선택자는 테마 내의 모든 자식 요소에서 변수에 액세스하려는 경우 일반적으로 사용됩니다. 이 선택자는 종종 플러그인 변수로 채워집니다.\n사용법을 설명하는 예는 다음과 같습니다:\n[!example] 설정 및 노트 내용과 같이 Obsidian 내 다양한 위치에서 찾을 수 있는 입력 필드를 생각해 보겠습니다. 이 입력 필드에 특정한 변수를 정의하려면 :root 선택자를 사용할 수 있습니다.\n:root { --input-focus-border-color: Highlight; --input-focus-outline: 1px solid Canvas; --input-unfocused-border-color: transparent; --input-disabled-border-color: transparent; --input-hover-border-color: black; /* 루트에 대한 기본 입력 변수 */ } 이제 CSS에서 호버 테두리 색상을 수정해 보겠습니다:\n:root { --input-hover-border-color: red; /* 검은색에서 빨간색으로 변경 */ } 이 업데이트를 통해 입력 필드 위로 마우스를 가져가면 테두리 색상이 밝은 빨간색으로 변경됩니다.\n[!tip] 라이트 및 다크 테마 모두에서 동일하게 유지되어야 하는 스타일을 정의할 때는 body 선택자를 사용하는 것이 좋습니다.\n라이트 및 다크 테마 간에 전환할 때 스타일이 변경되기를 원하는 경우에만 .theme-dark 또는 .theme-light 선택자를 사용하세요.\n또한 :root를 신중하고 고려하여 사용하는 것이 중요합니다. 변수를 body, .theme-dark 또는 .theme-light 선택자 내에 배치할 수 있다면 그렇게 하는 것이 좋습니다.\n7단계: 사용 중인 CSS 변수 찾기 Obsidian은 사용자 인터페이스의 다양한 부분을 사용자 정의하기 위해 400개 이상의 다양한 CSS 변수를 노출합니다. 이러한 변수 중 다수는 [[CSS variables]]에서 찾을 수 있습니다.\n또는 앱을 검사하여 특정 요소를 스타일링하는 데 사용되는 변수를 찾을 수 있습니다. 이 단계에서는 리본 배경을 변경하기 위한 CSS 변수를 찾습니다.\nObsidian에서 Ctrl+Shift+I(macOS에서는 Cmd+Option+I)를 눌러 개발자 도구를 엽니다. 소스 탭을 엽니다. 페이지 → top → obsidian.md 아래에서 app.css를 선택합니다. app.css의 맨 위로 스크롤하여 사용 가능한 모든 CSS 변수를 찾습니다. Ctrl+F(macOS에서는 Cmd+F)를 누르고 \" –ribbon-“을 입력하여 리본과 관련된 변수를 검색합니다. 두 개의 공백은 사용처가 아닌 정의를 반환합니다. 결과 중 하나는 --ribbon-background이며, 유망해 보입니다. 확실히 하려면 HTML을 검사하여 특정 요소에서 사용하는 CSS 변수를 찾을 수도 있습니다.\n개발자 도구의 왼쪽 상단 모서리에서 사각형 위에 커서가 있는 아이콘을 선택합니다. Obsidian 창 왼쪽의 리본 중앙을 선택합니다. 개발자 도구 오른쪽의 스타일 탭에서 선택한 요소에 적용된 CSS(예: background-color: var(--ribbon-background))를 볼 수 있습니다.\n이제 --ribbon-background가 리본 배경색을 제어한다는 것을 알았으므로 theme.css에 다음을 추가합니다:\nbody { --ribbon-background: magenta; } 결론 이 튜토리얼에서는 첫 번째 Obsidian 테마를 만들었습니다. 테마를 수정하고 다시 로드하여 Obsidian 내에서 변경 사항을 반영했습니다. 또한 사용자 인터페이스의 특정 부분을 스타일링하기 위한 CSS 변수를 찾는 방법도 배웠습니다.\n","categories":"","description":"","excerpt":"이 튜토리얼에서는 Obsidian용 테마 개발을 시작하는 방법을 배웁니다. 테마를 사용하면 CSS를 사용하여 Obsidian …","ref":"/ko/themes/app-themes/build-a-theme/","tags":"","title":""},{"body":"Learn how to include assets, such as fonts and images, in your theme.\n[!warning] Loading remote content For Obsidian to work offline and to preserve user privacy, themes [[Developer policies|aren’t allowed]] to load remote content over the network. For more information, refer to [[Theme guidelines#Keep resources local]]\nUse data URLs To include assets such as fonts, icons, and images in your theme, you need to embed them in the CSS file by passing a data URL to the url() function.\nTo create a data URL for your assets, create a URL using the following format:\nurl(\"data:\u003cMIME_TYPE\u003e;base64,\u003cBASE64_DATA\u003e\") Replace \u003cMIME_TYPE\u003e with the MIME type for your asset. If you don’t know it, refer to Common MIME types. Replace \u003cBASE64_DATA\u003e with the Base64 encoded representation of your asset. The following example embeds a GIF file as a background image:\nh1 { background-image: url(\"data:image/gif;base64,R0lGODdhAQADAPABAP////8AACwAAAAAAQADAAACAgxQADs=\") } Encode your assets For instructions on how to encode an asset into base64, refer to Encoding data into base64 format.\nYou can also use one of the many free online tools for encoding.\nFor fonts:\nWoff2Base for WOFF2 font files Aspose supports a wide variety of font formats For images:\nWebSemantics converts JPEG, JPG, GIF, PNG, SVG Base64 Guru supports a wide variety of image formats Yoksel URL-encoder for SVG optimized for SVG files Consider file size Embedding assets increases the file size of your theme, which may lead to poor performance in the following situations:\nDownloading and updating your theme from the community theme directory. Loading and using your theme in the Obsidian app. Editing your theme in a code editor. Consider breaking up your theme into multiple files using a CSS preprocessor, such as Sass or Less. ","categories":"","description":"","excerpt":"Learn how to include assets, such as fonts and images, in your theme. …","ref":"/themes/app-themes/embed-fonts-and-images-in-your-theme/","tags":"","title":""},{"body":"테마에 글꼴 및 이미지와 같은 자산을 포함하는 방법을 알아보세요.\n[!warning] 원격 콘텐츠 로딩 Obsidian이 오프라인에서 작동하고 사용자 개인 정보를 보호하기 위해 테마는 [[Developer policies|네트워크를 통해 원격 콘텐츠를 로드할 수 없습니다]]. 자세한 내용은 [[Theme guidelines#Keep resources local|자산을 로컬로 유지]]를 참조하세요.\n데이터 URL 사용 테마에 글꼴, 아이콘, 이미지와 같은 자산을 포함하려면 url() 함수에 데이터 URL을 전달하여 CSS 파일에 _포함_해야 합니다.\n자산에 대한 데이터 URL을 만들려면 다음 형식을 사용하여 URL을 만드세요:\nurl(\"data:\u003cMIME_TYPE\u003e;base64,\u003cBASE64_DATA\u003e\") \u003cMIME_TYPE\u003e을 자산의 MIME 유형으로 바꿉니다. 모르는 경우 일반적인 MIME 유형을 참조하세요. \u003cBASE64_DATA\u003e를 자산의 Base64 인코딩 표현으로 바꿉니다. 다음 예제는 GIF 파일을 배경 이미지로 포함합니다:\nh1 { background-image: url(\"data:image/gif;base64,R0lGODdhAQADAPABAP////8AACwAAAAAAQADAAACAgxQADs=\") } 자산 인코딩 자산을 base64로 인코딩하는 방법에 대한 지침은 데이터를 base64 형식으로 인코딩을 참조하세요.\n인코딩을 위한 많은 무료 온라인 도구 중 하나를 사용할 수도 있습니다.\n글꼴의 경우:\nWOFF2 글꼴 파일용 Woff2Base Aspose는 다양한 글꼴 형식을 지원합니다. 이미지의 경우:\nWebSemantics는 JPEG, JPG, GIF, PNG, SVG를 변환합니다. Base64 Guru는 다양한 이미지 형식을 지원합니다. Yoksel URL-encoder for SVG는 SVG 파일에 최적화되어 있습니다. 파일 크기 고려 자산을 포함하면 테마의 파일 크기가 증가하여 다음과 같은 상황에서 성능이 저하될 수 있습니다:\n커뮤니티 테마 디렉토리에서 테마 다운로드 및 업데이트 Obsidian 앱에서 테마 로드 및 사용 코드 에디터에서 테마 편집. Sass 또는 Less와 같은 CSS 전처리기를 사용하여 테마를 여러 파일로 나누는 것을 고려하세요. ","categories":"","description":"","excerpt":"테마에 글꼴 및 이미지와 같은 자산을 포함하는 방법을 알아보세요.\n[!warning] 원격 콘텐츠 로딩 Obsidian이 오프 …","ref":"/ko/themes/app-themes/embed-fonts-and-images-in-your-theme/","tags":"","title":""},{"body":"Manually releasing your theme can be time-consuming and error-prone. In this guide, you’ll configure your theme to use GitHub Actions to automatically create a release when you create a new tag.\nIn the root directory of your theme, create a file called release.yml under .github/workflows with the following content:\nname: Release Obsidian theme on: push: tags: - \"*\" jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: Create release env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} run: | tag=\"${GITHUB_REF#refs/tags/}\" gh release create \"$tag\" \\ --title=\"$tag\" \\ --generate-notes \\ --draft \\ manifest.json theme.css In your terminal, commit the workflow.\ngit add .github/workflows/release.yml git commit -m \"Add release workflow\" git push origin main Create a tag that matches the version in the manifest.json file.\ngit tag -a 1.0.1 -m \"1.0.1\" git push origin 1.0.1 -a creates an annotated tag. -m specifies the name of your release. For Obsidian plugins, this must be the same as the version. Browse to your repository on GitHub and select the Actions tab. Your workflow might still be running, or it might have finished already.\nWhen the workflow finishes, go back to the main page for your repository and select Releases in the sidebar on the right side. The workflow has created a draft GitHub release and uploaded the required assets as binary attachments.\nSelect Edit (pencil icon) on the right side of the release name.\nAdd release notes to let users know what happened in this release, and then select Publish release.\nYou’ve successfully set up your theme to automatically create a GitHub release whenever you create a new tag.\nIf this is the first release for this theme, you’re now ready to [[Submit your theme]]. If this is an update to an already published theme, your users can now update to the latest version. ","categories":"","description":"","excerpt":"Manually releasing your theme can be time-consuming and error-prone. …","ref":"/themes/app-themes/release-your-theme-with-github-actions/","tags":"","title":""},{"body":"테마를 수동으로 릴리스하는 것은 시간이 많이 걸리고 오류가 발생하기 쉽습니다. 이 가이드에서는 새 태그를 만들 때 GitHub Actions를 사용하여 자동으로 릴리스를 생성하도록 테마를 구성합니다.\n테마의 루트 디렉토리에서 .github/workflows 아래에 다음 내용으로 release.yml 파일을 만듭니다:\nname: Obsidian 테마 릴리스 on: push: tags: - \"*\" jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - name: 릴리스 생성 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} run: | tag=\"${GITHUB_REF#refs/tags/}\" gh release create \"$tag\" \\ --title=\"$tag\" \\ --generate-notes \\ --draft \\ manifest.json theme.css 터미널에서 워크플로우를 커밋합니다.\ngit add .github/workflows/release.yml git commit -m \"릴리스 워크플로우 추가\" git push origin main manifest.json 파일의 버전과 일치하는 태그를 만듭니다.\ngit tag -a 1.0.1 -m \"1.0.1\" git push origin 1.0.1 -a는 주석 태그를 만듭니다. -m은 릴리스 이름을 지정합니다. Obsidian 플러그인의 경우 버전과 동일해야 합니다. GitHub에서 저장소로 이동하여 Actions 탭을 선택합니다. 워크플로우가 아직 실행 중이거나 이미 완료되었을 수 있습니다.\n워크플로우가 완료되면 저장소의 기본 페이지로 돌아가서 오른쪽 사이드바에서 Releases를 선택합니다. 워크플로우가 초안 GitHub 릴리스를 만들고 필요한 자산을 바이너리 첨부 파일로 업로드했습니다.\n릴리스 이름 오른쪽에 있는 Edit(연필 아이콘)를 선택합니다.\n릴리스 노트를 추가하여 사용자에게 이 릴리스에서 변경된 내용을 알린 다음 Publish release를 선택합니다.\n이제 새 태그를 만들 때마다 자동으로 GitHub 릴리스를 생성하도록 테마를 성공적으로 설정했습니다.\n이 테마의 첫 번째 릴리스인 경우 이제 [[Submit your theme|테마를 제출]]할 준비가 되었습니다. 이미 게시된 테마에 대한 업데이트인 경우 사용자는 이제 최신 버전으로 업데이트할 수 있습니다. ","categories":"","description":"","excerpt":"테마를 수동으로 릴리스하는 것은 시간이 많이 걸리고 오류가 발생하기 쉽습니다. 이 가이드에서는 새 태그를 만들 때 GitHub …","ref":"/ko/themes/app-themes/release-your-theme-with-github-actions/","tags":"","title":""},{"body":"If you want to share your theme with the Obsidian community, the best way is to submit it to the official list of themes. Once we’ve reviewed and published your theme, users can install it directly from within Obsidian. It’ll also be featured in the plugin directory on the Obsidian website.\nYou only need to submit the initial version of your theme. After your theme has been published, users can automatically download new releases from GitHub directly from within Obsidian.\nPrerequisites To complete this guide, you’ll need:\nA GitHub account. Before you begin Before you submit your theme, make sure you have the following files in the root folder of your repository:\nA README.md that describes the theme. A LICENSE that determines how others are allowed to use the theme and its source code. If you need help to pick a license for your theme, refer to Choose a License. A screenshot of your theme to be displayed in the community theme store. Recommended image dimensions: 512 x 288 pixels. A manifest.json that describes your theme. For more information, refer to [[Manifest]]. Step 1: Publish your theme to GitHub [!note] Template repositories If you created your theme from one of our template repositories, you may skip this step.\nTo review your theme, we need to access to the source code on GitHub. If you’re unfamiliar with GitHub, refer to the GitHub docs for how to Create a new repository.\nStep 2: Submit your theme for review In this step, you’ll submit your theme to the Obsidian team for review.\nIn community-css-themes.json, add a new entry at the end of the JSON array. The following example shows the entry for the Minimal theme.\n{ \"name\": \"Minimal\", \"author\": \"kepano\", \"repo\": \"kepano/obsidian-minimal\", \"screenshot\": \"dark-simple.png\", \"modes\": [\"dark\", \"light\"] }, name and author determines how your plugin appears to the user, and should match the corresponding properties in your [[Manifest]]. repo is the path to your GitHub repository. For example, if your GitHub repo is located at https://github.com/your-username/your-repo-name, the path is your-username/your-repo-name. screenshot is the path to a screenshot of your theme. The screenshot looks best with a 16:9 aspect ratio. Recommended image dimensions: 512 x 288 pixels. modes lists the color modes that your theme supports. Remember to add a comma after the closing brace, }, of the previous entry.\nSelect Commit changes… in the upper-right corner.\nSelect Propose changes.\nSelect Create pull request.\nSelect Preview, and then select Community Theme.\nClick Create pull request.\nIn the name of the pull request, enter “Add […] theme”, where […] is the name of your theme.\nFill in the details in the description for the pull request. For the checkboxes, insert an x between the brackets, [x], to mark them as done.\nClick Create pull request (for the last time 🤞).\nYou’ve now submitted your theme to the Obsidian theme directory. Sit back and wait for us to review your submission.\n[!question] How long does it take to review my theme? The time it takes to review your submission depends on the current workload of the Obsidian team. The team is still small, so please be patient while you wait for your theme to be reviewed. We’re currently unable to give any estimates on when we’ll be able to review your submission.\nStep 4: Address review comments Once a reviewer has reviewed your theme, they’ll add a comment to your pull request with the result of the review. The reviewer may require that you update your theme, or they can offer suggestions on how you can improve it.\nAddress any required changes and update the GitHub release with the new changes. Leave a comment on the PR to let us know you’ve addressed the feedback. Don’t open a new PR.\nWe’ll publish the theme as soon we’ve verified that all required changes have been addressed.\n[!note] While only Obsidian team members can publish your theme, other community members may also offer to review your submission in the meantime.\nNext steps Once we’ve reviewed and published your theme, it’s time to announce it to the community:\nAnnounce in Share \u0026 showcase in the forums. Announce in the #updates channel on Discord. You need the developer role to post in #updates. ","categories":"","description":"","excerpt":"If you want to share your theme with the Obsidian community, the best …","ref":"/themes/app-themes/submit-your-theme/","tags":"","title":""},{"body":"Obsidian 커뮤니티와 테마를 공유하려면 공식 테마 목록에 제출하는 것이 가장 좋은 방법입니다. 검토 후 테마가 게시되면 사용자는 Obsidian 내에서 직접 설치할 수 있으며 플러그인 디렉토리에도 소개됩니다.\n테마의 초기 버전만 제출하면 됩니다. 테마가 게시된 후 사용자는 GitHub에서 새 릴리스를 Obsidian 내에서 자동으로 다운로드할 수 있습니다.\n필수 조건 이 가이드를 완료하려면 다음이 필요합니다:\nGitHub 계정 시작하기 전에 테마를 제출하기 전에 저장소 루트 폴더에 다음 파일이 있는지 확인하세요:\n테마를 설명하는 README.md 파일 테마와 소스 코드 사용 방식을 결정하는 LICENSE 파일. 라이선스 선택에 도움이 필요하면 Choose a License를 참조하세요. 커뮤니티 테마 스토어에 표시될 테마 스크린샷 (권장 이미지 크기: 512 x 288 픽셀) 테마를 설명하는 manifest.json 파일. 자세한 내용은 [[Manifest]]를 참조하세요. 1단계: GitHub에 테마 게시 [!note] 템플릿 저장소 템플릿 저장소에서 테마를 생성한 경우 이 단계를 건너뛸 수 있습니다.\n테마를 검토하려면 GitHub의 소스 코드에 액세스할 수 있어야 합니다. GitHub에 익숙하지 않은 경우 새 저장소 만들기 방법을 참조하세요.\n2단계: 테마 검토 요청 이 단계에서는 Obsidian 팀에 테마 검토를 요청합니다.\ncommunity-css-themes.json에서 JSON 배열 끝에 새 항목을 추가하세요. 다음은 Minimal 테마의 예시입니다.\n{ \"name\": \"Minimal\", \"author\": \"kepano\", \"repo\": \"kepano/obsidian-minimal\", \"screenshot\": \"dark-simple.png\", \"modes\": [\"dark\", \"light\"] }, name과 author는 사용자에게 표시되는 방식이며 [[Manifest]]의 해당 속성과 일치해야 합니다. repo는 GitHub 저장소 경로입니다 (예: your-username/your-repo-name). screenshot은 테마 스크린샷 경로입니다 (권장 비율 16:9, 크기 512 x 288 픽셀). modes는 테마가 지원하는 색상 모드를 나열합니다. 이전 항목의 닫는 중괄호 } 뒤에 쉼표를 추가하는 것을 잊지 마세요.\n오른쪽 상단에서 Commit changes… 선택\nPropose changes 선택\nCreate pull request 선택\nPreview → Community Theme 선택\nCreate pull request 클릭\n풀 리퀘스트 제목에 “Add […] theme” 입력 (여기서 […]는 테마 이름)\n설명란에 세부 정보 작성. 체크박스는 [x]로 표시\nCreate pull request 클릭 (마지막으로 🤞)\n이제 테마를 Obsidian 테마 디렉토리에 제출했습니다. 검토가 완료될 때까지 기다리세요.\n[!question] 검토에 얼마나 걸리나요? 검토 시간은 Obsidian 팀의 작업량에 따라 다릅니다. 팀 규모가 작으므로 검토가 완료될 때까지 기다려 주세요. 현재 검토 예상 시간을 알려드릴 수 없습니다.\n3단계: 검토 의견 처리 검토자가 테마를 검토한 후 풀 리퀘스트에 검토 결과를 댓글로 추가합니다. 테마 업데이트를 요구하거나 개선 사항을 제안할 수 있습니다.\n필요한 변경 사항을 처리하고 GitHub 릴리스를 업데이트하세요. PR에 댓글을 남겨 피드백을 처리했음을 알리세요. 새 PR을 열지 마세요.\n필요한 모든 변경 사항이 처리되면 테마를 게시할 것입니다.\n[!note] Obsidian 팀원만 테마를 게시할 수 있지만, 그동안 다른 커뮤니티 구성원이 검토를 도울 수 있습니다.\n다음 단계 테마가 검토되고 게시되면 커뮤니티에 알릴 차례입니다:\n포럼의 Share \u0026 showcase에 공지 Discord의 #updates 채널에 공지 (developer 역할 필요) ","categories":"","description":"","excerpt":"Obsidian 커뮤니티와 테마를 공유하려면 공식 테마 목록에 제출하는 것이 가장 좋은 방법입니다. 검토 후 테마가 게시되면  …","ref":"/ko/themes/app-themes/submit-your-theme/","tags":"","title":""},{"body":"This page lists our recommendations for building themes that are both reliable and maintainable. By following these guidelines, you can minimize the maintenance work to keep your theme updated with future versions of Obsidian.\nFor more information about general guidelines for developers, refer to [[Developer policies]].\nUse CSS variables Since most of Obsidian’s user interface uses CSS variables, you can create highly expressive themes by merely overriding the built-in CSS variables.\nOverride general variables under body, and colors under .theme-light or .theme-dark.\n:root { --input-focus-border-color: Highlight; } body { --font-text-size: 18px; } .theme-light { --background-primary: white; } .theme-dark { --background-primary: black; } Use selectors with low specificity Avoid overly complex selectors targeting specific classes. [[#Use CSS variables]] to keep your selectors simple.\nThe most common issues when maintaining a theme are due to broken selectors as a result of new versions of Obsidian, which may change class names and how elements are nested.\nKeep assets local Per [[Developer policies]] community themes must not load remote assets, such as fonts and images, that are unavailable when the user is offline. Even if the user has access to the internet, loading remote assets may violate user privacy.\nIf you wish to submit your theme to the official Community Themes directory, your theme must not make network calls, and therefore all resources must be bundled into your theme. See our guide [[Embed fonts and images in your theme]].\nAvoid !important declarations Declaring styles as !important prevents users from overriding styles from your theme using snippets.\n","categories":"","description":"","excerpt":"This page lists our recommendations for building themes that are both …","ref":"/themes/app-themes/theme-guidelines/","tags":"","title":""},{"body":"이 페이지는 안정적이고 유지보수 가능한 테마를 구축하기 위한 권장 사항을 나열합니다. 이 가이드라인을 따르면 향후 Obsidian 버전과 함께 테마를 업데이트하는 데 필요한 유지보수 작업을 최소화할 수 있습니다.\n개발자를 위한 일반적인 가이드라인에 대한 자세한 내용은 [[Developer policies]]를 참조하세요.\nCSS 변수 사용 Obsidian의 대부분의 사용자 인터페이스는 CSS 변수를 사용하므로, 기본 제공 CSS 변수를 재정의하는 것만으로도 매우 표현력 있는 테마를 만들 수 있습니다.\n일반 변수는 body 아래에서, 색상은 .theme-light 또는 .theme-dark 아래에서 재정의하세요.\n:root { --input-focus-border-color: Highlight; } body { --font-text-size: 18px; } .theme-light { --background-primary: white; } .theme-dark { --background-primary: black; } 낮은 특이도 선택자 사용 특정 클래스를 대상으로 하는 지나치게 복잡한 선택자는 피하세요. [[#Use CSS variables|CSS 변수 사용]]으로 선택자를 단순하게 유지하세요.\n테마를 유지보수할 때 가장 흔히 발생하는 문제는 Obsidian의 새 버전으로 인해 클래스 이름과 요소 중첩 방식이 변경되어 선택자가 깨지는 경우입니다.\n자산을 로컬로 유지 [[Developer policies|개발자 정책]]에 따라 커뮤니티 테마는 사용자가 오프라인 상태일 때 사용할 수 없는 글꼴 및 이미지와 같은 원격 자산을 로드해서는 안 됩니다. 사용자가 인터넷에 액세스할 수 있는 경우에도 원격 자산을 로드하면 사용자 개인 정보를 침해할 수 있습니다.\n공식 커뮤니티 테마 디렉토리에 테마를 제출하려는 경우 네트워크 호출을 하지 않아야 하므로 모든 리소스를 테마에 번들로 포함해야 합니다. 가이드 [[Embed fonts and images in your theme|테마에 글꼴 및 이미지 포함하기]]를 참조하세요.\n!important 선언 피하기 스타일을 !important로 선언하면 사용자가 스니펫을 사용하여 테마의 스타일을 재정의할 수 없습니다.\n","categories":"","description":"","excerpt":"이 페이지는 안정적이고 유지보수 가능한 테마를 구축하기 위한 권장 사항을 나열합니다. …","ref":"/ko/themes/app-themes/theme-guidelines/","tags":"","title":""},{"body":"Obsidian Publish gives you several options for customizing how your Publish site looks.\nObsidian Publish allows you to customize the look of your site using CSS.\nThe following elements can be turned on or off in the Publish site settings and influence the layout of the site.\nReading experience Readable line length sets a maximum width for notes and centers the content on wide screens. Theme toggle displays a switch for light and dark mode. Stacked notes enables notes to stack and scroll horizontally when links are clicked, similar to Tab stacks in the Obsidian app. Components Navigation adds a left sidebar similar with a list of folders and files. Search displays a search input field, it may be positioned in the left sidebar, right sidebar or top navigation depending on which UI elements are active. Backlinks displays a list of backlinks at the bottom of the page. Graph displays the local graph in the right sidebar. Table of contents displays an outline of headings in the current page in the right sidebar. CSS variables Theming for Obsidian Publish is made simple with CSS variables. Learn more about CSS variables and how to use them.\nThe list of [[CSS variables]] available for customization fall into two groups:\nApp variables are inherited from the Obsidian app theme. These primarily control the colors and styling of the content. Publish-specific variables control the elements specific to Obsidian Publish. ","categories":"","description":"","excerpt":"Obsidian Publish gives you several options for customizing how your …","ref":"/themes/obsidian-publish-themes/about-obsidian-publish-themes/","tags":"","title":""},{"body":"Obsidian Publish는 Publish 사이트의 모양을 사용자 정의할 수 있는 여러 옵션을 제공합니다.\nObsidian Publish를 사용하면 CSS를 사용하여 사이트의 모양을 사용자 정의할 수 있습니다.\n다음 요소는 Publish 사이트 설정에서 켜거나 끌 수 있으며 사이트 레이아웃에 영향을 줍니다.\n읽기 경험 읽기 쉬운 줄 길이는 노트의 최대 너비를 설정하고 넓은 화면에서 콘텐츠를 중앙에 배치합니다. 테마 토글은 라이트 및 다크 모드 전환 스위치를 표시합니다. 스택 노트는 Obsidian 앱의 탭 스택과 유사하게 링크를 클릭하면 노트가 스택되고 가로로 스크롤되도록 합니다. 구성 요소 탐색은 폴더 및 파일 목록이 있는 왼쪽 사이드바와 유사한 것을 추가합니다. 검색은 검색 입력 필드를 표시하며, 활성 UI 요소에 따라 왼쪽 사이드바, 오른쪽 사이드바 또는 상단 탐색에 위치할 수 있습니다. 백링크는 페이지 하단에 백링크 목록을 표시합니다. 그래프는 오른쪽 사이드바에 로컬 그래프를 표시합니다. 목차는 오른쪽 사이드바에 현재 페이지의 제목 개요를 표시합니다. CSS 변수 Obsidian Publish의 테마 설정은 CSS 변수로 간단하게 만들 수 있습니다. CSS 변수 및 사용 방법에 대해 자세히 알아보세요.\n사용자 정의에 사용할 수 있는 [[CSS variables]] 목록은 두 그룹으로 나뉩니다:\n앱 변수는 Obsidian 앱 테마에서 상속됩니다. 주로 콘텐츠의 색상과 스타일을 제어합니다. Publish 관련 변수는 Obsidian Publish에 특정한 요소를 제어합니다. ","categories":"","description":"","excerpt":"Obsidian Publish는 Publish 사이트의 모양을 사용자 정의할 수 있는 여러 옵션을 제공합니다.\nObsidian …","ref":"/ko/themes/obsidian-publish-themes/about-obsidian-publish-themes/","tags":"","title":""},{"body":"Obsidian App and Obsidian Publish are different contexts Obsidian Publish shares common code and UI principles with Obsidian App, but also has some important differences that you should consider when creating themes. A few rules of thumb to keep in mind:\nAvoid complex selectors, use the available [[CSS variables]] instead. Avoid including CSS selectors and rules that are specific to Obsidian App. Keep CSS file size small so it loads fast for visitors. Consider compatibility across browsers and screen sizes. App-specific and Publish-specific CSS rules While Obsidian App and Obsidian Publish share some common code, most App themes are designed to target CSS classes that are not present in the Publish context. For this reason, we recommend building Publish themes from the ground up, to minimize the amount of unnecessary code.\nFile size Obsidian App themes are stored locally on the user’s device, whereas Obsidian Publish themes are loaded each time a user vists the site. For this reason, Obsidian Publish themes should be mindful of file size.\nKeeping your theme file small will avoid flashes of unstyled content, and load faster on a variety of devices and internet connections. Ideally your publish.css file should be as small as possible.\nIn the App context it is acceptable to embed fonts and images in the CSS file using base64 encoding. In the Publish context, we recommend that you avoid this approach, especially if it leads to larger file sizes (multiple megabytes) that may block rendering when a visitor accesses the site.\nBrowser compatibility Visitors to Publish sites may use older browsers that are not compatible with new CSS features. For this reason we recommend being conservative with advanced CSS features in the Publish context. This is in contrast to Obsidian App themes which target a narrow scope of rendering engines (recent versions of Chromium/Blink) that support newer browser features. Try searching caniuse.com to see which CSS features are broadly available across browsers.\nSmall screens and mobile devices Obsidian Publish has two breakpoints by default:\nBreakpoint Device Effect 1000px Tablet Right sidebar is hidden 750px Mobile Left and right sidebars are hidden. If enabled, navigation is accessible via hamburger menu in the top left corner You can target these devices using CSS. Any rules defined outside of the @media query will apply to all devices.\n@media screen and (min-width: 1000px) { /* ... rules and variables for screens larger than tablet */ } @media screen and (max-width: 1000px) { /* ... rules and variables for tablet devices and smaller */ } @media screen and (max-width: 750px) { /* ... rules and variables for mobile devices and smaller */ } ","categories":"","description":"","excerpt":"Obsidian App and Obsidian Publish are different contexts Obsidian …","ref":"/themes/obsidian-publish-themes/best-practices-for-publish-themes/","tags":"","title":""},{"body":"Obsidian 앱과 Obsidian Publish는 다른 컨텍스트입니다 Obsidian Publish는 Obsidian 앱과 공통 코드 및 UI 원칙을 공유하지만, 테마를 만들 때 고려해야 할 몇 가지 중요한 차이점이 있습니다. 명심해야 할 몇 가지 경험 법칙:\n복잡한 선택자를 피하고 사용 가능한 [[CSS variables]]를 대신 사용하세요. Obsidian 앱에 특정한 CSS 선택자 및 규칙을 포함하지 마세요. 방문자가 빠르게 로드할 수 있도록 CSS 파일 크기를 작게 유지하세요. 브라우저 및 화면 크기 간의 호환성을 고려하세요. 앱별 및 Publish별 CSS 규칙 Obsidian 앱과 Obsidian Publish는 일부 공통 코드를 공유하지만, 대부분의 앱 테마는 Publish 컨텍스트에 없는 CSS 클래스를 대상으로 하도록 설계되었습니다. 이러한 이유로 불필요한 코드를 최소화하기 위해 Publish 테마를 처음부터 구축하는 것이 좋습니다.\n파일 크기 Obsidian 앱 테마는 사용자 장치에 로컬로 저장되는 반면, Obsidian Publish 테마는 사용자가 사이트를 방문할 때마다 로드됩니다. 이러한 이유로 Obsidian Publish 테마는 파일 크기에 유의해야 합니다.\n테마 파일을 작게 유지하면 스타일이 지정되지 않은 콘텐츠의 깜박임을 피하고 다양한 장치 및 인터넷 연결에서 더 빠르게 로드됩니다. 이상적으로 publish.css 파일은 가능한 한 작아야 합니다.\n앱 컨텍스트에서는 base64 인코딩을 사용하여 CSS 파일에 글꼴과 이미지를 포함하는 것이 허용됩니다. Publish 컨텍스트에서는 방문자가 사이트에 액세스할 때 렌더링을 차단할 수 있는 더 큰 파일 크기(수 메가바이트)로 이어지는 경우 이 접근 방식을 피하는 것이 좋습니다.\n브라우저 호환성 Publish 사이트 방문자는 새로운 CSS 기능과 호환되지 않는 이전 브라우저를 사용할 수 있습니다. 이러한 이유로 Publish 컨텍스트에서는 고급 CSS 기능을 보수적으로 사용하는 것이 좋습니다. 이는 최신 브라우저 기능을 지원하는 좁은 범위의 렌더링 엔진(최신 버전의 Chromium/Blink)을 대상으로 하는 Obsidian 앱 테마와 대조됩니다. caniuse.com을 검색하여 브라우저 전반에서 널리 사용할 수 있는 CSS 기능을 확인해 보세요.\n작은 화면 및 모바일 장치 Obsidian Publish에는 기본적으로 두 개의 중단점이 있습니다:\n중단점 장치 효과 1000px 태블릿 오른쪽 사이드바 숨김 750px 모바일 왼쪽 및 오른쪽 사이드바 숨김. 활성화된 경우 왼쪽 상단 모서리의 햄버거 메뉴를 통해 탐색 가능 CSS를 사용하여 이러한 장치를 대상으로 지정할 수 있습니다. @media 쿼리 외부에서 정의된 모든 규칙은 모든 장치에 적용됩니다.\n@media screen and (min-width: 1000px) { /* ... 태블릿보다 큰 화면에 대한 규칙 및 변수 */ } @media screen and (max-width: 1000px) { /* ... 태블릿 장치 및 더 작은 장치에 대한 규칙 및 변수 */ } @media screen and (max-width: 750px) { /* ... 모바일 장치 및 더 작은 장치에 대한 규칙 및 변수 */ } ","categories":"","description":"","excerpt":"Obsidian 앱과 Obsidian Publish는 다른 컨텍스트입니다 Obsidian Publish는 Obsidian …","ref":"/ko/themes/obsidian-publish-themes/best-practices-for-publish-themes/","tags":"","title":""},{"body":"You can build themes for your Obsidian Publish site. Themes for Obsidian Publish use the same [[CSS variables]] as the Obsidian app along with [[CSS variables#Obsidian Publish|Publish-specific CSS variables]].\n[!tip] See [[Build a theme]] for more in-depth information on the body, :root, .theme-dark, and .theme-light selectors.\nTo build a theme for your site:\nAdd a file called publish.css to the root folder of your vault. You need to use a external editor to create this file, as Obsidian does not support editing CSS files. Publish publish.css to enable the theme on your live Publish site. Example:\n.published-container { --page-width: 800px; --page-side-padding: 48px; /* ... CSS variables for Publish that do not change when light or dark mode is enabled. They sometimes link to color variables in .theme-light or .theme-dark */ } .theme-light { --background-primary: #ebf2ff; --h1-color: #000000; /* ... CSS color variables for when light mode is enabled */ } .theme-dark { --background-primary: #1f2a3f; --h1-color: #ffffff; /* ... CSS color variables for when dark mode is enabled */ } For more information on how to customize your site, refer to Customize your site.\n","categories":"","description":"","excerpt":"You can build themes for your Obsidian Publish site. Themes for …","ref":"/themes/obsidian-publish-themes/build-a-publish-theme/","tags":"","title":""},{"body":"Obsidian Publish 사이트용 테마를 만들 수 있습니다. Obsidian Publish용 테마는 Obsidian 앱과 동일한 [[CSS variables]] 및 [[CSS variables#Obsidian Publish|Publish 관련 CSS 변수]]를 사용합니다.\n[!tip] body, :root, .theme-dark, .theme-light 선택자에 대한 자세한 내용은 [[Build a theme]]를 참조하세요.\n사이트용 테마를 만들려면:\n볼트의 루트 폴더에 publish.css라는 파일을 추가합니다. Obsidian은 CSS 파일 편집을 지원하지 않으므로 외부 편집기를 사용하여 이 파일을 만들어야 합니다. publish.css를 게시하여 라이브 Publish 사이트에서 테마를 활성화합니다. 예시:\n.published-container { --page-width: 800px; --page-side-padding: 48px; /* ... 라이트 또는 다크 모드가 활성화되어도 변경되지 않는 Publish용 CSS 변수. 때로는 .theme-light 또는 .theme-dark의 색상 변수에 연결됩니다. */ } .theme-light { --background-primary: #ebf2ff; --h1-color: #000000; /* ... 라이트 모드가 활성화되었을 때의 CSS 색상 변수 */ } .theme-dark { --background-primary: #1f2a3f; --h1-color: #ffffff; /* ... 다크 모드가 활성화되었을 때의 CSS 색상 변수 */ } 사이트 사용자 정의에 대한 자세한 내용은 사이트 사용자 정의를 참조하세요.\n","categories":"","description":"","excerpt":"Obsidian Publish 사이트용 테마를 만들 수 있습니다. Obsidian Publish용 테마는 Obsidian …","ref":"/ko/themes/obsidian-publish-themes/build-a-publish-theme/","tags":"","title":""},{"body":"","categories":"","description":"","excerpt":"","ref":"/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/ko/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/","tags":"","title":"Obsidian Developer Docs"},{"body":"","categories":"","description":"","excerpt":"","ref":"/ko/","tags":"","title":"Obsidian Developer Docs"},{"body":"","categories":"","description":"","excerpt":"","ref":"/plugins/","tags":"","title":"Plugins"},{"body":"","categories":"","description":"","excerpt":"","ref":"/ko/plugins/","tags":"","title":"Plugins"},{"body":"","categories":"","description":"","excerpt":"","ref":"/reference/","tags":"","title":"References"},{"body":"","categories":"","description":"","excerpt":"","ref":"/ko/reference/","tags":"","title":"References"},{"body":"","categories":"","description":"","excerpt":"","ref":"/tags/","tags":"","title":"Tags"},{"body":"","categories":"","description":"","excerpt":"","ref":"/ko/tags/","tags":"","title":"Tags"},{"body":"","categories":"","description":"","excerpt":"","ref":"/themes/","tags":"","title":"Themes"},{"body":"","categories":"","description":"","excerpt":"","ref":"/ko/themes/","tags":"","title":"Themes"}]